{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Nushell",
  "home_page_url": "www.nushell.sh/de/",
  "feed_url": "www.nushell.sh/feed.json",
  "description": "Eine neue Art von Shell.",
  "items": [
    {
      "title": "Konfiguration von Drittanbieter-Prompts",
      "url": "www.nushell.sh/de/book/3rdpartyprompts.html",
      "id": "www.nushell.sh/de/book/3rdpartyprompts.html",
      "content_html": "<h1 id=\"konfiguration-von-drittanbieter-prompts\" tabindex=\"-1\"> Konfiguration von Drittanbieter-Prompts</h1>\n<h2 id=\"nerdfonts\" tabindex=\"-1\"> nerdfonts</h2>\n<p>nerdfonts sind nicht zwangsweise notwendig, machen aber die Darstellung viel besser.\nSie enthalten unter anderem Symbole für Betriebssysteme oder den Git-Status und graphische Formen für einen ansprechenden Prompt.</p>\n<p><a href=\"https://www.nerdfonts.com\" target=\"_blank\" rel=\"noopener noreferrer\">Webseite</a></p>\n<p><a href=\"https://github.com/ryanoasis/nerd-fonts\" target=\"_blank\" rel=\"noopener noreferrer\">Repository</a></p>\n<h2 id=\"oh-my-posh\" tabindex=\"-1\"> oh-my-posh</h2>\n<p><a href=\"https://ohmyposh.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">Webseite</a></p>\n<p><a href=\"https://github.com/JanDeDobbeleer/oh-my-posh\" target=\"_blank\" rel=\"noopener noreferrer\">Repository</a></p>\n<p>Wenn <a href=\"https://ohmyposh.dev/\" target=\"_blank\" rel=\"noopener noreferrer\">oh-my-posh</a> verwendet werden soll, kann dies in wenigen Schritten für Nushell erreicht werden. Die Integration in Nushell funktioniert sehr gut. Die folgenden Schritte werden dazu benötigt:</p>\n<ol>\n<li>oh-my-posh installieren und die Farbschemata herunterladen entsprechend dieser <a href=\"https://ohmyposh.dev/docs/linux#installation\" target=\"_blank\" rel=\"noopener noreferrer\">Anleitung</a></li>\n<li>Herunterladen und installieren einer <a href=\"https://github.com/ryanoasis/nerd-fonts\" target=\"_blank\" rel=\"noopener noreferrer\">nerd font</a>.</li>\n<li>Die Umgebungsvariable <code>PROMPT_COMMAND</code> durch hinzufügen der folgenden Zeile in <code>~/.config/nushell/config.nu</code> setzen. Den Style <code>M365Princess.omp.json</code> kann man entsprechend der <a href=\"https://ohmyposh.dev/docs/themes\" target=\"_blank\" rel=\"noopener noreferrer\">Demo</a> beliebig ändern .</li>\n</ol>\n<div><pre><code><span>></span> let-env PROMPT_COMMAND <span>=</span> <span>{</span> oh-my-posh --config ~/.poshthemes/M365Princess.omp.json <span>}</span>\n</code></pre></div><h2 id=\"starship\" tabindex=\"-1\"> Starship</h2>\n<p><a href=\"https://starship.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">Website</a></p>\n<p><a href=\"https://github.com/starship/starship\" target=\"_blank\" rel=\"noopener noreferrer\">Repository</a></p>\n<ol>\n<li>Den obigen Links folgen und starship installieren.</li>\n<li>nerdfonts entsprechend persönlicher Präferenzen installieren.</li>\n<li>Die <code>STARSHIP_SHELL</code> Umgebungsvariable auf <code>nu</code> setzen, indem der folgende Befehl ausgeführt wird: <code>let-env STARSHIP_SHELL = &quot;nu&quot;</code></li>\n<li>Wenn die standardmäßige Uhr mit Zeit und Datum auf der rechten Seite dargestellt werden soll, sollte der folgende Befehl ausgeführt werden: <code>hide PROMPT_COMMAND_RIGHT</code></li>\n<li>Wenn der standardmäßige Indikator verwendet werden soll, kann der folgende Befehl ausgeführt werden: <code>let-env PROMPT_INDICATOR = &quot; &quot;</code></li>\n<li>starship kann als Prompt auf der linken Seite mit dem folgenden Befehl festgelegt werden: <code>let-env PROMPT_COMMAND = { starship prompt --cmd-duration $env.CMD_DURATION_MS $'--status=($env.LAST_EXIT_CODE)' | str trim }</code>. Ein Hinweis: Unter Umständen muss <code>str trim</code> in der Nushell-Prompt nicht verwendet werden, wenn starship's standardmäßig aktive Einstellung für neue Zeilen in der <code>starship.toml</code> mittels <code>add_newline = false</code> deaktiviert wurde. Es gibt Berichte, dass dies teilweise nicht gut im Zusammenspiel mit Nushell-Prompts funktioniert. Wir arbeiten noch daran!</li>\n<li>Da Nushell Prompts auf der rechten Seite unterstützt, kann auch mit starship's Möglichkeit einer solchen Prompt experimentiert werden. Die rechte Prompt in Nushell zu setzen funktioniert identisch, wie das Setzen der Linken. Es muss lediglich <code>PROMPT_COMMAND_RIGHT</code> gesetzt werden.</li>\n</ol>\n<h2 id=\"purs\" tabindex=\"-1\"> Purs</h2>\n<p><a href=\"https://github.com/xcambar/purs\" target=\"_blank\" rel=\"noopener noreferrer\">Repository</a></p>\n",
      "date_modified": "2022-06-02T15:48:22.685Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Einführung",
      "url": "www.nushell.sh/de/book/",
      "id": "www.nushell.sh/de/book/",
      "content_html": "<h1 id=\"einfuhrung\" tabindex=\"-1\"> Einführung</h1>\n<p>Hallo und herzlich Willkommen beim Nushell Projekt. Das Ziel diese Projekts ist es, die Philosophie von Unix Shells, wo Pipes einfache Befehle miteinander verbinden, mit modernen Ansätzen zu verbinden.</p>\n<p>Nu ist von vielen Seiten beeinflusst: traditionelle Shells wie Bash, objektbasierte Shells wie PowerShell, funktionale Programmierung, Systems Programming und viele Weitere. Aber statt die eierlegende Wollmilchsau zu sein, liegt der Fokus von Nu darauf, die angebotenen Funktionen gut zu beherrschen:</p>\n<ul>\n<li>Flexible cross-plattform Shell mit einem modernen Verhalten</li>\n<li>Ausgaben von Kommandozeilenprogrammen mit einer Shell zu verarbeiten, die Struktur von Daten versteht</li>\n<li>Ein Interface besitzen, das den modernen Bedürfnissen gerecht wird</li>\n</ul>\n<p>Der einfachste Weg zu verstehen, was Nu alles leisten kann, ist entlang von Beispielen. Los geht's!</p>\n<p>Das Erste was auffällt, wenn ein Befehl wie <code>ls</code> ausgeführt wird, ist, dass anstatt eines Blocks von Text eine strukturierte Tabelle als Ausgabe erscheint.</p>\n<div><pre><code><span>></span> <span>ls</span>\n╭────┬───────────────────────┬──────┬───────────┬─────────────╮\n│ <span>#  │         name          │ type │   size    │  modified   │</span>\n├────┼───────────────────────┼──────┼───────────┼─────────────┤\n│  <span>0</span> │ <span>404</span>.html              │ <span>file</span> │     <span>429</span> B │ <span>3</span> days ago  │\n│  <span>1</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>8</span> mins ago  │\n│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>3</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │\n│  <span>4</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>5</span> │ README.md             │ <span>file</span> │     <span>213</span> B │ <span>3</span> days ago  │\n<span>..</span>.\n</code></pre></div><p>Diese Tabelle ist mehr als nur eine andere Darstellungsform. Wie Tabellen in Spreadsheets erlaubt es diese Tabelle mit den Daten interaktiver zu arbeiten.</p>\n<p>Um das zu demonstrieren, wird der Inhalt der Tabelle zunächst nach der Größe sortiert. Um das zu realisieren, wird die Ausgabe von <code>ls</code> genommen und in ein Befehl gegeben, der Tabellen auf Basis von Daten in einer Spalte neu anordnen kann.</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> reverse\n╭────┬───────────────────────┬──────┬───────────┬─────────────╮\n│ <span>#  │         name          │ type │   size    │  modified   │</span>\n├────┼───────────────────────┼──────┼───────────┼─────────────┤\n│  <span>0</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │\n│  <span>1</span> │ SUMMARY.md            │ <span>file</span> │   <span>3.7</span> KiB │ <span>3</span> days ago  │\n│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>3</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>4</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>9</span> mins ago  │\n│  <span>5</span> │ books.md              │ <span>file</span> │     <span>687</span> B │ <span>3</span> days ago  │\n<span>..</span>.\n</code></pre></div><p>Um das Ganze zu realisieren, mussten hierzu nicht Argumente an <code>ls</code> übergeben werden. Stattdessen wird der <code>sort-by</code> Befehl verwendet, den Nu bereitstellt, um Daten zu sortieren. Damit die größten Dateien oben erscheinen wurde zusätzlich die Option <code>reverse</code> angegeben.</p>\n<p>Nu stellt sehr viele Befehle bereit, die mit Tabellen arbeiten können. Beispielsweise kann die Ausgabe von <code>ls</code> auch derart gefiltert werden, dass nur Datei mit einer Größe von mehr als einem Kilobyte angezeigt werden:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 1kb\n╭───┬───────────────────┬──────┬─────────┬────────────╮\n│ <span># │       name        │ type │  size   │  modified  │</span>\n├───┼───────────────────┼──────┼─────────┼────────────┤\n│ <span>0</span> │ Gemfile           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │\n│ <span>1</span> │ Gemfile.lock      │ <span>file</span> │ <span>6.9</span> KiB │ <span>3</span> days ago │\n│ <span>2</span> │ LICENSE           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │\n│ <span>3</span> │ SUMMARY.md        │ <span>file</span> │ <span>3.7</span> KiB │ <span>3</span> days ago │\n╰───┴───────────────────┴──────┴─────────┴────────────╯\n</code></pre></div><p>Wie in der Unix-Philosophie, erlauben Befehle, die untereinander Daten austauschen können, viele verschiedene Kombinationen um Aufgaben zu lösen. Wie in folgendem Beispiel:</p>\n<div><pre><code><span>></span> <span>ps</span>\n╭─────┬──────┬──────────────────────┬─────────┬───────┬───────────┬──────────╮\n│  <span>#  │ pid  │         name         │ status  │  cpu  │    mem    │ virtual  │</span>\n├─────┼──────┼──────────────────────┼─────────┼───────┼───────────┼──────────┤\n│   <span>0</span> │ <span>7570</span> │ nu                   │ Running │  <span>1.96</span> │  <span>23.2</span> MiB │ <span>32.8</span> GiB │\n│   <span>1</span> │ <span>3533</span> │ remindd              │ Sleep   │  <span>0.00</span> │ <span>103.6</span> MiB │ <span>32.3</span> GiB │\n│   <span>2</span> │ <span>3495</span> │ TVCacheExtension     │ Sleep   │  <span>0.00</span> │  <span>11.9</span> MiB │ <span>32.2</span> GiB │\n│   <span>3</span> │ <span>3490</span> │ MusicCacheExtension  │ Sleep   │  <span>0.00</span> │  <span>12.9</span> MiB │ <span>32.2</span> GiB │\n<span>..</span>.\n</code></pre></div><p>Der <code>ps</code> Befehl erlaubt es auf Linux-Systemen alle laufenden Prozesse, deren Status und Name abzufragen. Des Weiteren gibt er Informationen zu CPU-Last der einzelnen Prozesse an.</p>\n<p>Was macht man, wenn man nur Prozesse sehen möchte, die aktuelle aktiv die CPU nutzen? Wie zuvor beim <code>ls</code> Befehl, kann mit der durch <code>ps</code> zurückgegebenen Tabelle gearbeitet werden:</p>\n<div><pre><code><span>></span> <span>ps</span> <span>|</span> where cpu <span>></span> <span>5</span>\n╭───┬──────┬────────────────┬─────────┬────────┬───────────┬──────────╮\n│ <span># │ pid  │      name      │ status  │  cpu   │    mem    │ virtual  │</span>\n├───┼──────┼────────────────┼─────────┼────────┼───────────┼──────────┤\n│ <span>0</span> │ <span>1583</span> │ Terminal       │ Running │  <span>20.69</span> │ <span>127.8</span> MiB │ <span>33.0</span> GiB │\n│ <span>1</span> │  <span>579</span> │ photoanalysisd │ Running │ <span>139.50</span> │  <span>99.9</span> MiB │ <span>32.3</span> GiB │\n╰───┴──────┴────────────────┴─────────┴────────┴───────────┴──────────╯\n</code></pre></div><p>Bis jetzt wurden <code>ls</code> und <code>ps</code> genutzt, um Dateien und Prozesse aufzulisten. Nu besitzt aber noch viele weitere Befehle die nützliche Informationen in Tabellenform ausgeben. Dazu wird nun ein Block auf die Befehle <code>date</code> und <code>sys</code> geworfen.</p>\n<p>Wenn <code>date now</code> aufgerufen wird, werden Informationen zum aktuellen Datum und der aktuellen Uhrzeit ausgegeben.</p>\n<div><pre><code><span>></span> <span>date</span> now\n<span>2022</span>-03-07 <span>14</span>:14:51.684619600 -08:00\n</code></pre></div><p>Um das Datum in Tabellenform zu bekommen, kann es zusätzlich in <code>date to-table</code> gegeben werden:</p>\n<div><pre><code><span>></span> <span>date</span> now <span>|</span> <span>date</span> to-table\n╭───┬──────┬───────┬─────┬──────┬────────┬────────┬──────────╮\n│ <span># │ year │ month │ day │ hour │ minute │ second │ timezone │</span>\n├───┼──────┼───────┼─────┼──────┼────────┼────────┼──────────┤\n│ <span>0</span> │ <span>2022</span> │     <span>3</span> │   <span>7</span> │   <span>14</span> │     <span>45</span> │      <span>3</span> │ -08:00   │\n╰───┴──────┴───────┴─────┴──────┴────────┴────────┴──────────╯\n</code></pre></div><p>Der Aufruf von <code>sys</code> gibt Informationen zum System aus, auf dem Nu läuft:</p>\n<div><pre><code><span>></span> sys\n╭───────┬───────────────────╮\n│ <span>host</span>  │ <span>{</span>record <span>6</span> fields<span>}</span> │\n│ cpu   │ <span>[</span>table <span>4</span> rows<span>]</span>    │\n│ disks │ <span>[</span>table <span>3</span> rows<span>]</span>    │\n│ mem   │ <span>{</span>record <span>4</span> fields<span>}</span> │\n│ temp  │ <span>[</span>table <span>1</span> row<span>]</span>     │\n│ net   │ <span>[</span>table <span>4</span> rows<span>]</span>    │\n╰───────┴───────────────────╯\n</code></pre></div><p>Diese Ausgabe unterscheidet sich nun von den vorherigen. Der <code>sys</code> Befehl gibt eine Tabelle zurück, die selbst strukturierte Tabellen in den Zellen enthält anstatt nur einfache Werte. Um auf die Daten zuzugreifen, wird der <em>get</em> Befehl verwendet:</p>\n<div><pre><code><span>></span> sys <span>|</span> get <span>host</span>\n╭────────────────┬────────────────────────╮\n│ name           │ Debian GNU/Linux       │\n│ os version     │ <span>11</span>                     │\n│ kernel version │ <span>5.10</span>.92-v8+            │\n│ <span>hostname</span>       │ lifeless               │\n│ <span>uptime</span>         │ 19day 21hr 34min 45sec │\n│ sessions       │ <span>[</span>table <span>1</span> row<span>]</span>          │\n╰────────────────┴────────────────────────╯\n</code></pre></div><p>Der <code>get</code> Befehl erlaubt es, in die Inhalte einer Tabellenzelle einzutauchen. Hier wird beispielsweise die Spalte &quot;host&quot; näher betrachtet, die Informationen über den Host, auf dem Nu läuft, enthält. Der Name des Betriebssystem (OS), die CPU und mehr. Nun sollen die Namen der Nutzer auf dem System ausgegeben werden:</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name\n╭───┬────╮\n│ <span>0</span> │ jt │\n╰───┴────╯\n</code></pre></div><p>Aktuelle existiert nur ein Nutzer namens &quot;jt&quot;. Wie zu sehen ist, kann ein ganzer Pfad für Spalten angegeben werden - nicht nur der Name der Spalte. Nu wird den Pfad nehmen und durch die entsprechenden Daten in der Tabelle gehen.</p>\n<p>Und noch etwas anderes ist anders. Anstatt einer Tabelle mit Daten wurde nur ein einzelnes Element ausgegeben: der String &quot;jt&quot;. Nu arbeitet sowohl mit Tabellen voller Daten als auch mit Strings. Strings sind ein wichtiger Bestandteil, um mit Befehlen außerhalb von Nu zu arbeiten.</p>\n<p>Nun soll aufgezeigt werden, wie mit Strings außerhalb von Nu gearbeitet wird. Dazu wird das vorige Beispiel erweitert. Die Daten werden an den externen <code>echo</code> Befehl weitergegeben (das <code>^</code> teilt Nu mit, dass nicht der eingebaute <code>echo</code> Befehl verwendet werden soll):</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> ^echo <span>$it</span> <span>}</span>\njt\n</code></pre></div><p>Das sieht jetzt genau gleich aus wie die Ausgabe zuvor. Was soll das? Es ist ähnlich aber mit einem entscheidenden Unterschied: <code>^echo</code> wurde aufgerufen. Das erlaubt es uns Daten aus Nu heraus an beliebige Befehle außerhalb von Nu zu geben wie <code>echo</code> oder <code>git</code>.</p>\n<p><em>Hinweis: Hilfe zu allen in Nu eingebauten Befehlen kann mit dem Befehl <code>help</code> angezeigt werden</em>:</p>\n<div><pre><code><span>></span> <span>help</span> path\nExplore and manipulate paths.\n\nThere are three ways to represent a path:\n\n* As a path literal, e.g., <span>'/home/viking/spam.txt'</span>\n* As a structured path: a table with <span>'parent'</span>, <span>'stem'</span>, and <span>'extension'</span> <span>(</span>and\n* <span>'prefix'</span> on Windows<span>)</span> columns. This <span>format</span> is produced by the <span>'path parse'</span>\n  subcommand.\n* As an inner list of path parts, e.g., <span>'[[ / home viking spam.txt ]]'</span><span>.</span>\n  Splitting into parts is <span>done</span> by the <span><span>`</span>path <span>split</span><span>`</span></span> command.\n\nAll subcommands accept all three variants as an input. Furthermore, the <span>'path\njoin'</span> subcommand can be used to <span>join</span> the structured path or path parts back into\nthe path literal.\n\nUsage:\n  <span>></span> path\n\nSubcommands:\n  path <span>basename</span> - Get the final component of a path\n  path <span>dirname</span> - Get the parent directory of a path\n  path exists - Check whether a path exists\n  path <span>expand</span> - Try to <span>expand</span> a path to its absolute form\n  path <span>join</span> - Join a structured path or a list of path parts.\n  path parse - Convert a path into structured data.\n  path relative-to - Get a path as relative to another path.\n  path <span>split</span> - Split a path into parts by a separator.\n  path <span>type</span> - Get the <span>type</span> of the object a path refers to <span>(</span>e.g., file, dir, symlink<span>)</span>\n\nFlags:\n  -h, --help\n      Display this <span>help</span> message\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.685Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Aliase",
      "url": "www.nushell.sh/de/book/aliase.html",
      "id": "www.nushell.sh/de/book/aliase.html",
      "content_html": "<h1 id=\"aliase\" tabindex=\"-1\"> Aliase</h1>\n<p>Aliase in Nushell bieten eine einfache Möglichkeit, um Texte zur ersetzen. Damit ist es möglich, einen Kurznamen für längere Befehle zu definieren - inklusive der Argumente.</p>\n<p>Beispielsweise kann ein Alias namens <code>ll</code> definiert werden, der den längeren Befehl <code>ls -l</code> ersetzt:</p>\n<div><pre><code>> alias ll = ls -l\n</code></pre></div><p>Nun kann der Alias aufgerufen werden:</p>\n<div><pre><code>> ll\n</code></pre></div><p>Wenn das getan wird, wirkt es, als sei <code>ls -l</code> aufgerufen worden. Das bietet auch die Möglichkeit weitere Parameter anzugeben. So kann auch geschrieben werden:</p>\n<div><pre><code>> ll -a\n</code></pre></div><p>Das ist äquivalent zu <code>ls -l -a</code>. Deutlich kürzer.</p>\n<h2 id=\"persistenz\" tabindex=\"-1\"> Persistenz</h2>\n<p>Für Informationen, um Aliase dauerhaft zu speichern, damit diese immer in Nushell nutzbar sind, kann ein Blick auf das <a href=\"/de/book/konfiguration.html\">Konfigurationskapitel</a> geworfen werden.</p>\n",
      "date_modified": "2022-06-02T15:48:22.685Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Command Reference",
      "url": "www.nushell.sh/de/book/command_reference.html",
      "id": "www.nushell.sh/de/book/command_reference.html",
      "content_html": "<h1 id=\"command-reference\" tabindex=\"-1\"> Command Reference</h1>\n<table>\n  <tr>\n    <th>Command</th>\n    <th>Beschreibung</th>\n  </tr>\n  <tr v-for=\"command in commands\">\n   <td><a :href=\"command.path\"><code>{{ command.title }}</code></a></td>\n   <td style=\"white-space: pre-wrap;\">{{ command.frontmatter.usage }}</td>\n  </tr>\n</table>\n",
      "date_modified": "2022-06-02T15:48:22.685Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Eigene Befehle",
      "url": "www.nushell.sh/de/book/eigene_befehle.html",
      "id": "www.nushell.sh/de/book/eigene_befehle.html",
      "content_html": "<h1 id=\"eigene-befehle\" tabindex=\"-1\"> Eigene Befehle</h1>\n<p>Die Fähigkeit von Nu, lange Pipelines zu verarbeiten, erlauben es große Kontrolle über Daten und das System zu haben. Das Ganze kommt allerdings zum Preis von viel Tipparbeit. Idealerweise sollte es eine Möglichkeit geben, mühsam gebaute Pipelines zu speichern und wieder und wieder auszuführen.</p>\n<p>Hier kommen eigene Befehle ins Spiel.</p>\n<p>Eine beispielhafte Definition eines eigenen Befehls sieht wie folgt aus:</p>\n<div><pre><code>def greet [name] {\n  echo &quot;hello&quot; $name\n}\n</code></pre></div><p>In dieser Definition, wird ein Befehl <code>greet</code> beschrieben, der einen Parameter <code>name</code> konsumiert. Nach diesem Parameter erfolgt die Beschreibung was passiert, wenn der Befehl ausgeführt wird. Wenn der Befehl aufgerufen wird, wird der Wert, der als Parameter <code>name</code> übergeben wurde, in die Variable <code>$name</code> geschrieben, die im Codeblock verfügbar ist.</p>\n<p>Um den obigen Befehl auszuführen wird er wie ein eingebauter Befehl aufgerufen:</p>\n<div><pre><code>> greet \"world\"\n</code></pre></div><p>Wenn das getan wird, wird eine Ausgabe erzeugt, die wie die der eingebauten Befehle aussieht:</p>\n<div><pre><code>───┬───────\n 0 │ hello\n 1 │ world\n───┴───────\n</code></pre></div><h2 id=\"namen-von-befehlen\" tabindex=\"-1\"> Namen von Befehlen</h2>\n<p>In Nushell ist ein valider Name eines Befehls ein String aus Zeichen oder ein String in Anführungszeichen. Beispiele hierfür sind: <code>greet</code>, <code>get-size</code>, <code>mycommand123</code>, <code>&quot;mycommand&quot;</code>, <code>😊</code> und <code>123</code>.</p>\n<p><em>Hinweis: Es wird empfohlen Worte in Befehlen mit <code>-</code> zur besseren Lesbarkeit zu trennen.</em> Beispiele: <code>get-size</code> anstatt <code>getsize</code> oder <code>get_size</code>.</p>\n<h2 id=\"unterbefehle\" tabindex=\"-1\"> Unterbefehle</h2>\n<p>Es ist auch möglich Unterbefehle zu definieren. Dazu wird der Unterbefehl vom Superbefehl durch ein Leerzeichen getrennt. Wenn beispielsweise der Befehl <code>str</code> durch einen Unterbefehl <code>mycommand</code> erweitert werden soll, funktioniert das wie folgt:</p>\n<div><pre><code>def &quot;str mycommand&quot; [] {\n  echo hello\n}\n</code></pre></div><p>Jetzt kann der eigene Unterbefehl aufgerufen werden, als ob er ein eingebauter Befehl von <code>str</code> wäre:</p>\n<div><pre><code>> str mycommand\n</code></pre></div><h2 id=\"typen-von-parametern\" tabindex=\"-1\"> Typen von Parametern</h2>\n<p>Wenn eigene Befehle definiert werden, kann optional auch der Typ jedes Parameters angegeben werden. Das obige Beispiel kann beispielsweise wie folgt abgeändert werden:</p>\n<div><pre><code>def greet [name: string] {\n  echo &quot;hello&quot; $name\n}\n</code></pre></div><p>Die Typen der Parameter anzugeben ist optional. Nushell erlaubt es diese wegzulassen und behandelt diese dann als Typ <code>any</code>. Es kann also jede Art von Typ verarbeitet werden. Wenn ein Typ angegeben wurde, überprüft Nushell den Typ, wenn die Funktion aufgerufen wird.</p>\n<p>Beispielhaft soll nur noch ein <code>int</code> als Typ erlaubt sein:</p>\n<div><pre><code>def greet [name: int] {\n  echo &quot;hello&quot; $name\n}\n\ngreet world\n</code></pre></div><p>Wenn versucht wird, den oberen Code auszuführen, wird Nu darauf aufmerksam machen, dass die Typen nicht passen und die Ausführung stoppen:</p>\n<div><pre><code>error: Type Error\n  ┌─ shell:6:7\n  │\n5 │ greet world\n  │       ^^^^^ Expected int, found world\n</code></pre></div><p>Dies kann dabei helfen Nutzer darauf aufmerksam zu machen, welche Art von Typ erlaubt ist.</p>\n<p>Die aktuell erlaubten Typen sind (mit Version 0.59.0 und neuer):</p>\n<ul>\n<li><code>any</code></li>\n<li><code>block</code></li>\n<li><code>cell-path</code></li>\n<li><code>duration</code></li>\n<li><code>path</code></li>\n<li><code>expr</code></li>\n<li><code>filesize</code></li>\n<li><code>glob</code></li>\n<li><code>int</code></li>\n<li><code>math</code></li>\n<li><code>number</code></li>\n<li><code>operator</code></li>\n<li><code>range</code></li>\n<li><code>cond</code></li>\n<li><code>bool</code></li>\n<li><code>signature</code></li>\n<li><code>string</code></li>\n<li><code>variable</code></li>\n</ul>\n<h2 id=\"flags\" tabindex=\"-1\"> Flags</h2>\n<p>Zusätzlich zu den obigen Parametern, können auch namenabhängige Parameter verwendet werden, indem Flags für eigene Befehle definiert werden.</p>\n<p>Zum Beispiel:</p>\n<div><pre><code>def greet [\n  name: string\n  --age: int\n] {\n  echo $name $age\n}\n</code></pre></div><p>In der obigen Definition von <code>greet</code>, werden ein fester Parameter <code>name</code> und eine Flag <code>age</code> definiert. Damit ist es möglich, dem Befehl <code>greet</code> optional den Parameter <code>age</code> zu übergeben.</p>\n<p>Das obige Beispiel kann wie folgt aufgerufen werden:</p>\n<div><pre><code>> greet world --age 10\n</code></pre></div><p>Oder:</p>\n<div><pre><code>> greet --age 10 world\n</code></pre></div><p>Oder gleich ganz ohne Flag:</p>\n<div><pre><code>> greet world\n</code></pre></div><p>Flags können auch so definiert werden, dass es eine Kurzform gibt. Das erlaubt es sowohl eine kurze als auch eine einfach lesbare lange Flag für die selbe Aufgabe zu haben.</p>\n<p>Das Beispiel wird hier, um eine Kurzform für die Flag <code>age</code> erweitert:</p>\n<div><pre><code>def greet [\n  name: string\n  --age (-a): int\n] {\n  echo $name $age\n}\n</code></pre></div><p><em>Hinweis:</em> Flags sind benannt nach der langen Form des Namens. Im obigen Beispiel erfolgt der Zugriff immer über <code>$age</code> und nicht über <code>$a</code>.</p>\n<p>Nun kann diese neue Version von <code>greet</code> wie folgt aufgerufen werden:</p>\n<div><pre><code>> greet -a 10 hello\n</code></pre></div><h2 id=\"dokumentation-fur-den-eigenen-befehl\" tabindex=\"-1\"> Dokumentation für den eigenen Befehl</h2>\n<p>Um Nutzern eines eigenen Befehls zu helfen, können diese und ihre Parameter mit zusätzlichen Beschreibungen versehen werden.</p>\n<p>Es wird weiterhin das obige Beispiel verwendet:</p>\n<div><pre><code>def greet [\n  name: string\n  --age (-a): int\n] {\n  echo $name $age\n}\n</code></pre></div><p>Wenn der Befehl definiert ist kann <code>help greet</code> aufgerufen werden, um Informationen zum Befehl zu erhalten:</p>\n<div><pre><code>Usage:\n  > greet &lt;name> {flags}\n\nParameters:\n  &lt;name>\n\nFlags:\n  -h, --help: Display this help message\n  -a, --age &lt;integer>\n</code></pre></div><p>Wie zu sehen ist, werden der Parameter und die Flag, die definiert wurden, aufgelistet. Zusätzlich gibt es noch die Flag <code>-h</code>, die jeder Befehl hat.</p>\n<p>Um diese Hilfe zu verbessern, können Beschreibungen zur Definition hinzugefügt werden:</p>\n<div><pre><code># A greeting command that can greet the caller\ndef greet [\n  name: string      # The name of the person to greet\n  --age (-a): int   # The age of the person\n] {\n  echo $name $age\n}\n</code></pre></div><p>Diese Kommentare, die zur Definition und den Parametern hinzugefügt wurden, werden sichtbar, wenn die Hilfe zum Befehl aufgerufen wird.</p>\n<p>Wenn jetzt <code>help greet</code> ausgeführt wird, wird ein hilfreicherer Text angezeigt:</p>\n<div><pre><code>A greeting command that can greet the caller\n\nUsage:\n  > greet &lt;name> {flags}\n\nParameters:\n  &lt;name> The name of the person to greet\n\nFlags:\n  -h, --help: Display this help message\n  -a, --age &lt;integer>: The age of the person\n</code></pre></div><h2 id=\"ausgabe\" tabindex=\"-1\"> Ausgabe</h2>\n<p>Eigene Befehle streamen ihre Ausgabe gleich wie eingebaute Befehle. Beispielsweise soll die folgende Pipeline umgebaut werden:</p>\n<div><pre><code>&gt; ls | get name\n</code></pre></div><p><code>ls</code> soll jetzt in einen neuen, eigenen Befehl verschoben werden:</p>\n<div><pre><code>def my-ls [] { ls }\n</code></pre></div><p>Die Ausgabe dieses Befehls, kann identisch zur Ausgabe von <code>ls</code> verwendet werden.</p>\n<div><pre><code>> my-ls | get name\n───┬───────────────────────\n 0 │ myscript.nu\n 1 │ myscript2.nu\n 2 │ welcome_to_nushell.md\n───┴───────────────────────\n</code></pre></div><p>Das erlaubt es sehr einfach eigene Befehle zu definieren und deren Ausgabe zu verwenden. Ein Hinweis: Es werden keine return Statements wie in anderen Sprachen verwendet. Stattdessen werden in Nushell Pipelines gebaut, die ihre Ausgabe zur verbundenen Pipeline streamen.</p>\n<h2 id=\"eingabe\" tabindex=\"-1\"> Eingabe</h2>\n<p>Eigene Befehle können, wie andere Befehle, auch Eingaben verarbeiten. Diese Eingabe wird durch die Pipeline an den Codeblock des eigenen Befehls übergeben.</p>\n<p>Hier soll nun beispielhaft ein eigener echo-Befehl definiert werden, der eine weitere Zeile nach jeder Zeile der Eingabe ausgibt:</p>\n<div><pre><code>def my-echo [] {\n  each {\n    echo $it &quot;--&quot;\n  }\n}\n</code></pre></div><p>Wenn dieser neue Befehl nun in einer Pipeline aufgerufen wird, sieht die Ausgabe wie folgt aus:</p>\n<div><pre><code>> echo foo bar | my-echo\n───┬─────\n 0 │ foo\n 1 │ --\n 2 │ bar\n 3 │ --\n───┴─────\n</code></pre></div><h2 id=\"persistenz\" tabindex=\"-1\"> Persistenz</h2>\n<p>Um Informationen darüber zu erhalten, wie eigene Befehle bei jedem Start von Nushell verfügbar bleiben, sei auf das <a href=\"/de/book/konfiguration.html\">Konfigurationskapitel</a> verwiesen.</p>\n",
      "date_modified": "2022-06-02T15:48:22.686Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Aufruf von Systembefehlen",
      "url": "www.nushell.sh/de/book/escaping.html",
      "id": "www.nushell.sh/de/book/escaping.html",
      "content_html": "<h1 id=\"aufruf-von-systembefehlen\" tabindex=\"-1\"> Aufruf von Systembefehlen</h1>\n<p>Nushell stellt einen identischen Satz an Befehlen für verschiedene Systeme zur Verfügung, die überall dieselbe Syntax und Funktionalität haben. Manchmal ist es jedoch nötig, den gleichnamigen, vom System selbst bereitgestellten, Befehl aufzurufen. Um beispielsweise den <code>ls</code> oder <code>date</code> Befehl des Systems auszuführen, wird das Zirkumflex (<code>^</code>) dem Befehl vorangestellt:</p>\n<p>Nushell Befehl:</p>\n<div><pre><code>> ls\n</code></pre></div><p>Aufruf des Systembefehls:</p>\n<div><pre><code>> ^ls\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.686Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Nu installieren",
      "url": "www.nushell.sh/de/book/installation.html",
      "id": "www.nushell.sh/de/book/installation.html",
      "content_html": "<h1 id=\"nu-installieren\" tabindex=\"-1\"> Nu installieren</h1>\n<p>Der aktuell beste Weg Nu zu bekommen ist, es von <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a> zu installieren, Binärdateien von unserer <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">Release-Seite</a> herunterzuladen oder es selbst zu kompilieren.</p>\n<h2 id=\"binardatei\" tabindex=\"-1\"> Binärdatei</h2>\n<p>Von der <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">Release-Seite</a> kann Nushell bereits kompiliert heruntergeladen werden. Alternativ kann Nushell, wenn <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Homebrew</a> verwendet wird, mit dem Befehl <code>brew install nushell</code> installiert werden. Unter Windows können <a href=\"https://docs.microsoft.com/en-us/windows/package-manager/winget/\" target=\"_blank\" rel=\"noopener noreferrer\">Winget</a> oder <a href=\"https://chocolatey.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Chocolatey</a> zur Installation verwendet werden: <code>winget install nushell</code> beziehungsweise <code>choco install nushell</code>.</p>\n<h3 id=\"windows\" tabindex=\"-1\"> Windows</h3>\n<p><strong>Achtung:</strong> Nu funtioniert aktuell auf Windows 10 und hat keine Unterstützung für Windows 7/8.1.</p>\n<p>Die aktuelle, veröffentlichte <code>.zip</code>-Datei von der <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">Release-Seite</a> herunterladen und den Inhalt extrahieren nach:</p>\n<div><pre><code>C:<span>\\</span>Program Files\n</code></pre></div><p>Danach den <code>nu</code> beinhaltenden Ordner der Umgebungsvariable PATH hinzufügen. Wenn das passiert ist, kann <code>nu</code> wie folgt gestartet werden:</p>\n<div><pre><code><span>></span> nu\nC:<span>\\</span>Users<span>\\</span>user<span>></span>\n</code></pre></div><p>Für Nutzer des <a href=\"https://github.com/microsoft/terminal\" target=\"_blank\" rel=\"noopener noreferrer\">Windows Terminal</a> kann <code>nu</code> als Standard-Shell gesetzt werden, indem:</p>\n<div><pre><code><span>{</span>\n  <span>\"guid\"</span><span>:</span> <span>\"{2b372ca1-1ee2-403d-a839-6d63077ad871}\"</span>,\n  <span>\"hidden\"</span><span>:</span> false,\n  <span>\"icon\"</span><span>:</span> <span>\"https://www.nushell.sh/icon.png\"</span>,\n  <span>\"name\"</span><span>:</span> <span>\"Nu Shell\"</span>,\n  <span>\"commandline\"</span><span>:</span> <span>\"nu.exe\"</span>\n<span>}</span>\n</code></pre></div><p>zu <code>&quot;profiles&quot;</code> in den Terminal Einstellungen (JSON-Datei) hinzufügt wird. Zu guter Letzt, muss nur noch <code>&quot;defaultProfile&quot;</code> angepasst werden:</p>\n<div><pre><code><span>\"defaultProfile\"</span><span>:</span> <span>\"{2b372ca1-1ee2-403d-a839-6d63077ad871}\"</span>,\n</code></pre></div><p>Jetzt sollte sich <code>nu</code> beim Start von Windows Terminal öffnen.</p>\n<h2 id=\"vorbereitungen\" tabindex=\"-1\"> Vorbereitungen</h2>\n<p>Bevor Nu installiert werden kann, muss sichergestellt werden, dass das System die nötigen Anforderungen erfüllt. Aktuell bedeutet das sicherzustellen, dass die Rust-Toolchain und lokale Abhängigkeiten installiert sind.</p>\n<h3 id=\"installieren-einer-compiler-suite\" tabindex=\"-1\"> Installieren einer Compiler-Suite</h3>\n<p>Damit Rust richtig funktioniert, muss eine kompatible Compiler-Suite auf dem System installiert sein. Die empfohlenen Compiler-Suites sind:</p>\n<ul>\n<li>Linux: GCC oder Clang</li>\n<li>macOS: Clang (Xcode installieren)</li>\n<li>Windows: MSVC (installieren von <a href=\"https://visualstudio.microsoft.com/vs/community/\" target=\"_blank\" rel=\"noopener noreferrer\">Visual Studio Community Edition</a> oder der <a href=\"https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022\" target=\"_blank\" rel=\"noopener noreferrer\">Visual Studio Build Tools</a>)\n<ul>\n<li>Sicherstellen, dass &quot;Desktop development with C++&quot; installiert wird</li>\n<li>Jede Visual Studio Edition sollte funktionieren (Community ist gratis)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"rust-installieren\" tabindex=\"-1\"> Rust installieren</h3>\n<p>Wenn Rust noch nicht auf dem System installiert ist, ist <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">rustup</a> der beste Weg es zu bekommen. Rustup ist ein Programm um Rust-Installationen zu managen wie beispielsweise verschiedene Rust-Versionen.</p>\n<p>Nu benötigt aktuell die <strong>latest stable (1.55 oder neuer)</strong> Version von Rust. Der einfachste Weg ist es, <code>rustup</code> die korrekte Version für finden zu lassen. Wenn <code>rustup</code> zum ersten Mal gestartet wird, wird nachgefragt, welche Version installiert werden soll:</p>\n<div><pre><code>Current installation options:\n\ndefault <span>host</span> triple: x86_64-unknown-linux-gnu\ndefault toolchain: stable\nprofile: default\nmodify <span>PATH</span> variable: <span>yes</span>\n\n<span>1</span><span>)</span> Proceed with installation <span>(</span>default<span>)</span>\n<span>2</span><span>)</span> Customize installation\n<span>3</span><span>)</span> Cancel installation\n</code></pre></div><p>Wenn Sie bereit sind, drücken Sie <code>1</code> und dann <code>Enter</code>.</p>\n<p>Wenn Rust nicht via <code>rustup</code> installiert werden soll, können auch andere Methoden verwendet werden um es zu installieren (z.B. vom Paketmanager der Linux-Distro). Dabei muss sichergestellt werden, dass es sich um Rust-Version 1.55 oder neuer handelt.</p>\n<h2 id=\"abhangigkeiten\" tabindex=\"-1\"> Abhängigkeiten</h2>\n<h3 id=\"debian-ubuntu\" tabindex=\"-1\"> Debian/Ubuntu</h3>\n<p>Es müssen die Pakete <code>pkg-config</code> und <code>libssl-dev</code> installiert werden:</p>\n<div><pre><code><span>apt</span> <span>install</span> pkg-config libssl-dev\n</code></pre></div><p>Linux-Nutzer die die optionalen Funktionen <code>rawkey</code> und <code>clipboard</code> verwenden möchten, müssen außerdem die Pakete <code>libx11-dev</code> und <code>libxcb-composite0-dev</code> installieren:</p>\n<div><pre><code><span>apt</span> <span>install</span> libxcb-composite0-dev libx11-dev\n</code></pre></div><h3 id=\"rhel-basierte-distributionen\" tabindex=\"-1\"> RHEL basierte Distributionen</h3>\n<p>Für RHEL basierte Distributionen müssen die Pakete <code>libxcb</code>, <code>openssl-devel</code> und <code>libX11-devel</code> installiert werden:</p>\n<div><pre><code>yum <span>install</span> libxcb openssl-devel libX11-devel\n</code></pre></div><h3 id=\"macos\" tabindex=\"-1\"> macOS</h3>\n<p>Mittels <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Homebrew</a>, müssen die Pakete <code>openssl</code> und <code>cmake</code> über folgenden Befehl installiert werden:</p>\n<div><pre><code>brew <span>install</span> openssl cmake\n</code></pre></div><h2 id=\"installieren-von-crates-io\" tabindex=\"-1\"> Installieren von <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a></h2>\n<p>Wenn alle die Abhängigkeitenn, die für Nu benötigt werden, installiert sind, kann <code>cargo</code> verwendet werden um Nu zu installieren.</p>\n<div><pre><code><span>></span> cargo <span>install</span> nu\n</code></pre></div><p>Das war's! Cargo wird Nu und seine anderen Abhängigkeiten herunterladen, kompilieren und schließlich im cargo <code>bin</code> Pfad installieren, damit es benutzt werden kann.</p>\n<p>Wenn mehr Funktionalitäten installiert werden sollen, kann der folgende Befehl verwendet werden:</p>\n<div><pre><code><span>></span> cargo <span>install</span> nu --features<span>=</span>extra\n</code></pre></div><p>Um alle verfügbaren Funktionalitäten zu bekommen, ist es am einfachsten einen Checkout durchzuführen und es selbst mit Hilfe der Rust-Tools zu kompilieren:</p>\n<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git\n<span>></span> <span>cd</span> nushell\nnushell<span>></span> cargo <span>install</span> --path <span>.</span> --features<span>=</span>extra\n</code></pre></div><p>Damit das funktioniert, sollte sichergestellt werden, dass alle oben genannten Abhängigkeiten auf dem System installiert sind.</p>\n<p>Wenn Nu schließlich installiert ist, kann die Shell mit dem <code>nu</code>-Befehl gestartet werden:</p>\n<div><pre><code>$ nu\n/home/jt/Source<span>></span>\n</code></pre></div><h2 id=\"kompilieren-von-quelldateien\" tabindex=\"-1\"> Kompilieren von Quelldateien</h2>\n<p>Nu kann auch direkt aus den Quelldateien, die auf GitHub verfügbar sind, kompiliert werden. Das stellt unmittelbar die neuesten Funktionen und Fehlerbehebungen von Nu zur Verfügung.</p>\n<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git\n</code></pre></div><p>Git clont das main nushell Repo. Von da aus, kann Nu, wenn <code>rustup</code> verwendet wird, wie folgt kompiliert und gestartet werden:</p>\n<div><pre><code><span>></span> <span>cd</span> nushell\nnushell<span>></span> cargo build --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --features<span>=</span>extra\n</code></pre></div><p>Nu kann auch in &quot;release&quot; Modus kompiliert und gestartet werden:</p>\n<div><pre><code>nushell<span>></span> cargo build --release --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --release --features<span>=</span>extra\n</code></pre></div><p>Leute, die sich mit Rust auskennen, wundern sich womöglich, warum hier sowohl ein <code>build</code> als auch ein <code>run</code> durchgeführt wird, obwohl <code>run</code> standardmäßig auch einen Build durchführt. Das ist nötig, um ein Problem mit der neuen <code>default-run</code>-Option von Cargo zu umgehen, damit alle Plugins kompiliert werden. Dies wird unter Umständen in Zukunft nicht mehr nötig sein.</p>\n<h2 id=\"als-login-shell-verwenden\" tabindex=\"-1\"> Als Login-Shell verwenden</h2>\n<p><strong>!!! Nu befindet sich noch in der Entwicklung und ist unter Umständen nicht stabil genug für die tägliche Nutzung. !!!</strong></p>\n<p>Um die Login-Shell festzulegen, kann der Befehl <a href=\"https://linux.die.net/man/1/chsh\" target=\"_blank\" rel=\"noopener noreferrer\"><code>chsh</code></a> verwendet werden.\nManche Linux-Distributionen haben eine Liste von erlaubten Shells in <code>/etc/shells</code> und verbieten es die Shell zu ändern, bis Nu in der Whitelist ist. Wenn die <code>shells</code>-Datei nicht abgeändert wurde, erscheint vielleicht einen ähnlichen Fehler, wie:</p>\n<div><pre><code>chsh: /home/username/.cargo/bin/nu is an invalid shell\n</code></pre></div><p>Nu kann zur Liste der erlaubte Shells hinzugefügt werden, indem der Pfad von <code>nu</code> der <code>shells</code>-Datei angefügt wird.\nDer Pfad, der hinzugefügt werden muss, kann mit dem Befehl <code>which nu</code> herausgefunden werden. Normalerweise ist es <code>$HOME/.cargo/bin/nu</code>.</p>\n",
      "date_modified": "2022-06-02T15:48:22.686Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Konfiguration",
      "url": "www.nushell.sh/de/book/konfiguration.html",
      "id": "www.nushell.sh/de/book/konfiguration.html",
      "content_html": "<h1 id=\"konfiguration\" tabindex=\"-1\"> Konfiguration</h1>\n<h2 id=\"nushell-konfiguration-mittels-config-nu\" tabindex=\"-1\"> Nushell Konfiguration mittels <code>config.nu</code></h2>\n<p>Nushell nutzt ein Konfigurationssystem, das ein Nushell-Skript beim Start ausführt. Die Konfigurationsdatei wird für Nushell <code>config.nu</code> genannt. Der Pfad zu dieser Konfigurationsdatei kann durch den Aufruf von <code>echo $nu.config-path</code> herausgefunden werden. Es handelt sich dabei um eine Datei, die abgearbeitet wird und in jedem Schritt Definitionen, Umgebungsvariablen und mehr zum globalen Namespace hinzufügt.</p>\n<p>Ein Beispiel für eine Nushell <code>config.nu</code> kann <a href=\"https://github.com/nushell/nushell/blob/main/src/default_config.nu\" target=\"_blank\" rel=\"noopener noreferrer\">hier</a> in unserem Repository gefunden werden.</p>\n<h3 id=\"config-konfigurieren\" tabindex=\"-1\"> <code>$config</code> konfigurieren</h3>\n<p>Die zentralen Konfigurationen von Nushell sind in der globalen <code>$config</code> Variable festgehalten. Dieser Eintrag kann wie folgt erstellt werden:</p>\n<div><pre><code>let $config = {\n  ...\n}\n</code></pre></div><p>Es ist auch möglich <code>$config</code> zu überschreiben und zu ändern:</p>\n<div><pre><code>let $config = ($config | update &lt;field name> &lt;field value>)\n</code></pre></div><h3 id=\"umgebung\" tabindex=\"-1\"> Umgebung</h3>\n<p>Die Shell-Umgebung kann durch Aufrufe von <code>let-env</code> in der <code>config.nu</code>-Datei geändert werden. Es gibt einige wichtige Nushell-spezifischen Einstellungen:</p>\n<ul>\n<li><code>LS_COLORS</code>: Setzt die Farben für Dateitypen in ls</li>\n<li><code>PROMPT_COMMAND</code>: Befehle, die ausgeführt werden, um die Prompt zu erzeugen (Block oder String)</li>\n<li><code>PROMPT_COMMAND_RIGHT</code>: Befehle, die ausgeführt werden, um die Prompt zu erzeugen (Block)</li>\n<li><code>PROMPT_INDICATOR = &quot;〉&quot;</code>: Indikator, der der Prompt folgt (default: &quot;&gt;&quot;-like Unicode symbol)</li>\n<li><code>PROMPT_INDICATOR_VI_INSERT = &quot;: &quot;</code></li>\n<li><code>PROMPT_INDICATOR_VI_NORMAL = &quot;〉 &quot;</code></li>\n<li><code>PROMPT_MULTILINE_INDICATOR = &quot;::: &quot;</code></li>\n</ul>\n<h3 id=\"farbkonfiguration\" tabindex=\"-1\"> Farbkonfiguration</h3>\n<p>Mehr Informationen zu Farbeinstellungen und Themes kann im <a href=\"/book/coloring_and_theming.html\">entsprechenden Kapitel</a> gefunden werden.</p>\n<h2 id=\"nushell-als-login-shell\" tabindex=\"-1\"> Nushell als Login-Shell</h2>\n<p>Um Nushell als Login-Shell zu verwenden, muss die <code>$env</code> Variable konfiguriert werden, damit es möglich ist, externe Befehle als Login-Shell auszuführen.</p>\n<p>Der komplette Satz an Umgebungsvariablen kann erzeugt werden, wenn Nu in einer anderen Shell, wie beispielsweise Bash, ausgeführt wird. In diese Nu-Sitzung kann ein Befehl wie der folgende verwendet werden, um <code>$env</code> zu setzen:</p>\n<div><pre><code>> env | each { echo $\"let-env ($it.name) = '($it.raw)'\" } | str collect (char nl)\n</code></pre></div><p>Das wird <code>let-env</code> Zeilen ausgeben - eine für jede Umgebungsvariable - inklusive der nötigen Werte.</p>\n<p>Als nächstes, muss auf manchen Distributionen sichergestellt werden, dass Nu in der Liste der Shells in /etc/shells ist:</p>\n<div><pre><code>> cat /etc/shells\n# /etc/shells: valid login shells\n/bin/sh\n/bin/dash\n/bin/bash\n/bin/rbash\n/usr/bin/screen\n/usr/bin/fish\n/home/jonathan/.cargo/bin/nu\n</code></pre></div><p>Damit sollte es möglich sein, Nu als Login-Shell mit <code>chsh</code> festzulegen. Nach dem Ausloggen und erneutem Einloggen sollte Nu als Shell grüßen.</p>\n<h3 id=\"macos-usr-bin-open-als-open-behalten\" tabindex=\"-1\"> macOS: <code>/usr/bin/open</code> als <code>open</code> behalten</h3>\n<p>Manche Tools (z.B. Emacs) vertrauen darauf, dass <code>open</code> Dateien auf dem Mac öffnet.\nDa Nushell einen eigenen <code>open</code> Befehl hat, der eine andere Semantik hat und <code>/usr/bin/open</code> verbirgt, werden diese Tools einen Fehler werfen, wenn sie verwendet werden.\nEine Möglichkeit, dieses Problem zu umgehen, ist es, einen eigenen Befehl und einen <code>alias</code> in <code>config.nu</code> zu definieren:</p>\n<div><pre><code>def nuopen [arg, --raw (-r)] { if $raw { open -r $arg } else { open $arg } }\nalias open = ^open\n</code></pre></div><h2 id=\"konfiguration-der-prompt\" tabindex=\"-1\"> Konfiguration der Prompt</h2>\n<p>Die Konfiguration der Prompt wird durch das Setzen der Umgebungsvariable <code>PROMPT_COMMAND</code> bzw. <code>PROMPT_COMMAND_RIGHT</code> durchgeführt.\nDiese akzeptieren entweder einen String oder einen Codeblock der ausgeführt wird.</p>\n<div><pre><code>let-env PROMPT_COMMAND = \"Hallo Nu\"  # Die Hauptprompt auf einen festen String setzen\nlet-env PROMPT_COMMAND_RIGHT = {pwd} # Den rechte Promptteil mit dem aktuellen Verzeichnis anzeigen\n</code></pre></div><p>Darüber hinaus wird als Markierung ein Promptindikator gesetzt, welcher den aktuellen Modus oder einen Zeilenumbruch anzeigt:</p>\n<ul>\n<li><code>PROMPT_INDICATOR = &quot;〉&quot;</code>: Indikator, der der Prompt folgt (default: &quot;&gt;&quot;-like Unicode symbol)</li>\n<li><code>PROMPT_INDICATOR_VI_INSERT = &quot;: &quot;</code></li>\n<li><code>PROMPT_INDICATOR_VI_NORMAL = &quot;〉 &quot;</code></li>\n<li><code>PROMPT_MULTILINE_INDICATOR = &quot;::: &quot;</code></li>\n</ul>\n<p>Mehr Dokumentation zu fertigen Prompts von Drittanbietern kann <a href=\"/de/book/3rdpartyprompts.html\">hier</a> gefunden werden.</p>\n",
      "date_modified": "2022-06-02T15:48:22.687Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mathematik",
      "url": "www.nushell.sh/de/book/mathematik.html",
      "id": "www.nushell.sh/de/book/mathematik.html",
      "content_html": "<h1 id=\"mathematik\" tabindex=\"-1\"> Mathematik</h1>\n<p>Manchmal müssen lediglich ein paar Zahlen addiert werden, um eine Aufgabe zu erledigen. Nushell bietet dazu einen Satz an grundlegenden mathematischen Funktionen an. Mathematische Ausdrücke sind überall dort verfügbar, wo ein Befehl aufgerufen werden kann.</p>\n<h2 id=\"addieren-subtrahieren-multiplizieren-dividieren\" tabindex=\"-1\"> Addieren, Subtrahieren, Multiplizieren, Dividieren</h2>\n<div><pre><code>> 1 + 3\n4\n</code></pre></div><p>In Nushell, können die Operationen Addition, Subtraktion, Multiplikation und Division mit den dafür üblichen Symbolen <code>+</code>, <code>-</code>, <code>*</code> und <code>/</code> aufgerufen werden. Die Reihenfolge der Operatoren wird dabei berücksichtigt. Ein Beispiel: <code>1 + 2 * 3</code> wird behandelt als <code>1 + (2 * 3)</code>. Was zum nächsten Konzept führt: Klammern.</p>\n<h2 id=\"klammern\" tabindex=\"-1\"> Klammern</h2>\n<p>Klammern können verwendet werden, um mathematische Ausdrücke zu gruppieren. Das erlaubt es <code>(1 + 2) * 3</code> zu verwenden, um beispielsweise die Addition vor der Multiplikation auszuführen.</p>\n<h2 id=\"in-und-not-in\" tabindex=\"-1\"> <code>in</code> und <code>not-in</code></h2>\n<p>Um herauszufinden, ob ein Wert in einem Datensatz ist oder nicht, können die Operatoren <code>in</code> und <code>not-in</code> verwendet werden.</p>\n<div><pre><code>> 1 in [1 2 3]\ntrue\n</code></pre></div><div><pre><code>> 1 not-in [1 2 3]\nfalse\n</code></pre></div><h2 id=\"und\" tabindex=\"-1\"> =~ und !~</h2>\n<p>Um zu überprüfen, ob ein String innerhalb eines anderen Strings zu finden ist oder nicht, können die Operatoren <code>=~</code> und <code>!~</code> verwendet werden.</p>\n<div><pre><code>> \"foobar\" =~ \"foo\"\ntrue\n</code></pre></div><div><pre><code>> \"foobar\" !~ \"baz\"\ntrue\n</code></pre></div><h2 id=\"vergleiche\" tabindex=\"-1\"> Vergleiche</h2>\n<p>Die folgenden Vergleichsoperatoren sind ebenfalls verfügbar:</p>\n<ul>\n<li><code>&lt;</code> - kleiner als</li>\n<li><code>&lt;=</code> - kleiner gleich</li>\n<li><code>&gt;</code> - größer als</li>\n<li><code>&gt;=</code> - größer gleich</li>\n<li><code>==</code> - gleich</li>\n<li><code>!=</code> - ungleich</li>\n</ul>\n<h2 id=\"verknupfungsoperatoren\" tabindex=\"-1\"> Verknüpfungsoperatoren</h2>\n<p>Nushell unterstützt auch die Operatoren <code>&amp;&amp;</code> (&quot;und&quot;) und <code>||</code> (&quot;oder&quot;) um zwei Operationen die Bool-Werte zurückgeben zu verbinden. Zum Beispiel: <code>ls | where name in [&quot;one&quot; &quot;two&quot; &quot;three&quot;] &amp;&amp; size &gt; 10kb</code></p>\n<h2 id=\"reihenfolge-von-operationen\" tabindex=\"-1\"> Reihenfolge von Operationen</h2>\n<p>Mathematische Operationen werden in der folgenden Reihenfolge ausgewertet (von der höchsten Priorität zur niedrigsten Priorität):</p>\n<ul>\n<li>Klammern (<code>()</code>)</li>\n<li>Multiplikation (<code>*</code>), Division (<code>/</code>) und Potenz (<code>**</code>)</li>\n<li>Addition (<code>+</code>) und Subtraktion (<code>-</code>)</li>\n</ul>\n<div><pre><code>> 3 * (1 + 2)\n9\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.687Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Plugins",
      "url": "www.nushell.sh/de/book/plugins.html",
      "id": "www.nushell.sh/de/book/plugins.html",
      "content_html": "<h1 id=\"plugins\" tabindex=\"-1\"> Plugins</h1>\n<p>Die Funktionen von Nushell können mittels Plugins erweitert werden. Diese Plugins können einen Großteil der selben Operationen ausführen, wie die internen Befehle. Noch dazu haben Plugins den Vorteil, dass sie separat und flexibel zu Nushell hinzugefügt werden können.</p>\n<p>Um ein Plugin hinzuzufügen, muss es erstellt werden und dann der Befehl <code>register</code> auf dieses Plugin aufgerufen werden. Wenn das getan wird, muss Nushell auch mitgeteilt werden, welches Protokoll vom Plugin verwendet wird.</p>\n<p>Ein Beispiel:</p>\n<div><pre><code>> register ./my_plugins/nu-plugin-inc -e capnp\n</code></pre></div><p>Wenn der Befehl registriert wurde, kann er als Teil der internen Befehle verwendet werden.</p>\n<div><pre><code>> inc --help\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.687Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Variablen und Unterausdrücke",
      "url": "www.nushell.sh/de/book/variablen_und_unterausdruecke.html",
      "id": "www.nushell.sh/de/book/variablen_und_unterausdruecke.html",
      "content_html": "<h1 id=\"variablen-und-unterausdrucke\" tabindex=\"-1\"> Variablen und Unterausdrücke</h1>\n<p>Es gibt zwei Arten von auszuwertenden Ausdrücken in Nushell: Variablen und Unterausdrücke. Diese werden durch das Dollar Symbol (<code>$</code>) eingeleitet. Das gibt den Hinweis, dass Nushell an dieser Stelle einen Ausdruck auswerten muss, um einen Wert zu erhalten, der für die Ausführung eines gesamten Befehls benötigt wird. Beide Formen des Ausdrucks haben eine einfache Variante und eine 'Pfad'-Variante, wenn mit komplexeren Daten gearbeitet wird.</p>\n<h2 id=\"variablen\" tabindex=\"-1\"> Variablen</h2>\n<p>Die einfachere Variante der auszuwertenden Ausdrücke ist die Variable. Während der Auswertung, wird die Variable durch ihren Wert ersetzt.</p>\n<p>Wenn eine Variable erzeugt wurde, kann der Inhalt dieser Variable ausgegeben werden, indem <code>$</code> vor dem Variablennamen verwendet wird:</p>\n<div><pre><code>> let my-value = 4\n> echo $my-value\n4\n</code></pre></div><h2 id=\"pfade-von-variablen\" tabindex=\"-1\"> Pfade von Variablen</h2>\n<p>Ein Pfad einer Variable funktioniert ähnlich wie ein strukturierter Datentyp. Es kann mittels Referenzen auf den Inhalt der Variable beziehungsweise die Spalten in der Variable zugegriffen werden, um final bei einem bestimmten Wert zu landen. Wenn beispielsweise anstatt der <code>4</code> im obigen Beispiel, der Variablen eine Tabelle zugewiesen wurde:</p>\n<div><pre><code>> let my-value = [[name]; [testuser]]\n</code></pre></div><p>Hier kann ein Pfad der Variable <code>$my-value</code> verwendet werden, um den Wert der Spalte <code>name</code> in nur einem Schritt zu bekommen:</p>\n<div><pre><code>> echo $my-value.name\ntestuser\n</code></pre></div><h2 id=\"unterausdrucke\" tabindex=\"-1\"> Unterausdrücke</h2>\n<p>Unterausdrücke können jederzeit ausgewertet und die Ergebnisse verwendet werden, indem der Ausdruck in Klammern <code>()</code> gepackt wird. Hinweis: In älteren Versionen von Nushell (älter als 0.32) wurde <code>$()</code> benutzt.</p>\n<p>Die Klammern enthalten eine Pipeline, die bis zum Ende durchlaufen wird und deren Ergebnis dann verwendet wird. Hier einige Beispiele: <code>(ls)</code> würde den <code>ls</code> Befehl ausführen und die entsprechende Tabelle zurückgeben und <code>(git branch --show-current)</code> führt den externen Befehl <code>git</code> aus und gibt einen String mit dem Namen des aktuellen Branch zurück. Diese Klammern können auch verwendet werden, um mathematische Ausdrücke, wie <code>(2 + 3)</code>, auszuwerten.</p>\n<p>Unterausdrücke können auch ganze Pipelines statt nur einzelner Befehle enthalten. Um eine Liste von Dateien mit einer Größe größer als 10 Kilobytes zu bekommen, kann die folgende Pipeline verwendet und einer Variable zugewiesen werden:</p>\n<div><pre><code>> let names-of-big-files = (ls | where size > 10kb)\n> echo $names-of-big-files\n───┬────────────┬──────┬──────────┬──────────────\n # │    name    │ type │   size   │   modified\n───┼────────────┼──────┼──────────┼──────────────\n 0 │ Cargo.lock │ File │ 155.3 KB │ 17 hours ago\n 1 │ README.md  │ File │  15.9 KB │ 17 hours ago\n───┴────────────┴──────┴──────────┴──────────────\n</code></pre></div><h2 id=\"unterausdrucke-und-pfade\" tabindex=\"-1\"> Unterausdrücke und Pfade</h2>\n<p>Unterausdrücke unterstützen auch Pfade. Um beispielsweise eine Liste der Dateinamen im aktuellen Ordner zu bekommen, kann diese Pipeline verwendet werden:</p>\n<div><pre><code>> ls | get name\n</code></pre></div><p>Dasselbe Ergebnis kann auch in nur einem Schritt erreicht werden, indem ein Unterausdruck mit Pfad verwendet wird:</p>\n<div><pre><code>> echo (ls).name\n</code></pre></div><p>Welcher Stil gewählt wird, hängt vom Anwendungsfall und den persönlichen Vorlieben ab.</p>\n<h2 id=\"short-hand-unterausdrucke\" tabindex=\"-1\"> Short-hand Unterausdrücke</h2>\n<p>Nushell erlaubt den Zugriff auf Spalten in Tabellen in Unterausdrücken durch einfache Short-Hands. Wenn beispielsweise nur Zeilen in <code>ls</code> angezeigt werden sollen, in der die Größe der Datei größer als 10 Kilobytes ist, kann der folgende Befehl verwendet werden:</p>\n<div><pre><code>> ls | where size > 10kb\n</code></pre></div><p><code>where size &gt; 10kb</code> ist ein Befehl mit zwei Teilen: Dem Befehlsnamen <code>where</code> und dem short-hand Ausdruck <code>size &gt; 10kb</code>. Hier wird auch klar, warum das Ganze short-hand heißt: <code>size</code> ist hier die gekürzte Version von <code>$it.size</code>. Das Ganze könnte auch mit einer der folgenden ausführlicheren Varianten erreicht werden:</p>\n<div><pre><code>> ls | where $it.size > 10kb\n> ls | where ($it.size > 10kb)\n> ls | where {|$it| $it.size > 10kb }\n</code></pre></div><p>Damit diese short-hand Syntax funktioniert, muss der Name der Spalte auf der linken Seite der Operation sein (wie bei <code>size</code> in <code>size &gt; 10kb</code>).</p>\n",
      "date_modified": "2022-06-02T15:48:22.687Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Vergleich zu Bash",
      "url": "www.nushell.sh/de/book/von_bash_kommend.html",
      "id": "www.nushell.sh/de/book/von_bash_kommend.html",
      "content_html": "<h1 id=\"vergleich-zu-bash\" tabindex=\"-1\"> Vergleich zu Bash</h1>\n<p>Hinweis: Diese Tabelle geht von Nu 0.59 oder neuer aus.</p>\n<table>\n<thead>\n<tr>\n<th>Bash</th>\n<th>Nu</th>\n<th>Funktion</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ls</code></td>\n<td><code>ls</code></td>\n<td>Auflisten der Dateien des aktuellen Pfads</td>\n</tr>\n<tr>\n<td><code>ls &lt;dir&gt;</code></td>\n<td><code>ls &lt;dir&gt;</code></td>\n<td>Auflisten der Dateien am angegebenen Pfad</td>\n</tr>\n<tr>\n<td><code>ls pattern*</code></td>\n<td><code>ls pattern*</code></td>\n<td>Auflisten von Dateien, die dem gegebenen Schema/Pattern folgen</td>\n</tr>\n<tr>\n<td><code>ls -la</code></td>\n<td><code>ls --long --all</code> or <code>ls -la</code></td>\n<td>Auflisten aller Dateien (inklusive versteckte) mit allen verfügbaren Informationen</td>\n</tr>\n<tr>\n<td><code>ls -d */</code></td>\n<td><code>ls | where type == Dir</code></td>\n<td>Auflisten von Ordnern</td>\n</tr>\n<tr>\n<td><code>find . -name *.rs</code></td>\n<td><code>ls **/*.rs</code></td>\n<td>Rekursives auflisten aller Dateien, die zum gegebenen Schema/Pattern passen</td>\n</tr>\n<tr>\n<td><code>cd &lt;directory&gt;</code></td>\n<td><code>cd &lt;directory&gt;</code></td>\n<td>Wechseln an den angegebenen Pfad</td>\n</tr>\n<tr>\n<td><code>cd</code></td>\n<td><code>cd</code></td>\n<td>Wechseln in den HOME-Ordner</td>\n</tr>\n<tr>\n<td><code>cd -</code></td>\n<td><code>cd -</code></td>\n<td>Wechseln an den vorherigen Pfad</td>\n</tr>\n<tr>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td>Erzeugen des angegebenen Pfads</td>\n</tr>\n<tr>\n<td><code>mkdir -p &lt;path&gt;</code></td>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td>Erzeugen des angegebenen Pfads und weiterer Ordner wenn nötig</td>\n</tr>\n<tr>\n<td><code>touch test.txt</code></td>\n<td><code>touch test.txt</code></td>\n<td>Erstellen einer Datei</td>\n</tr>\n<tr>\n<td><code>&gt; &lt;path&gt;</code></td>\n<td><code>| save &lt;path&gt;</code></td>\n<td>Speichern eines String in eine Datei</td>\n</tr>\n<tr>\n<td><code>&gt;&gt; &lt;path&gt;</code></td>\n<td><code>| save --append &lt;path&gt;</code></td>\n<td>Anhängen eines Strings an eine Datei</td>\n</tr>\n<tr>\n<td><code>cat &lt;path&gt;</code></td>\n<td><code>open --raw &lt;path&gt;</code></td>\n<td>Einlesen des Inhalts der angegebenen Datei (in Textform)</td>\n</tr>\n<tr>\n<td></td>\n<td><code>open &lt;path&gt;</code></td>\n<td>Einlesen einer Datei in Form von strukturierten Daten</td>\n</tr>\n<tr>\n<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Bewegen einer Datei an einen neuen Ort</td>\n</tr>\n<tr>\n<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Kopieren einer Datei an einen Ort</td>\n</tr>\n<tr>\n<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Kopieren eines Ordners an einen Ort (rekursiv)</td>\n</tr>\n<tr>\n<td><code>rm &lt;path&gt;</code></td>\n<td><code>rm &lt;path&gt;</code></td>\n<td>Entfernen der angegebenen Datei</td>\n</tr>\n<tr>\n<td></td>\n<td><code>rm -t &lt;path&gt;</code></td>\n<td>Angegebene Datei in den Papierkorb des Systems werfen</td>\n</tr>\n<tr>\n<td><code>rm -rf &lt;path&gt;</code></td>\n<td><code>rm -r &lt;path&gt;</code></td>\n<td>Entfernen des angegebenen Pfads rekursiv</td>\n</tr>\n<tr>\n<td><code>chmod</code></td>\n<td><code>&lt;Noch nicht möglich&gt;</code></td>\n<td>Ändern von Dateiattributen</td>\n</tr>\n<tr>\n<td><code>date -d &lt;date&gt;</code></td>\n<td><code>&quot;&lt;date&gt;&quot; | into datetime -f &lt;format&gt;</code></td>\n<td>Datum ausgeben (<a href=\"https://docs.rs/chrono/0.4.15/chrono/format/strftime/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">Dokumentation des Formats</a>)</td>\n</tr>\n<tr>\n<td><code>sed</code></td>\n<td><code>str find-replace</code></td>\n<td>Suchen und ersetzen eines Pattern in einem String</td>\n</tr>\n<tr>\n<td><code>grep &lt;pattern&gt;</code></td>\n<td><code>where $it =~ &lt;substring&gt;</code> or <code>find &lt;substring&gt;</code></td>\n<td>Filtern von Strings die den Substring beinhalten</td>\n</tr>\n<tr>\n<td><code>man &lt;command&gt;</code></td>\n<td><code>help &lt;command&gt;</code></td>\n<td>Hilfe zu einem Befehl ansehen</td>\n</tr>\n<tr>\n<td></td>\n<td><code>help commands</code></td>\n<td>Alle verfügbaren Befehle anzeigen</td>\n</tr>\n<tr>\n<td></td>\n<td><code>help --find &lt;string&gt;</code></td>\n<td>Nach einem Text in allen verfügbaren Befehlen suchen</td>\n</tr>\n<tr>\n<td><code>command1 &amp;&amp; command2</code></td>\n<td><code>command1; command2</code></td>\n<td>Ausführen eines Befehls und wenn Ausführung erfolgreich wird ein weiterer Befehl ausgeführt</td>\n</tr>\n<tr>\n<td><code>stat $(which git)</code></td>\n<td><code>stat (which git).path</code></td>\n<td>Ausgabe eines Befehls als Eingabe für einen anderen Befehl verwenden</td>\n</tr>\n<tr>\n<td><code>echo $PATH</code></td>\n<td><code>echo $env.PATH</code></td>\n<td>Aktuelle PATH-Variable anzeigen</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>vim $nu.config-path</code></td>\n<td>PATH permanent ändern</td>\n</tr>\n<tr>\n<td><code>export PATH = $PATH:/usr/other/bin</code></td>\n<td><code>let-env PATH = ($env.PATH | append /usr/other/bin)</code></td>\n<td>PATH temporär ändern</td>\n</tr>\n<tr>\n<td><code>export</code></td>\n<td><code>echo $env</code></td>\n<td>Anzeigen der aktuellen Umgebungsvariablen</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>vim $nu.config-path</code></td>\n<td>Umgebungsvariablen permanent ändern</td>\n</tr>\n<tr>\n<td><code>FOO=BAR ./bin</code></td>\n<td><code>FOO=BAR ./bin</code></td>\n<td>Umgebungsvariablen temporär ändern</td>\n</tr>\n<tr>\n<td><code>export FOO=BAR</code></td>\n<td><code>let-env FOO = BAR</code></td>\n<td>Umgebungsvariable für aktuelle Sitzung setzen</td>\n</tr>\n<tr>\n<td><code>echo $FOO</code></td>\n<td><code>echo $env.FOO</code></td>\n<td>Umgebungsvariablen nutzen</td>\n</tr>\n<tr>\n<td><code>unset FOO</code></td>\n<td><code>hide FOO</code></td>\n<td>Umgebungsvariable für aktuelle Sitzung verbergen</td>\n</tr>\n<tr>\n<td><code>alias s=&quot;git status -sb&quot;</code></td>\n<td><code>alias s = git status -sb</code></td>\n<td>Alias temporär definieren</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>vim $nu.config-path</code></td>\n<td>Alias permanent hinzufügen und ändern (für neue Shells)</td>\n</tr>\n<tr>\n<td><code>bash -c &lt;commands&gt;</code></td>\n<td><code>nu -c &lt;commands&gt;</code></td>\n<td>Ausführen einer Pipeline an Befehlen (benötigt 0.9.1 oder neuer)</td>\n</tr>\n<tr>\n<td><code>bash &lt;script file&gt;</code></td>\n<td><code>nu &lt;script file&gt;</code></td>\n<td>Ausführen einer Skriptdatei (benötigt 0.9.1 oder neuer)</td>\n</tr>\n<tr>\n<td><code>\\</code></td>\n<td><code>(</code> gefolgt von <code>)</code></td>\n<td>Fortsetzen von Zeilen</td>\n</tr>\n</tbody>\n</table>\n",
      "date_modified": "2022-06-02T15:48:22.687Z",
      "authors": [],
      "tags": []
    }
  ]
}