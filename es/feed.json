{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Nushell",
  "home_page_url": "www.nushell.sh/es/",
  "feed_url": "www.nushell.sh/feed.json",
  "description": "Un nuevo tipo de shell.",
  "items": [
    {
      "title": "Introducción",
      "url": "www.nushell.sh/es/book/",
      "id": "www.nushell.sh/es/book/",
      "content_html": "<h1 id=\"introduccion\" tabindex=\"-1\"> Introducción</h1>\n<p>Hola, y bienvenido al proyecto Nushell. El objetivo de este proyecto es tomar la filosofía Unix de shells, dónde tuberías <em>-pipes-</em> conectan comandos simples juntos y llevarlos al estilo moderno de desarrollo.</p>\n<p>Nu toma ideas de muchos territorios familiares: shells tradicionales como bash, shells basadas en objetos como PowerShell, programación funcional, programación de sistemas, y más. Pero, en lugar de ser un &quot;Todo en uno&quot;, Nu enfoca su energía en hacer algunas cosas bien:</p>\n<ul>\n<li>Crear una multiplataforma shell flexible con un toque moderno.</li>\n<li>Permitir mezclar y combinar aplicaciones de línea de comandos con una shell que entiende la estructura de sus datos.</li>\n<li>Tenga el brillo UX que proporcionan las aplicaciones modernas CLI.</li>\n</ul>\n<p>La manera más facil de ver qué puede hacer Nu es con ejemplos, iniciemos.</p>\n<p>Lo primero que notarás al ejercutar un comando como <code>ls</code> es que en lugar de un bloque de texto que regresa, recibirás una tabla estructurada.</p>\n<div><pre><code><span>></span> <span>ls</span>\n╭────┬───────────────────────┬──────┬───────────┬─────────────╮\n│ <span>#  │         name          │ type │   size    │  modified   │</span>\n├────┼───────────────────────┼──────┼───────────┼─────────────┤\n│  <span>0</span> │ <span>404</span>.html              │ <span>file</span> │     <span>429</span> B │ <span>3</span> days ago  │\n│  <span>1</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>8</span> mins ago  │\n│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>3</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │\n│  <span>4</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>5</span> │ README.md             │ <span>file</span> │     <span>213</span> B │ <span>3</span> days ago  │\n<span>..</span>.\n</code></pre></div><p>La tabla no solamente muestra lo que hay en el directorio de una manera distinta sino algo más. Como las tablas de una hoja de cálculo <em>-<em>spreadsheet</em>-</em>, esta tabla te permite trabajar con los datos más interactivamente.</p>\n<p>Lo primero que vamos hacer es ordenar nuestra tabla por tamaño. Para poder hacerlo tomaremos la salida de <code>ls</code> y la alimentaremos al comando que ordena tablas basado en los valores de una columna (para este ejemplo sería la columna <code>size</code>).</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> reverse\n╭────┬───────────────────────┬──────┬───────────┬─────────────╮\n│ <span>#  │         name          │ type │   size    │  modified   │</span>\n├────┼───────────────────────┼──────┼───────────┼─────────────┤\n│  <span>0</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │\n│  <span>1</span> │ SUMMARY.md            │ <span>file</span> │   <span>3.7</span> KiB │ <span>3</span> days ago  │\n│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>3</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │\n│  <span>4</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>9</span> mins ago  │\n│  <span>5</span> │ books.md              │ <span>file</span> │     <span>687</span> B │ <span>3</span> days ago  │\n<span>..</span>.\n</code></pre></div><p>Puedes observar que para lograrlo no tuvimos que pasar argumentos al comando <code>ls</code>. En cambio, nosotros usamos el comando <code>sort-by</code> que proporciona Nu para ordenar la salida del comando <code>ls</code>. Para ver los archivos más grandes en las primeras filas usamos el comando <code>reverse</code>.</p>\n<p>Nu proporciona muchos comandos que trabajan con tablas. Por ejemplo, podemos filtrar los contenidos de la tabla de <code>ls</code> para únicamente mostrar archivos superiores a 1 kilobytes:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 1kb\n╭───┬───────────────────┬──────┬─────────┬────────────╮\n│ <span># │       name        │ type │  size   │  modified  │</span>\n├───┼───────────────────┼──────┼─────────┼────────────┤\n│ <span>0</span> │ Gemfile           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │\n│ <span>1</span> │ Gemfile.lock      │ <span>file</span> │ <span>6.9</span> KiB │ <span>3</span> days ago │\n│ <span>2</span> │ LICENSE           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │\n│ <span>3</span> │ SUMMARY.md        │ <span>file</span> │ <span>3.7</span> KiB │ <span>3</span> days ago │\n╰───┴───────────────────┴──────┴─────────┴────────────╯\n</code></pre></div><p>Al igual que en la filosofía Unix, poder hacer que los comandos hablen entre ellos nos da maneras de mezclar y combinar de formas distintas. Miremos otro ejemplo:</p>\n<div><pre><code><span>></span> <span>ps</span>\n╭─────┬──────┬──────────────────────┬─────────┬───────┬───────────┬──────────╮\n│  <span>#  │ pid  │         name         │ status  │  cpu  │    mem    │ virtual  │</span>\n├─────┼──────┼──────────────────────┼─────────┼───────┼───────────┼──────────┤\n│   <span>0</span> │ <span>7570</span> │ nu                   │ Running │  <span>1.96</span> │  <span>23.2</span> MiB │ <span>32.8</span> GiB │\n│   <span>1</span> │ <span>3533</span> │ remindd              │ Sleep   │  <span>0.00</span> │ <span>103.6</span> MiB │ <span>32.3</span> GiB │\n│   <span>2</span> │ <span>3495</span> │ TVCacheExtension     │ Sleep   │  <span>0.00</span> │  <span>11.9</span> MiB │ <span>32.2</span> GiB │\n│   <span>3</span> │ <span>3490</span> │ MusicCacheExtension  │ Sleep   │  <span>0.00</span> │  <span>12.9</span> MiB │ <span>32.2</span> GiB │\n<span>..</span>.\n</code></pre></div><p>Es posible que estés familiarizado con el comando <code>ps</code> si has utilizado Linux. Con dicho comando, podemos tener una lista de los procesos actuales que ejecuta el sistema, qué estado tienen y sus nombres. También podemos ver la carga CPU del proceso.</p>\n<p>¿Qué tal si quisiéramos mostrar los procesos que activamente usan el CPU? Así como hicimos con el comando <code>ls</code> previamente, también podemos trabajar con la tabla que nos devuelve <code>ps</code>:</p>\n<div><pre><code><span>></span> <span>ps</span> <span>|</span> where cpu <span>></span> <span>5</span>\n╭───┬──────┬────────────────┬─────────┬────────┬───────────┬──────────╮\n│ <span># │ pid  │      name      │ status  │  cpu   │    mem    │ virtual  │</span>\n├───┼──────┼────────────────┼─────────┼────────┼───────────┼──────────┤\n│ <span>0</span> │ <span>1583</span> │ Terminal       │ Running │  <span>20.69</span> │ <span>127.8</span> MiB │ <span>33.0</span> GiB │\n│ <span>1</span> │  <span>579</span> │ photoanalysisd │ Running │ <span>139.50</span> │  <span>99.9</span> MiB │ <span>32.3</span> GiB │\n╰───┴──────┴────────────────┴─────────┴────────┴───────────┴──────────╯\n</code></pre></div><p>Hasta ahora, hemos visto el uso de <code>ls</code> y <code>ps</code> para enumerar archivos y procesos. Nu también ofrece otros comandos que pueden crear tablas con información de gran utilidad. Exploremos <code>date</code> y <code>sys</code>.</p>\n<p>Ejecutando <code>date now</code> nos proporciona información del día y tiempo:</p>\n<div><pre><code><span>></span> <span>date</span> now\n<span>2022</span>-03-07 <span>14</span>:14:51.684619600 -08:00\n</code></pre></div><p>Para obtener una tabla podemos alimentar la salida a <code>date to-table</code></p>\n<div><pre><code><span>></span> <span>date</span> now <span>|</span> <span>date</span> to-table\n╭───┬──────┬───────┬─────┬──────┬────────┬────────┬──────────╮\n│ <span># │ year │ month │ day │ hour │ minute │ second │ timezone │</span>\n├───┼──────┼───────┼─────┼──────┼────────┼────────┼──────────┤\n│ <span>0</span> │ <span>2022</span> │     <span>3</span> │   <span>7</span> │   <span>14</span> │     <span>45</span> │      <span>3</span> │ -08:00   │\n╰───┴──────┴───────┴─────┴──────┴────────┴────────┴──────────╯\n</code></pre></div><p>Ejecutando <code>sys</code> devuelve información sobre el sistema en el que se ejecuta Nu:</p>\n<div><pre><code><span>></span> sys\n╭───────┬───────────────────╮\n│ <span>host</span>  │ <span>{</span>record <span>6</span> fields<span>}</span> │\n│ cpu   │ <span>[</span>table <span>4</span> rows<span>]</span>    │\n│ disks │ <span>[</span>table <span>3</span> rows<span>]</span>    │\n│ mem   │ <span>{</span>record <span>4</span> fields<span>}</span> │\n│ temp  │ <span>[</span>table <span>1</span> row<span>]</span>     │\n│ net   │ <span>[</span>table <span>4</span> rows<span>]</span>    │\n╰───────┴───────────────────╯\n</code></pre></div><p>Esta tabla se ve un poco diferente con las que ya hemos trabajado. El comando <code>sys</code> nos regresa una tabla que también contiene tablas estructuradas en las celdas en vez de valores simples. Para explorar esos datos, necesitamos <em>obtener</em> la columna deseada para mostrar:</p>\n<div><pre><code><span>></span> sys <span>|</span> get <span>host</span>\n╭────────────────┬────────────────────────╮\n│ name           │ Debian GNU/Linux       │\n│ os version     │ <span>11</span>                     │\n│ kernel version │ <span>5.10</span>.92-v8+            │\n│ <span>hostname</span>       │ lifeless               │\n│ <span>uptime</span>         │ 19day 21hr 34min 45sec │\n│ sessions       │ <span>[</span>table <span>1</span> row<span>]</span>          │\n╰────────────────┴────────────────────────╯\n</code></pre></div><p>El comando <code>get</code> nos permite ir directo al valor de una columa de la tabla. Aquí estamos mirando la columna &quot;host&quot; que contiene información del host dónde se está ejecutando Nu. El nombre del sistema operativo, hostname, CPU, y más. Miremos los nombres de los usuarios en el sistema:</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name\n╭───┬────╮\n│ <span>0</span> │ jt │\n╰───┴────╯\n</code></pre></div><p>En este momento, solo hay un usuario en el sistema llamado &quot;jt&quot;. Notarás que podemos pasar una ruta de columna <em>-<em>column path</em>-</em> y no únicamente el nombre de una columna. Nu tomará esta ruta de columna e irá a los datos correspondientes en la tabla.</p>\n<p>Es posible que hayas notado algo más diferente también. En lugar de tener una tabla de datos, tenemos solo un elemento individual: la cadena &quot;jt&quot;. Nu trabaja tanto con tabla de datos así como cadenas. Cadenas son una parte importante de trabajar con comandos fuera de Nu.</p>\n<p>Miremos en acción cómo funcionan las cadenas fuera de Nu. Tomaremos el ejemplo anterior y ejecutaremos el comando externo <code>echo</code> (el carácter <code>^</code> le informa a Nu que no se desea usar el comando <em>interno</em> también llamado <code>echo</code>):</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> ^echo <span>$it</span> <span>}</span>\njt\n</code></pre></div><p>Si esto se parece mucho a lo que teníamos antes, ¡tienes buen ojo! Es similar, pero con una diferencia importante: hemos llamado <code>echo</code> con el valor que vimos antes. Esto nos permite pasar datos fuera de Nu a <code>echo</code> (o cualquier comando fuera de Nu, como <code>git</code> por ejemplo)</p>\n<p><em>Nota: Para texto de ayuda de los comandos internos de Nu, puedes descubrirlos con el comando <code>help</code></em>:</p>\n<div><pre><code><span>></span> <span>help</span> path\nExplore and manipulate paths.\n\nThere are three ways to represent a path:\n\n* As a path literal, e.g., <span>'/home/viking/spam.txt'</span>\n* As a structured path: a table with <span>'parent'</span>, <span>'stem'</span>, and <span>'extension'</span> <span>(</span>and\n* <span>'prefix'</span> on Windows<span>)</span> columns. This <span>format</span> is produced by the <span>'path parse'</span>\n  subcommand.\n* As an inner list of path parts, e.g., <span>'[[ / home viking spam.txt ]]'</span><span>.</span>\n  Splitting into parts is <span>done</span> by the <span><span>`</span>path <span>split</span><span>`</span></span> command.\n\nAll subcommands accept all three variants as an input. Furthermore, the <span>'path\njoin'</span> subcommand can be used to <span>join</span> the structured path or path parts back into\nthe path literal.\n\nUsage:\n  <span>></span> path\n\nSubcommands:\n  path <span>basename</span> - Get the final component of a path\n  path <span>dirname</span> - Get the parent directory of a path\n  path exists - Check whether a path exists\n  path <span>expand</span> - Try to <span>expand</span> a path to its absolute form\n  path <span>join</span> - Join a structured path or a list of path parts.\n  path parse - Convert a path into structured data.\n  path relative-to - Get a path as relative to another path.\n  path <span>split</span> - Split a path into parts by a separator.\n  path <span>type</span> - Get the <span>type</span> of the object a path refers to <span>(</span>e.g., file, dir, symlink<span>)</span>\n\nFlags:\n  -h, --help\n      Display this <span>help</span> message\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.688Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Aliases",
      "url": "www.nushell.sh/es/book/aliases.html",
      "id": "www.nushell.sh/es/book/aliases.html",
      "content_html": "<h1 id=\"aliases\" tabindex=\"-1\"> Aliases</h1>\n<p>La habilidad de Nu para componer tuberías largas permite tener bastante control de su sistema y datos, pero a costas de tipear mucho. Sería ideal que puedas grabar las tuberías bien elaboradas para hacer uso de esas las veces que quieras.</p>\n<p>Aquí es donde aparecen los aliases.</p>\n<p>Un alias te permite crear un nombre corto para un bloque de comandos. Cuando se ejecuta el alias, es lo equivalente como si hayas tipeado el bloque de comandos.</p>\n<p>Ejemplo:</p>\n<div><pre><code>> alias ls-nombres [] { ls | select name }\n> ls-nombres\n────┬────────────────────\n #  │ name\n────┼────────────────────\n  0 │ 404.html\n  1 │ CONTRIBUTING.md\n  2 │ Gemfile\n  3 │ Gemfile.lock\n  4 │ LICENSE\n</code></pre></div><h2 id=\"parametros\" tabindex=\"-1\"> Parámetros</h2>\n<p>También pueden tomar parámetros opcionales que son pasadas al bloque. Cada parámetro se convierte en una variable en el bloque.</p>\n<div><pre><code>> alias decir [mensaje] { echo $mensaje }\n> decir \"¡hola!\"\n¡hola!\n</code></pre></div><p>Puedes tener un número arbitrario de estos argumentos. Cuando el usuario no proporciona un valor, la variable en el bloque evaulara a <code>Nothing</code> y será eliminada.</p>\n",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Cargando datos",
      "url": "www.nushell.sh/es/book/cargando_datos.html",
      "id": "www.nushell.sh/es/book/cargando_datos.html",
      "content_html": "<h1 id=\"cargando-datos\" tabindex=\"-1\"> Cargando datos</h1>\n<p>Hemos visto como puedes usar comandos como <code>ls</code>, <code>ps</code>, <code>date</code>, y <code>sys</code> para cargar información sobre los archivos, procesos, hora de fecha, y del mismo sistema. Cada comando nos entrega una tabla de información que podemos explorar. Hay otras maneras de cargar datos en una tabla de datos para trabajar.</p>\n<h2 id=\"abriendo-archivos\" tabindex=\"-1\"> Abriendo archivos</h2>\n<p>Una de las funciones más destacadas de Nu para trabajar con datos es el comando <code>open</code>. Es una multi-herramienta que puede trabajar con varios formatos de datos. Para ver qué significa esto intentemos abrir un archivo en formato json:</p>\n<div><pre><code>> open editors/vscode/package.json\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n name | descript | author   | license | version | reposito | publishe | categori | keywords | engines  | activati | main     | contribu | scripts  | devDepen\n      | ion      |          |         |         | ry       | r        | es       |          |          | onEvents |          | tes      |          | dencies\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n lark | Lark     | Lark     | MIT     | 1.0.0   | [object] | vscode   | [0       | [1 item] | [object] | [1 item] | ./out/ex | [object] | [object] | [object]\n      | support  | develope |         |         |          |          | items]   |          |          |          | tension  |          |          |\n      | for VS   | rs       |         |         |          |          |          |          |          |          |          |          |          |\n      | Code     |          |         |         |          |          |          |          |          |          |          |          |          |\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n</code></pre></div><p>De manera similar a <code>ls</code>, abrir un tipo de archivo que Nu entienda nos devolverá algo más que solo texto (o una secuencia de bytes). Aquí abrimos el archivo &quot;package.json&quot; de un proyecto de JavaScript. Nu puede reconocer y abrir el texto en JSON y devolvernos una tabla de datos.</p>\n<p>Si deseamos revisar la versión del proyecto que estamos mirando podemos usar el comando <code>get</code>.</p>\n<div><pre><code>> open editors/vscode/package.json | get version\n1.0.0\n</code></pre></div><p>Actualmente Nu soporta los siguiente formatos para cargar datos directamente a tablas:</p>\n<ul>\n<li>json</li>\n<li>yaml</li>\n<li>toml</li>\n<li>xml</li>\n<li>csv</li>\n<li>ini</li>\n</ul>\n<p>¿Pero qué sucede si cargas un archivo de texto que no sea de estos? Probemos:</p>\n<div><pre><code>> open README.md\n</code></pre></div><p>Se nos muestra el contenido del archivo. Si el archivo es muy grande obtendremos una vista práctica desplazable para mirar el archivo y luego regresar a la terminal. Para ayudar con legibilidad Nu resaltará la sintaxis de formatos comunes de archivos como de código, markdown, y más.</p>\n<p>Debajo de la superficie Nu mira estos archivos de texto como una cadena larga. Próximamente hablaremos de cómo trabajar con estas cadenas para extraer los datos que necesitemos de ellas.</p>\n<h2 id=\"trabajando-con-cadenas\" tabindex=\"-1\"> Trabajando con cadenas</h2>\n<p>Una parte importante de trabajar con datos llegando fuera de Nu es que no siempre estará en formato que Nu entiende. Comúnmente estos datos son proporcionados como una cadena.</p>\n<p>Imaginemos que nos proporcionan estos datos de archivo:</p>\n<div><pre><code>> open gente.txt\nOctavia | Butler | Writer\nBob | Ross | Painter\nAntonio | Vivaldi | Composer\n</code></pre></div><p>Cada pedazo de dato que deseamos está separada por el símbolo de tubería (pipe '|'), y cada persona está en líneas separadas. Nu no contiene un formato de archivo delimitado con pleca ('|') predeterminado, por lo que tendremos que parsearlo nosotros mismos.</p>\n<p>Lo primero que queremos hacer al cargar el archivo es trabajarlo línea por línea:</p>\n<div><pre><code>> open gente.txt | lines\n---+------------------------------\n # | value\n---+------------------------------\n 0 | Octavia | Butler | Writer\n 1 | Bob | Ross | Painter\n 2 | Antonio | Vivaldi | Composer\n---+------------------------------\n</code></pre></div><p>Podemos darnos cuenta que estamos trabajando con las líneas porque estamos de vuelta a una tabla. Nuestro próximo paso es mirar si podemos dividir las filas a algo más útil. Para eso, usaremos el comando <code>split</code>. <code>split</code>, como implica el nombre, nos da una manera de dividir una cadena delimitada. Usaremos el subcomando <code>column</code> para dividir el contenido a varias columnas. Indicamos cuál es el delimitador y se hace el resto:</p>\n<div><pre><code>> open gente.txt | lines | split column \"|\"\n---+----------+-----------+-----------\n # | Column1  | Column2   | Column3\n---+----------+-----------+-----------\n 0 | Octavia  |  Butler   |  Writer\n 1 | Bob      |  Ross     |  Painter\n 2 | Antonio  |  Vivaldi  |  Composer\n---+----------+-----------+-----------\n</code></pre></div><p>Casi se ve correcto. Parece que hay espacio extra ahí. Cambiemos nuestro delimitador:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \"\n---+---------+---------+----------\n # | Column1 | Column2 | Column3\n---+---------+---------+----------\n 0 | Octavia | Butler  | Writer\n 1 | Bob     | Ross    | Painter\n 2 | Antonio | Vivaldi | Composer\n---+---------+---------+----------\n</code></pre></div><p>Nada mal. El comando <code>split</code> nos da datos que podemos usar. Adicionalmente nos crea nombres de columnas predeterminadas:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \" | get Column1\n---+---------\n # | value\n---+---------\n 0 | Octavia\n 1 | Bob\n 2 | Antonio\n---+---------\n</code></pre></div><p>También podemos nombrar nuestras columnas en vez de usar nombres predeterminados:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \" primer_nombre apellido trabajo\n---+---------------+-----------+----------\n # | primer_nombre | apellido  | trabajo\n---+---------------+-----------+----------\n 0 | Octavia       | Butler    | Writer\n 1 | Bob           | Ross      | Painter\n 2 | Antonio       | Vivaldi   | Composer\n---+---------------+-----------+----------\n</code></pre></div><p>Ahora que tenemos nuestros datos en una tabla podemos usar todos los comandos que hemos usado en tablas antes:</p>\n<div><pre><code>> open gente.txt | lines | split column \" | \" primer_nombre apellido trabajo | sort-by primer_nombre\n---+---------------+-----------+----------\n # | primer_nombre | apellido  | trabajo\n---+---------------+-----------+----------\n 0 | Antonio       | Vivaldi   | Composer\n 1 | Bob           | Ross      | Painter\n 2 | Octavia       | Butler    | Writer\n---+---------------+-----------+----------\n</code></pre></div><p>Hay otros comandos que puedes usar para trabajar con cadenas:</p>\n<ul>\n<li>str</li>\n<li>lines</li>\n<li>size</li>\n</ul>\n<p>También hay un conjunto de comandos auxiliares que podemos llamar si conocemos de antemano que los datos tienen una estructura que Nu debería de entender. Por ejemplo, abramos un Rust archivo lock:</p>\n<div><pre><code>> open Cargo.lock\n# This file is automatically @generated by Cargo.\n# It is not intended for manual editing.\n[[package]]\nname = \"adhoc_derive\"\nversion = \"0.1.2\"\n</code></pre></div><p>The <code>from</code> command can be used for each of the structured data text formats that Nu can open and understand by passing it the supported format as a subcommand.</p>\n<p>El archivo &quot;Cargo.lock&quot; es un archivo en formato .toml pero la extensión del archivo no es .toml. Está bien, podemos usar el comando <code>from</code> usando el subcomando <code>toml</code>:</p>\n<div><pre><code>> open Cargo.lock | from toml\n----------+-------------\n metadata | package\n----------+-------------\n [object] | [405 items]\n----------+-------------\n</code></pre></div><p>El comando <code>from</code> se puede usar para cada dato estructurado de formatos de texto que Nu pueda abrir y entender pasando el formato soportado como subcomando.</p>\n<h2 id=\"abriendo-en-modo-crudo\" tabindex=\"-1\"> Abriendo en modo crudo</h2>\n<p>Mientras es útil poder abrir un archivo e inmediatamente trabajar con una tabla de sus datos, esto no siempre es lo que deseas hacer. Para llegar al texto subyacente, el comando <code>open</code> puede tomar una bandera opcional:</p>\n<div><pre><code>> open Cargo.toml --raw\n[package]\nname = \"nu\"\nversion = \"0.1.3\"\nauthors = [\"Yehuda Katz &lt;wycats@gmail.com>\", \"Jonathan Turner &lt;jonathan.d.turner@gmail.com>\"]\ndescription = \"A shell for the GitHub era\"\nlicense = \"MIT\"\n</code></pre></div><h2 id=\"abriendo-urls\" tabindex=\"-1\"> Abriendo URLs</h2>\n<p>Además de cargar archivos desde tu archivos de sistema, también puedes usar el comando <code>fetch</code> proporcionando una URL. Se cargará el contenido de la URL por internet y devolverá:</p>\n<div><pre><code>> fetch http://www.andresrobalino.com/feed.xml\n----------\n rss\n----------\n [1 item]\n----------\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Configuración",
      "url": "www.nushell.sh/es/book/configuracion.html",
      "id": "www.nushell.sh/es/book/configuracion.html",
      "content_html": "<h1 id=\"configuracion\" tabindex=\"-1\"> Configuración</h1>\n<p>Nu tiene un número pequeño, pero creciente, de variables internas que puedes establecer cambios en su aspecto y funcionamiento. A continuación una lista de las variables actuales, sus tipos, y una descripción de cómo se utilizan:</p>\n<table>\n<thead>\n<tr>\n<th>Variable</th>\n<th>Tipo</th>\n<th>Descripción</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>completion_mode</td>\n<td>&quot;list&quot; o &quot;circular&quot;</td>\n<td>el estilo de autocompletar a usar</td>\n</tr>\n<tr>\n<td>ctrlc_exit</td>\n<td>booleano</td>\n<td>salir o no de Nu después de presionar ctrl-c varias veces</td>\n</tr>\n<tr>\n<td>disable_table_indexes</td>\n<td>booleano</td>\n<td>elimina la columna de índice de la tabla</td>\n</tr>\n<tr>\n<td>edit_mode</td>\n<td>&quot;vi&quot; o &quot;emacs&quot;</td>\n<td>cambia edición de línea a modo &quot;vi&quot; o &quot;emacs&quot;</td>\n</tr>\n<tr>\n<td>env</td>\n<td>fila</td>\n<td>variables de entorno que serán pasadas a comandos externos</td>\n</tr>\n<tr>\n<td>header_align</td>\n<td>&quot;center&quot;, &quot;right&quot;, u otro</td>\n<td>alinea los encabezados de la tabla alineados al centro, a la derecha o a la izquierda</td>\n</tr>\n<tr>\n<td>key_timeout</td>\n<td>entero</td>\n<td>el tiempo de espera utilizado para cambiar entre los modos de edición</td>\n</tr>\n<tr>\n<td>nonzero_exit_errors</td>\n<td>booleano</td>\n<td>si imprimir errores para códigos de salida no-ceros para externos</td>\n</tr>\n<tr>\n<td>path</td>\n<td>tabla de cadenas</td>\n<td>PATH para usar en búsqueda de binarios</td>\n</tr>\n<tr>\n<td>startup</td>\n<td>lista de cadenas</td>\n<td>comandos, como <code>alias</code>es, para ejecutar cuando nushell arranca</td>\n</tr>\n<tr>\n<td>table_mode</td>\n<td>&quot;light&quot; o otro</td>\n<td>habilitar tablas livianas o normales</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"uso\" tabindex=\"-1\"> Uso</h2>\n<h3 id=\"configuracion-de-variables\" tabindex=\"-1\"> Configuración de variables</h3>\n<p>Para establecer una de estas variables, puedes usar <code>config set</code>. Por ejemplo:</p>\n<div><pre><code>> config set edit_mode \"vi\"\n</code></pre></div><h3 id=\"estableciendo-una-variable-desde-la-tuberia\" tabindex=\"-1\"> Estableciendo una variable desde la tubería</h3>\n<p>Hay una manera adicional de establecer una variable, y es usar el contenido de la tubería como el valor deseado para la variable. Para esto usa la bandera <code>set-into</code>:</p>\n<div><pre><code>> echo \"bar\" | config set_into foo\n</code></pre></div><p>Esto es de utilidad cuando se trabaja con las variables <code>env</code> y <code>path</code>.</p>\n<h3 id=\"listado-de-todas-las-variables\" tabindex=\"-1\"> Listado de todas las variables.</h3>\n<p>Ejecutando el comando <code>config</code> sin argumentos mostrará una tabla de las preferencias de configuración actuales:</p>\n<div><pre><code>> config\n━━━━━━━━━━━┯━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━┯━━━━━━━━━━━━\n edit_mode │ env            │ path             │ table_mode\n───────────┼────────────────┼──────────────────┼────────────\n emacs     │ [table: 1 row] │ [table: 10 rows] │ normal\n━━━━━━━━━━━┷━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━┷━━━━━━━━━━━━\n</code></pre></div><p>Nota: si por el momento no has establecido variables de configuración, puede estar vacía.</p>\n<h3 id=\"obteniendo-una-variable\" tabindex=\"-1\"> Obteniendo una variable</h3>\n<p>Usando la bandera <code>get</code>, puedes conseguir el valor de una variable:</p>\n<div><pre><code>> config get edit_mode\n</code></pre></div><h3 id=\"eliminando-una-variable\" tabindex=\"-1\"> Eliminando una variable</h3>\n<p>Para eliminar una variable de la configuración, usa la bandera <code>remove</code>:</p>\n<div><pre><code>> config remove edit_mode\n</code></pre></div><h3 id=\"borrar-toda-la-configuracion\" tabindex=\"-1\"> Borrar toda la configuración</h3>\n<p>Si deseas borrar toda la configuración y empezar de cero, puedes usar la bandera <code>clear</code>. Por supuesto, tenga precaución con esto ya que una vez ejecutado el archivo de configuración también se eliminará.</p>\n<div><pre><code>> config clear\n</code></pre></div><h3 id=\"encontrar-donde-se-almacena-el-archivo-de-configuracion\" tabindex=\"-1\"> Encontrar dónde se almacena el archivo de configuración</h3>\n<p>El archivo de configuración se carga desde una ubicación predeterminada. Para encontrar esta ubicación en el sistema, puedes solicitarla usando la bandera <code>path</code>:</p>\n<div><pre><code>config path\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n &lt;value>\n───────────────────────────────────────\n /home/nusheller/.config/nu/config.toml\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n</code></pre></div><h3 id=\"cargando-la-configuracion-desde-un-archivo\" tabindex=\"-1\"> Cargando la configuración desde un archivo</h3>\n<p>Es posible que desees cargar la configuración desde una ubicación distinta a la predeterminada. Para hacerlo, usa la bandera <code>load</code>:</p>\n<div><pre><code>> config load myconfiguration.toml\n</code></pre></div><h2 id=\"configurando-nu-como-shell-de-inicio-de-sesion\" tabindex=\"-1\"> Configurando Nu como shell de inicio de sesión</h2>\n<p>Para usar Nu como shell de inicio de sesión, necesitarás configurar las variables <code>path</code> y <code>env</code>. Con estos, obtendrás suficiente soporte para ejecutar comandos externos como shell de inicio de sesión.</p>\n<p>Antes de cambiarlo, ejecuta Nu dentro de otra shell, como Bash. Luego, obtén el entorno y PATH desde esa shell con los siguientes comandos:</p>\n<div><pre><code>> config set path $nu.path\n> config set env $nu.env\n</code></pre></div><p><code>$nu.path</code> y <code>$nu.env</code> son valores que están prestablecidas a las variables actuales de entorno y PATH, respectivamente. Una vez que las estableces a la configuración, estarán disponibles cuando uses Nu como shell de inicio de sesión.</p>\n<p>A continuación, en algunas distribuciones también deberás asegurarte de que Nu esté en la lista en <code>/etc/shells</code>:</p>\n<div><pre><code>❯ cat /etc/shells\n# /etc/shells: valid login shells\n/bin/sh\n/bin/dash\n/bin/bash\n/bin/rbash\n/usr/bin/screen\n/usr/bin/fish\n/home/jonathan/.cargo/bin/nu\n</code></pre></div><p>Con esto, deberías de poder hacer <code>chsh</code> y establecer Nu como la shell de inicio de sesión. Luego de cerrar sesión, en el próximo inicio de sesión deberías de recibir un brillante mensaje de Nu.</p>\n<h2 id=\"configuracion-del-prompt\" tabindex=\"-1\"> Configuración del prompt</h2>\n<p>Actualmente, la configuración del prompt es manejada instalando Nu con el soporte prompt proporcionado con <a href=\"https://github.com/starship/starship\" target=\"_blank\" rel=\"noopener noreferrer\">starship</a>.</p>\n<div><pre><code>nushell on 📙 master [$] is 📦 v0.5.1 via 🦀 v1.40.0-nightly\n❯\n</code></pre></div><p>Starship es un prompt divertido, colorido y sorprendentemente poderoso. Para configurarlo, sigue los pasos en su <a href=\"https://starship.rs/config/\" target=\"_blank\" rel=\"noopener noreferrer\">manual de configuración</a>.</p>\n",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Entorno",
      "url": "www.nushell.sh/es/book/entorno.html",
      "id": "www.nushell.sh/es/book/entorno.html",
      "content_html": "<h1 id=\"entorno\" tabindex=\"-1\"> Entorno</h1>\n<p>Una tarea común al usar una shell es controlar el ambiente de entorno que aplicaciones externas usarán. Comúnmente esto sucede automáticamente, a medida que el entorno se empaqueta y se entrega a la aplicación externa cuando se inicia. Sin embargo, hay veces que vamos a desear tener control más preciso sobre qué variables de entorno una aplicación pueda ver.</p>\n<p>Puedes ver las variables de entorno actuales que se enviarán a las aplicaciones explorando <code>#nu.env</code>:</p>\n<div><pre><code>> echo $nu.env\n──────────────────────────┬──────────────────────────────\n COLORTERM                │ truecolor\n DBUS_SESSION_BUS_ADDRESS │ unix:path=/run/user/1000/bus\n DESKTOP_SESSION          │ gnome\n DISPLAY                  │ :1\n</code></pre></div><p>El ambiente es creador a través de los ajustes en la configuración de Nu y a partir del entorno en el que se ejecuta Nu. Puedes actualizar el ambiente permanentement usando técnicas enumeradas en el capítulo de <a href=\"/es/book/configuracion.html\">configuración</a>.</p>\n<p>También puedes temporalmente actualizar una variable de entorno cuando ejecutas un comando o tubería de comandos.</p>\n<div><pre><code>> with-env [MI_VARIABLE VALOR] { echo $nu.env.MI_VARIABLE }\nVALOR\n</code></pre></div><p>El comando <code>with-env</code> establecerá temporalmente la variable de entorno dada (aquí: la variable &quot;MI_VARIABLE&quot; es dada el valor &quot;VALOR&quot;). Una vez hecho esto, el bloque se ejecutará con esta nueva variable de entorno establecida.</p>\n<p>A common shorthand, inspired by Bash and others, is also available. You can write the above example as:</p>\n<p>Una atajo común, inspirada en Bash y otros, también está disponible. Puedes escribir el ejemplo anterior como:</p>\n<div><pre><code>> MI_VARIABLE=VALOR echo $nu.env.MI_VARIABLE\nVALOR\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Escapando al sistema",
      "url": "www.nushell.sh/es/book/escapando.html",
      "id": "www.nushell.sh/es/book/escapando.html",
      "content_html": "<h1 id=\"escapando-al-sistema\" tabindex=\"-1\"> Escapando al sistema</h1>\n<p>Nu proporciona una serie de comandos que puedes utilitar en diferentes sistemas operativos y tener esta consistencia es de gran ayuda. Sin embargo, a veces, quieres ejecutar un comando que también tiene el mismo nombre de los comandos de Nu. Para ejecutar el comando local <code>ls</code> o <code>date</code> fuera de Nu por ejemplo, usa el comando de intercalación (^).</p>\n<p>Comando de Nu:</p>\n<div><pre><code>> ls\n</code></pre></div><p>Escapa al comando local:</p>\n<div><pre><code>> ^ls\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.689Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Explorando en el sistema",
      "url": "www.nushell.sh/es/book/explorando.html",
      "id": "www.nushell.sh/es/book/explorando.html",
      "content_html": "<h1 id=\"explorando-en-el-sistema\" tabindex=\"-1\"> Explorando en el sistema</h1>\n<p>Shells de antes permiten explorar el sistema de archivos y ejecutar comandos. Shells modernas como Nu permiten hacer lo mismo. Miremos algunos comandos comunes que puedas usar cuando interactues con el sistema.</p>\n<h2 id=\"ver-contenido-de-un-directorio\" tabindex=\"-1\"> Ver contenido de un directorio</h2>\n<div><pre><code><span>></span> <span>ls</span>\n</code></pre></div><p>Cómo hemos visto en otros capítulos, <code>ls</code> es un comando para mirar el contenido de una ruta. Nu devolverá el contenido en una tabla que podemos usar.</p>\n<p>El comando <code>ls</code> también recibe un argumento opcional para cambiar qué te gustaría ver. Por ejemplo, podemos enumerar los archivos que terminan en &quot;.md&quot;</p>\n<div><pre><code><span>></span> <span>ls</span> *.md\n───┬────────────────────┬──────┬─────────┬────────────\n <span># │ name               │ type │ size    │ modified </span>\n───┼────────────────────┼──────┼─────────┼────────────\n <span>0</span> │ CODE_OF_CONDUCT.md │ File │  <span>3.4</span> KB │ <span>5</span> days ago \n <span>1</span> │ CONTRIBUTING.md    │ File │   <span>886</span> B │ <span>5</span> days ago \n <span>2</span> │ README.md          │ File │ <span>15.0</span> KB │ <span>5</span> days ago \n <span>3</span> │ TODO.md            │ File │  <span>1.6</span> KB │ <span>5</span> days ago \n───┴────────────────────┴──────┴─────────┴────────────\n</code></pre></div><p>El asterisco (*) en el argumento que pasamos &quot;*.md&quot; a veces se llama comodín o glob. Nos permite complementar cualquier cosa. Puedes leer el glob &quot;*.md&quot; como &quot;complementa cualquier archivo siempre y cuando termine en '.md'&quot;</p>\n<p>Nu también usa globs modernos permitiendo acceder directorios más profundos.</p>\n<div><pre><code> <span>ls</span> **/*.md\n────┬───────────────────────────────────────────┬──────┬─────────┬────────────\n <span>#  │ name                                      │ type │ size    │ modified </span>\n────┼───────────────────────────────────────────┼──────┼─────────┼────────────\n  <span>0</span> │ .github/ISSUE_TEMPLATE/bug_report.md      │ File │   <span>592</span> B │ <span>5</span> days ago \n  <span>1</span> │ .github/ISSUE_TEMPLATE/feature_request.md │ File │   <span>595</span> B │ <span>5</span> days ago \n  <span>2</span> │ CODE_OF_CONDUCT.md                        │ File │  <span>3.4</span> KB │ <span>5</span> days ago \n  <span>3</span> │ CONTRIBUTING.md                           │ File │   <span>886</span> B │ <span>5</span> days ago \n  <span>4</span> │ README.md                                 │ File │ <span>15.0</span> KB │ <span>5</span> days ago \n  <span>5</span> │ TODO.md                                   │ File │  <span>1.6</span> KB │ <span>5</span> days ago \n  <span>6</span> │ crates/nu-source/README.md                │ File │  <span>1.7</span> KB │ <span>5</span> days ago \n  <span>7</span> │ docker/packaging/README.md                │ File │  <span>1.5</span> KB │ <span>5</span> days ago \n  <span>8</span> │ docs/commands/README.md                   │ File │   <span>929</span> B │ <span>5</span> days ago \n  <span>9</span> │ docs/commands/alias.md                    │ File │  <span>1.7</span> KB │ <span>5</span> days ago \n <span>10</span> │ docs/commands/append.md                   │ File │  <span>1.4</span> KB │ <span>5</span> days ago\n</code></pre></div><p>Aquí, buscamos cualquier archivo que termine con &quot;.md&quot;, y los dos asteriscos dicen además &quot;en cualquier directorio que comience desde aquí&quot;.</p>\n<h2 id=\"cambiar-el-directorio-actual\" tabindex=\"-1\"> Cambiar el directorio actual</h2>\n<div><pre><code><span>></span> <span>cd</span> new_directory\n</code></pre></div><p>Para cambiar del directorio actual a uno nuevo usamos el comando <code>cd</code>. Al igual que en otras shells, podemos usar tanto el nombre del directorio o si deseamos subir a un directorio podemos usar el acceso directo <code>..</code>.</p>\n<p>También se puede cambiar el directorio si se omite <code>cd</code> y se proporciona una ruta por si sola:</p>\n<div><pre><code><span>></span> ./new_directory\n</code></pre></div><h2 id=\"comandos-del-sistema-de-archivos\" tabindex=\"-1\"> Comandos del sistema de archivos</h2>\n<p>Nu también proporciona algunos comandos básicos del sistema de archivos que funcionan multiplataforma.</p>\n<p>Podemos mover un item de un lugar a otro usando el comando <code>mv</code>:</p>\n<div><pre><code><span>></span> <span>mv</span> item location\n</code></pre></div><p>Podemos copiar un item de un lugar a otro:</p>\n<div><pre><code><span>></span> <span>cp</span> item location\n</code></pre></div><p>Podemos eliminar un item.</p>\n<div><pre><code><span>></span> <span>rm</span> item\n</code></pre></div><p>Los tres comandos también pueden usar las capacidades de glob que vimos previamente con <code>ls</code>.</p>\n<p>Finalmente, podemos crear un directorio usando el comando <code>mkdir</code>:</p>\n<div><pre><code><span>></span> <span>mkdir</span> new_directory\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.690Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Instalando Nu",
      "url": "www.nushell.sh/es/book/instalacion.html",
      "id": "www.nushell.sh/es/book/instalacion.html",
      "content_html": "<h1 id=\"instalando-nu\" tabindex=\"-1\"> Instalando Nu</h1>\n<p>La mejor manera actualmente para poner en marcha Nu es instalándolo a través de <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a>, descargando desde <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">nuestra página</a>, y compilar desde la fuente.</p>\n<h2 id=\"binarios\" tabindex=\"-1\"> Binarios</h2>\n<p>Puedes descargar Nu compilado desde <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">nuestra página</a>. Alternativamente, si usas <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Homebrew</a> para macOS, puedes instalar el binario ejecutando <code>brew install nushell</code>.</p>\n<h3 id=\"windows\" tabindex=\"-1\"> Windows</h3>\n<p><strong>nota:</strong> Nu trabaja con Windows 10 y no soporta Windows 7/8.1</p>\n<p>Descarga el archivo actual <code>.zip</code> <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">de la página de releases</a> y extráelo por ejemplo a:</p>\n<div><pre><code> C:\\Program Files\n</code></pre></div><p>y posteriormente agrega Nu a la variable de entorno <code>PATH</code>. Una vez que hagamos eso, podemos ejecutar Nu usando el comando <code>nu</code>:</p>\n<div><pre><code> > nu\n C:\\Users\\user>\n</code></pre></div><p>Si te encuentras usando <a href=\"https://github.com/microsoft/terminal\" target=\"_blank\" rel=\"noopener noreferrer\">Windows Terminal</a> puedes establecer <code>nu</code> como la shell por defecto añadiendo:</p>\n<div><pre><code>{\n \"guid\": \"{2b372ca1-1ee2-403d-a839-6d63077ad871}\",\n \"hidden\": false,\n \"name\": \"Nu Shell\",\n \"commandline\": \"nu.exe\"\n}\n</code></pre></div><p>a <code>&quot;profiles&quot;</code> en las preferencias de tu Terminal (archivo JSON). Lo último que tienes que hacer es cambiar <code>&quot;defaultProfile&quot;</code> a:</p>\n<div><pre><code>\"defaultProfile\": \"{2b372ca1-1ee2-403d-a839-6d63077ad871}\",\n</code></pre></div><p>Ahora <code>nu</code> debería cargar al inicio de la Terminal de Windows.</p>\n<h2 id=\"preparacion\" tabindex=\"-1\"> Preparación</h2>\n<p>Antes de que podamos instalar Nu, necesitamos asegurarnos de que nuestro sistema tenga los requerimientos necesarios. Actualmente significa que debemos verificar tener instalado tanto el Rust toolchain así como las dependencias locales. Estás son las suites de compilación recomendadas:</p>\n<ul>\n<li>Linux: GCC or Clang</li>\n<li>macOS: Clang (install Xcode)</li>\n<li>Windows: <a href=\"https://visualstudio.microsoft.com/vs/community/\" target=\"_blank\" rel=\"noopener noreferrer\">Visual Studio Community Edition</a></li>\n</ul>\n<p>Para Linux y macOS, una vez que hayas instalado la suite de compilación, todo estará listo para instalar Rust a través de <code>rustup</code> (ver más abajo).</p>\n<p>For Windows, when you install Visual Studio Community Edition, make sure to install the &quot;C++ build tools&quot; as what we need is <code>link.exe</code> which is provided as part of that optional install. With that, we're ready to move to the next step.</p>\n<p>Para Windows, cuando instalas Visual Studio Community Edition, asegúrate de instalar las herramientas &quot;C++ build tools&quot; ya que lo que necesitamos es <code>link.exe</code>, que es proporcionado como parte de esa instalación optcional. Con eso, estamos listos para el siguiente paso.</p>\n<h3 id=\"instalando-un-suite-de-compilacion\" tabindex=\"-1\"> Instalando un suite de compilación</h3>\n<p>Para que Rust funcione correctamente, necesitarás tener un suite de compilación compatible instalado en el sistema.</p>\n<h3 id=\"instalando-rust\" tabindex=\"-1\"> Instalando Rust</h3>\n<p>En el caso de que no dispongamos de Rust en nuestro sistema la mejor manera de instalarlo es mediante <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">rustup</a>. Rustup es una manera de manejar instalaciones de Rust incluyendo distintas versiones de Rust.</p>\n<p>Nu actualmente requiere la versión <strong>estable más reciente (1.55 o posterior)</strong> de Rust. La mejor manera de <code>rustup</code> inferir la versión correcta para ti. En el momento de abrir <code>rustup</code> te solicitará qué versión de Rust deseas instalar:</p>\n<div><pre><code>Current installation options:\n\n   default host triple: x86_64-unknown-linux-gnu\n     default toolchain: stable\n  modify PATH variable: yes\n\n1) Proceed with installation (default)\n2) Customize installation\n3) Cancel installation\n</code></pre></div><p>Una vez que estamos listos, presionamos 1 y luego enter.</p>\n<p>Si prefieres no instalar Rust mediante <code>rustup</code>, también puedes instalar a través de otros métodos (Ej. un paquete en alguna distribución de Linux). Solo asegúrate de instalar una versión que sea Rust 1.55 o posterior.</p>\n<h2 id=\"dependencias\" tabindex=\"-1\"> Dependencias</h2>\n<h3 id=\"debian-ubuntu\" tabindex=\"-1\"> Debian/Ubuntu</h3>\n<p>Vas a necesitar instalar &quot;pkg-config&quot; y &quot;libssl-dev&quot;:</p>\n<p>&lt;&lt;&lt; @/snippets/installation/install_pkg_config_libssl_dev.sh</p>\n<p>Usuarios de Linux que desean usar las funcionalidades opcionales <code>rawkey</code> o <code>clipboard</code> necesitarán instalar los paquetes &quot;libx11-dev&quot; y &quot;libxcb-composite0-dev&quot;:</p>\n<p>&lt;&lt;&lt; @/snippets/installation/use_rawkey_and_clipboard.sh</p>\n<h3 id=\"distribuciones-basadas-en-rhel\" tabindex=\"-1\"> Distribuciones basadas en RHEL</h3>\n<p>Vas a necesitar instalar &quot;libxcb&quot;, &quot;openssl-devel&quot; and &quot;libX11-devel&quot;:</p>\n<p>&lt;&lt;&lt; @/snippets/installation/install_rhel_dependencies.sh</p>\n<h3 id=\"macos\" tabindex=\"-1\"> macOS</h3>\n<p>Usando <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">homebrew</a>, vas a necesitar instalar la fórmula &quot;openssl&quot;:</p>\n<div><pre><code>brew install openssl cmake\n</code></pre></div><h2 id=\"instalando-desde-crates-io\" tabindex=\"-1\"> Instalando desde <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a></h2>\n<p>Una vez instaladas las depependencias que Nu necesita, podemos instalarla usando el comando <code>cargo</code> que viene con el compilador Rust.</p>\n<div><pre><code>> cargo install nu\n</code></pre></div><p>¡Eso es todo! Cargo hará el trabajo de descarga Nu junto con sus dependencias, construirla e instalarla en el bin path de cargo para que podamos arrancarlo.</p>\n<p>Si deseas instalar con más funcionalidades, puedes hacer:</p>\n<div><pre><code>> cargo install nu --features=stable\n</code></pre></div><p>Para todas las funcionalidades disponibles, la manera más fácil es descargar la fuente de Nu y construírlo usted mismo usando las herramientas de Rust:</p>\n<div><pre><code>> git clone https://github.com/nushell/nushell.git\n> cd nushell\nnushell> cargo install --path . --force --features=stable\n\nPara que esto funcione, asegúrate de tener todas las dependencias instaladas (que se muestran arriba) en el sistema.\n\nFinalizada la instalación podemos ejecutar Nu usando el comando `nu`:\n\n</code></pre></div><p>$ nu\n/home/jonathan/Source&gt;</p>\n<div><pre><code>\n## Construyendo desde la fuente\n\nTambién podemos contruir nuestro propio Nu directamente desde github. Esto nos da acceso inmediato a las últimas funcionalidades y corrección de bugs.\n\n</code></pre></div><blockquote>\n<p>git clone https://github.com/nushell/nushell.git</p>\n</blockquote>\n<div><pre><code>\nGit nos clonará el repositorio principal de Nu. Partiendo de ahí podemos contruir y arrancar Nu si estamos usando `rustup` con:\n\n</code></pre></div><blockquote>\n<p>cd nushell\nnushell&gt; cargo build --workspace --features=stable &amp;&amp; cargo run --features=stable</p>\n</blockquote>\n<div><pre><code>\nTambién puedes construir y arrancar Nu en modo release:\n\n</code></pre></div><p>nushell&gt; cargo build --release --workspace --features=stable &amp;&amp; cargo run --release --features=stable</p>\n<div><pre><code>Gente familiarizada con Rust se preguntará la razón por la que hacemos un paso \"build\" y otro paso \"run\" si \"run\" construye por defecto. Esto es para evitar una deficiencia de la nueva opción `default-run` en Cargo y asegurar que todos los plugins se construyan aunque puede que esto no sea necesario en el futuro.\n\n**Nota:** Si te encuentras trabajando tanto en modo debug y release, asegúrate de ejecutar `cargo clean` cuando cambies entre ellas. Nu buscará plugins en los directorios tanto de debug así como release y puede suceder que cargue versiones de un plugin que no tienes intenciones de usar.\n\n## Establecer como shell de inicio de sesión\n\n**!!! Nu todavía está en desarrollo y puede no ser estable para uso diario. !!!**\n\nPara configurar la shell de inicio de sesión, puedes usra el comando [`chsh`](https://linux.die.net/man/1/chsh).\nEn algunas distribuciones de Linux se encuentra una lista válida de shells en `/etc/shells` y no permitirá cambiar la shell hasta que Nu esté en la lista blanca. Es posible que vea un error similar al siguiente si no ha actualizado el archivo `shells`:\n\n</code></pre></div><p>chsh: /home/username/.cargo/bin/nu is an invalid shell</p>\n<div><pre><code>\nPuedes agregar Nu a la lista de shells válidas añadiendo el binario al archivo `shells`. La ruta para agregar puedes encontrarla con el comando `which nu`, usualmente es `$HOME/.cargo/bin/nu`.\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.690Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Llegando desde Bash",
      "url": "www.nushell.sh/es/book/llegando_de_bash.html",
      "id": "www.nushell.sh/es/book/llegando_de_bash.html",
      "content_html": "<h1 id=\"llegando-desde-bash\" tabindex=\"-1\"> Llegando desde Bash</h1>\n<p>Nota: Esta tabla asume Nushell 0.14.1 or posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Bash</th>\n<th>Nu</th>\n<th>Task</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ls</code></td>\n<td><code>ls</code></td>\n<td>Lists the files in the current directory</td>\n</tr>\n<tr>\n<td><code>ls &lt;dir&gt;</code></td>\n<td><code>ls &lt;dir&gt;</code></td>\n<td>Lists the files in the given directory</td>\n</tr>\n<tr>\n<td><code>ls pattern*</code></td>\n<td><code>ls pattern*</code></td>\n<td>Lists files that match a given pattern</td>\n</tr>\n<tr>\n<td><code>ls -la</code></td>\n<td><code>ls --long --all</code> or <code>ls -la</code></td>\n<td>List files with all available information, including hidden files</td>\n</tr>\n<tr>\n<td><code>ls -d */</code></td>\n<td><code>ls | where type == Dir</code></td>\n<td>List directories</td>\n</tr>\n<tr>\n<td><code>find . -name *.rs</code></td>\n<td><code>ls **/*.rs</code></td>\n<td>Find recursively all files that match a given pattern</td>\n</tr>\n<tr>\n<td><code>cd &lt;directory&gt;</code></td>\n<td><code>cd &lt;directory&gt;</code></td>\n<td>Change to the given directory</td>\n</tr>\n<tr>\n<td><code>cd</code></td>\n<td><code>cd</code></td>\n<td>Change to the home directory</td>\n</tr>\n<tr>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td>Creates the given path</td>\n</tr>\n<tr>\n<td><code>mkdir -p &lt;path&gt;</code></td>\n<td><code>mkdir &lt;path&gt;</code></td>\n<td>Creates the given path, creating parents as necessary</td>\n</tr>\n<tr>\n<td><code>touch test.txt</code></td>\n<td><code>touch test.txt</code></td>\n<td>Create a file</td>\n</tr>\n<tr>\n<td><code>&gt; &lt;path&gt;</code></td>\n<td><code>| save --raw &lt;path&gt;</code></td>\n<td>Save string into a file</td>\n</tr>\n<tr>\n<td><code>cat &lt;path&gt;</code></td>\n<td><code>open --raw &lt;path&gt;</code></td>\n<td>Display the contents of the given file</td>\n</tr>\n<tr>\n<td></td>\n<td><code>open &lt;path&gt;</code></td>\n<td>Read a file as structured data</td>\n</tr>\n<tr>\n<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Move file to new location</td>\n</tr>\n<tr>\n<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Copy file to new location</td>\n</tr>\n<tr>\n<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>\n<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>\n<td>Copy directory to a new location, recursively</td>\n</tr>\n<tr>\n<td><code>rm &lt;path&gt;</code></td>\n<td><code>rm &lt;path&gt;</code></td>\n<td>Remove the given file</td>\n</tr>\n<tr>\n<td></td>\n<td><code>rm -t &lt;path&gt;</code></td>\n<td>Move the given file to the system trash</td>\n</tr>\n<tr>\n<td><code>rm -rf &lt;path&gt;</code></td>\n<td><code>rm -r &lt;path&gt;</code></td>\n<td>Recursively removes the given path</td>\n</tr>\n<tr>\n<td><code>chmod</code></td>\n<td><code>&lt;not yet possible&gt;</code></td>\n<td>Changes the file attributes</td>\n</tr>\n<tr>\n<td><code>date -d &lt;date&gt;</code></td>\n<td><code>echo &lt;date&gt; | str to-datetime -f &lt;format&gt;</code></td>\n<td>Parse a date (<a href=\"https://docs.rs/chrono/0.4.15/chrono/format/strftime/index.html\" target=\"_blank\" rel=\"noopener noreferrer\">format documentation</a>)</td>\n</tr>\n<tr>\n<td><code>sed</code></td>\n<td><code>str find-replace</code></td>\n<td>Find and replace a pattern in a string</td>\n</tr>\n<tr>\n<td><code>grep &lt;pattern&gt;</code></td>\n<td><code>where $it =~ &lt;substring&gt;</code></td>\n<td>Filter strings that contain the substring</td>\n</tr>\n<tr>\n<td><code>man &lt;command&gt;</code></td>\n<td><code>help &lt;command&gt;</code></td>\n<td>Get the help for a given command</td>\n</tr>\n<tr>\n<td></td>\n<td><code>help commands</code></td>\n<td>List all available commands</td>\n</tr>\n<tr>\n<td></td>\n<td><code>help --find &lt;string&gt;</code></td>\n<td>Search for match in all available commands</td>\n</tr>\n<tr>\n<td><code>command1 &amp;&amp; command2</code></td>\n<td><code>command1; command2</code></td>\n<td>Run a command, and if it's successful run a second</td>\n</tr>\n<tr>\n<td><code>stat $(which git)</code></td>\n<td><code>stat (which git).path</code></td>\n<td>Use command output as argument for other command</td>\n</tr>\n<tr>\n<td><code>echo $PATH</code></td>\n<td><code>echo $nu.path</code></td>\n<td>See the current path</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>config set path [&lt;dir1&gt; &lt;dir2&gt; ...]</code></td>\n<td>Update PATH permanently</td>\n</tr>\n<tr>\n<td><code>export PATH = $PATH:/usr/other/bin</code></td>\n<td><code>pathvar add &lt;path&gt;</code></td>\n<td>Update PATH temporarily</td>\n</tr>\n<tr>\n<td><code>export</code></td>\n<td><code>echo $nu.env</code></td>\n<td>List the current environment variables</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>echo $nu.env | insert var value | config set_into env</code></td>\n<td>Update environment variables permanently</td>\n</tr>\n<tr>\n<td><code>FOO=BAR ./bin</code></td>\n<td><code>FOO=BAR ./bin</code></td>\n<td>Update environment temporarily</td>\n</tr>\n<tr>\n<td><code>export FOO=BAR</code></td>\n<td><code>let-env FOO = BAR</code></td>\n<td>Set environment variable for current session</td>\n</tr>\n<tr>\n<td><code>unset FOO</code></td>\n<td><code>let-env FOO = $nothing</code></td>\n<td>Unset environment variable for current session</td>\n</tr>\n<tr>\n<td><code>alias s=&quot;git status -sb&quot;</code></td>\n<td><code>alias s = git status -sb</code></td>\n<td>Define an alias temporarily</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>config set [startup [&quot;alias myecho [msg] { echo Hello $msg }&quot;]]</code></td>\n<td>Add a first alias permanently (for new shells)</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>config get startup | append &quot;alias s [] { git status -sb }&quot; | config set_into startup</code></td>\n<td>Add an additional alias permanently (for new shells)</td>\n</tr>\n<tr>\n<td><code>&lt;update ~/.bashrc&gt;</code></td>\n<td><code>&lt;update nu/config.toml&gt;</code></td>\n<td>Add and edit alias permanently (for new shells), find path for the file with <code>config path</code></td>\n</tr>\n<tr>\n<td><code>bash -c &lt;commands&gt;</code></td>\n<td><code>nu -c &lt;commands&gt;</code></td>\n<td>Run a pipeline of commands (requires 0.9.1 or later)</td>\n</tr>\n<tr>\n<td><code>bash &lt;script file&gt;</code></td>\n<td><code>nu &lt;script file&gt;</code></td>\n<td>Run a script file (requires 0.9.1 or later)</td>\n</tr>\n<tr>\n<td><code>\\</code></td>\n<td><code>&lt;not yet possible&gt;</code></td>\n<td>Line continuation is not yet supported.</td>\n</tr>\n</tbody>\n</table>\n",
      "date_modified": "2022-06-02T15:48:22.690Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa nushell de lenguajes funcionales",
      "url": "www.nushell.sh/es/book/mapa_funcional_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_funcional_nushell.html",
      "content_html": "<h1 id=\"mapa-nushell-de-lenguajes-funcionales\" tabindex=\"-1\"> Mapa nushell de lenguajes funcionales</h1>\n<p>La idea detrás de esta tabla is ayudarte a entender como los comandos internos y plugins en Nu se relacionan con lenguajes funcionales. Hemos intentado producir un mapa de los comandos internos y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: Esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>Clojure</th>\n<th>Tablecloth (Ocaml / Elm)</th>\n<th>Haskell</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alias</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>append</td>\n<td>conj</td>\n<td></td>\n<td>(++)</td>\n<td></td>\n</tr>\n<tr>\n<td>args</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>autoview</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>average(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>binaryview(<code>*</code>)</td>\n<td>Integer/toHexString</td>\n<td></td>\n<td>showHex</td>\n<td></td>\n</tr>\n<tr>\n<td>calc, = math</td>\n<td>math operators</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>cd</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clear</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clip</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>compact</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>config</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>count</td>\n<td>count</td>\n<td>length</td>\n<td>length</td>\n<td></td>\n</tr>\n<tr>\n<td>cp</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>date</td>\n<td>java.time.LocalDate/now</td>\n<td></td>\n<td>Get-Date</td>\n<td></td>\n</tr>\n<tr>\n<td>debug</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>drop</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>du</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>each</td>\n<td>map</td>\n<td>map</td>\n<td>map</td>\n<td></td>\n</tr>\n<tr>\n<td>echo</td>\n<td>println</td>\n<td></td>\n<td>putStrLn, print</td>\n<td></td>\n</tr>\n<tr>\n<td>enter</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>evaluate_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>exit</td>\n<td>System/exit</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>fetch(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>first</td>\n<td>first</td>\n<td></td>\n<td>head</td>\n<td></td>\n</tr>\n<tr>\n<td>format</td>\n<td>format</td>\n<td></td>\n<td>Text.Printf.printf</td>\n<td></td>\n</tr>\n<tr>\n<td>from bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from csv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from eml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ics</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ini</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from json</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ods</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from sqlite</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ssv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from vcf</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xlsx</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>get</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>group_by</td>\n<td>group-by</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>headers</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>help</td>\n<td>doc</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>histogram</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>history</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>inc(<code>*</code>)</td>\n<td>inc</td>\n<td></td>\n<td>succ</td>\n<td></td>\n</tr>\n<tr>\n<td>insert</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>is_empty</td>\n<td>empty?</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep</td>\n<td>take, drop-last, pop</td>\n<td></td>\n<td>init, take</td>\n<td></td>\n</tr>\n<tr>\n<td>keep_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_while</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kill</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>last</td>\n<td>last, peek</td>\n<td></td>\n<td>last</td>\n<td></td>\n</tr>\n<tr>\n<td>lines</td>\n<td></td>\n<td></td>\n<td>lines, words, split-with</td>\n<td></td>\n</tr>\n<tr>\n<td>ls</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>map_max_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>match(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>merge</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>next</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>nth</td>\n<td>nth</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>open</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>parse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pivot</td>\n<td>(apply mapv vector matrix)</td>\n<td></td>\n<td>transpose</td>\n<td></td>\n</tr>\n<tr>\n<td>post(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prepend</td>\n<td>cons</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prev</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ps(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pwd</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>range</td>\n<td></td>\n<td></td>\n<td>1..10, 'a'..'f'</td>\n<td></td>\n</tr>\n<tr>\n<td>reduce_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reject</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rm</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>save</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>select(<code>***</code>)</td>\n<td>select-keys</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shells</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shuffle</td>\n<td>shuffle</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>size</td>\n<td>count</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip</td>\n<td>rest</td>\n<td></td>\n<td>tail</td>\n<td></td>\n</tr>\n<tr>\n<td>skip_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_while</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sort-by</td>\n<td>sort-by</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_column</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_row</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>str(<code>*</code>)</td>\n<td>clojure.string functions</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sum</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sys(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>table</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tags</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>textview(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tree(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to csv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to html</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to json</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to md</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to sqlite</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>touch</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>trim</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>uniq</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>update(<code>**</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>version</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>with_env</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>what</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>where</td>\n<td>filter</td>\n<td></td>\n<td>filter</td>\n<td></td>\n</tr>\n<tr>\n<td>which</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>wrap</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>*</code> - Pertenecen de los plugins standard</li>\n<li><code>**</code> - renombrada de <code>edit</code> a <code>update</code> en 0.13.1</li>\n<li><code>***</code> - renombrada de <code>pick</code> a <code>select</code> en 0.13.1</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.691Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa nushell de lenguajes imperativos",
      "url": "www.nushell.sh/es/book/mapa_imperativo_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_imperativo_nushell.html",
      "content_html": "<h1 id=\"mapa-nushell-de-lenguajes-imperativos\" tabindex=\"-1\"> Mapa nushell de lenguajes imperativos</h1>\n<p>La idea detrás de esta tabla is ayudarte a entender como los comandos internos y plugins en Nu se relacionan con lenguajes imperativos. Hemos intentado producir un mapa de los comandos internos y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>Python</th>\n<th>Kotlin (Java)</th>\n<th>C++</th>\n<th>Rust</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alias</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>append</td>\n<td>list.append, set.add</td>\n<td>add</td>\n<td>push_back, emplace_back</td>\n<td>push, push_back</td>\n</tr>\n<tr>\n<td>args</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>autoview</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>average(<code>*</code>)</td>\n<td>statistics.mean</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>binaryview(<code>*</code>)</td>\n<td>&quot;{:x}&quot;.format</td>\n<td>Integer.toHexString</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>calc, = math</td>\n<td>math operators</td>\n<td>math operators</td>\n<td>math operators</td>\n<td>math operators</td>\n</tr>\n<tr>\n<td>cd</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clear</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>clip</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>compact</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>config</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>count</td>\n<td>len</td>\n<td>size, length</td>\n<td>length</td>\n<td>len</td>\n</tr>\n<tr>\n<td>cp</td>\n<td>shutil.copy</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>date</td>\n<td>datetime.date.today</td>\n<td>java.time.LocalDate.now</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>debug</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>drop</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>du</td>\n<td>shutil.disk_usage</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>each</td>\n<td>for</td>\n<td>for</td>\n<td>for</td>\n<td>for</td>\n</tr>\n<tr>\n<td>echo</td>\n<td>print</td>\n<td>println</td>\n<td>printf</td>\n<td>println!</td>\n</tr>\n<tr>\n<td>enter</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>evaluate_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>exit</td>\n<td>exit</td>\n<td>System.exit, kotlin.system.exitProcess</td>\n<td>exit</td>\n<td>exit</td>\n</tr>\n<tr>\n<td>fetch(<code>*</code>)</td>\n<td>urllib.request.urlopen</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>first</td>\n<td>list[0]</td>\n<td>List[0], peek</td>\n<td>vector[0], top</td>\n<td>vec[0]</td>\n</tr>\n<tr>\n<td>format</td>\n<td>format</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from csv</td>\n<td>csv</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from eml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ics</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ini</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from json</td>\n<td>json</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ods</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from sqlite</td>\n<td>sqlite3</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from ssv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from vcf</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xlsx</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from xml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>from yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>get</td>\n<td>dict[&quot;key&quot;]</td>\n<td>Map[&quot;key&quot;]</td>\n<td>map[&quot;key&quot;]</td>\n<td></td>\n</tr>\n<tr>\n<td>group_by</td>\n<td>itertools.groupby</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>headers</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>help</td>\n<td>help</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>histogram</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>history</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>inc(<code>*</code>)</td>\n<td>x += 1</td>\n<td>x++</td>\n<td>x++</td>\n<td>+= 1</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>list.insert</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>is_empty</td>\n<td>is None</td>\n<td>isEmpty</td>\n<td>empty</td>\n<td></td>\n</tr>\n<tr>\n<td>keep</td>\n<td>list[:x]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_while</td>\n<td>itertools.takewhile</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>os.kill</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>last</td>\n<td>list[-1]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>lines</td>\n<td>split, splitlines</td>\n<td>split</td>\n<td>views::split</td>\n<td></td>\n</tr>\n<tr>\n<td>ls</td>\n<td>os.listdir</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>map_max_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>match(<code>*</code>)</td>\n<td>re</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>merge</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td>os.mkdir</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mv</td>\n<td>shutil.move</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>next</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>nth</td>\n<td>list[x]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>open</td>\n<td>open</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>parse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pivot</td>\n<td>zip(*matrix)</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>post(<code>*</code>)</td>\n<td>urllib.request.urlopen</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prepend</td>\n<td>deque.appendleft</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prev</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ps(<code>*</code>)</td>\n<td>os.listdir('/proc')</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>os.getcwd</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>range</td>\n<td>range</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reduce_by</td>\n<td>functools.reduce</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reject</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td>shutil.move</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reverse</td>\n<td>reversed, list.reverse</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rm</td>\n<td>os.remove</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>save</td>\n<td>io.TextIOWrapper.write</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>select(<code>***</code>)</td>\n<td>{k:dict[k] for k in keylist}</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shells</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shuffle</td>\n<td>random.shuffle</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>size</td>\n<td>len</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip</td>\n<td>list[x:]</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_while</td>\n<td>itertools.dropwhile</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sort-by</td>\n<td>sorted, list.sort</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_by</td>\n<td>re.split</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_column</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_row</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>str(<code>*</code>)</td>\n<td>str functions</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sum</td>\n<td>sum</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sys(<code>*</code>)</td>\n<td>sys</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>table</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tags</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>textview(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>tree(<code>*</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to bson</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to csv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to html</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to json</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to md</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to sqlite</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to toml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to tsv</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to url</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>to yaml</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>touch</td>\n<td>open(path, 'a').close()</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>trim</td>\n<td>strip, rstrip, lstrip</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>uniq</td>\n<td>set</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>update(<code>**</code>)</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>version</td>\n<td>sys.version, sys.version_info</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>with_env</td>\n<td>os.environ</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>what</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>where</td>\n<td>filter</td>\n<td>filter</td>\n<td>filter</td>\n<td>filter</td>\n</tr>\n<tr>\n<td>which</td>\n<td>shutil.which</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>wrap</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>*</code> - Pertenecen de los plugins standard</li>\n<li><code>**</code> - renombrada de <code>edit</code> a <code>update</code> en 0.13.1</li>\n<li><code>***</code> - renombrada de <code>pick</code> a <code>select</code> en 0.13.1</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.691Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa nushell de otras shells y lenguajes DSLs",
      "url": "www.nushell.sh/es/book/mapa_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_nushell.html",
      "content_html": "<h1 id=\"mapa-nushell-de-otras-shells-y-lenguajes-dsls\" tabindex=\"-1\"> Mapa nushell de otras shells y lenguajes DSLs</h1>\n<p>La idea detrás de esta tabla is ayudarte a entender como los comandos internos y plugins en Nu se relacionan con otras shells conocidas y lenguajes de dominio específicos. Hemos intentado producir un mapa de los comandos internos y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: Esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>SQL</th>\n<th>.Net LINQ (C#)</th>\n<th>PowerShell (without external modules)</th>\n<th>Bash</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>alias</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>alias</td>\n<td>alias</td>\n</tr>\n<tr>\n<td>append</td>\n<td>N/A</td>\n<td>Append()</td>\n<td>-Append</td>\n<td></td>\n</tr>\n<tr>\n<td>args</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>autoview</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>average(<code>*</code>)</td>\n<td>avg</td>\n<td>Average()</td>\n<td>Measure-Object, measure</td>\n<td></td>\n</tr>\n<tr>\n<td>binaryview(<code>*</code>)</td>\n<td>N/A</td>\n<td></td>\n<td>Format-Hex</td>\n<td></td>\n</tr>\n<tr>\n<td>calc, = math</td>\n<td>math operators</td>\n<td>Aggregate, Average, Count, Max, Min, Sum</td>\n<td></td>\n<td>bc</td>\n</tr>\n<tr>\n<td>cd</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Set-Location, cd</td>\n<td>cd</td>\n</tr>\n<tr>\n<td>clear</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Clear-Host</td>\n<td>clear</td>\n</tr>\n<tr>\n<td>clip</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Set-Clipboard, scb</td>\n<td>clip, clipboard, xclip, pbcopy</td>\n</tr>\n<tr>\n<td>compact</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>config</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>$Profile</td>\n<td>vi .bashrc, .profile</td>\n</tr>\n<tr>\n<td>count</td>\n<td>count</td>\n<td>Count</td>\n<td>Measure-Object, measure</td>\n<td>wc</td>\n</tr>\n<tr>\n<td>cp</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Copy-Item, cp, copy</td>\n<td>cp</td>\n</tr>\n<tr>\n<td>date</td>\n<td>NOW() / getdate()</td>\n<td>DateTime class</td>\n<td>Get-Date</td>\n<td>date</td>\n</tr>\n<tr>\n<td>debug</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>= dec</td>\n<td></td>\n<td>x--</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>default</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>drop</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>du</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td>du</td>\n</tr>\n<tr>\n<td>each</td>\n<td>cursor</td>\n<td></td>\n<td>ForEach-Object, foreach, for</td>\n<td></td>\n</tr>\n<tr>\n<td>echo</td>\n<td>print</td>\n<td>N/A</td>\n<td>Write-Output, write</td>\n<td>echo</td>\n</tr>\n<tr>\n<td>enter</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>evaluate_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>exit</td>\n<td>N/A</td>\n<td></td>\n<td>exit</td>\n<td>exit</td>\n</tr>\n<tr>\n<td>fetch(<code>*</code>)</td>\n<td>N/A</td>\n<td>HttpClient,WebClient, HttpWebRequest/Response</td>\n<td>Invoke-WebRequest</td>\n<td>wget</td>\n</tr>\n<tr>\n<td>first</td>\n<td>top, limit</td>\n<td>First, FirstOrDefault</td>\n<td>Select-Object -First</td>\n<td>head</td>\n</tr>\n<tr>\n<td>format</td>\n<td></td>\n<td>String.Format()</td>\n<td>String.Format()</td>\n<td></td>\n</tr>\n<tr>\n<td>from bson</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from csv</td>\n<td>import flatfile</td>\n<td>N/A</td>\n<td>Import-Csv, ConvertFrom-Csv</td>\n<td></td>\n</tr>\n<tr>\n<td>from eml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from ics</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from ini</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from json</td>\n<td>openjson</td>\n<td>N/A</td>\n<td>ConvertFrom-Json</td>\n<td></td>\n</tr>\n<tr>\n<td>from ods</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from sqlite</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from ssv</td>\n<td>import flatfile</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from toml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from tsv</td>\n<td>import flatfile</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from url</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from vcf</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from xlsx</td>\n<td>import</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>from xml</td>\n<td>cast(variable as xml)</td>\n<td>N/A</td>\n<td>ConvertFrom-Xml</td>\n<td></td>\n</tr>\n<tr>\n<td>from yaml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>get</td>\n<td></td>\n<td>Select</td>\n<td>(cmd).column</td>\n<td></td>\n</tr>\n<tr>\n<td>group_by</td>\n<td>group by</td>\n<td>GroupBy, group</td>\n<td>Group-Object, group</td>\n<td></td>\n</tr>\n<tr>\n<td>headers</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>help</td>\n<td>sp_help</td>\n<td>N/A</td>\n<td>Get-Help, help, man</td>\n<td>man</td>\n</tr>\n<tr>\n<td>histogram</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>history</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-History, history</td>\n<td>history</td>\n</tr>\n<tr>\n<td>inc(<code>*</code>)</td>\n<td>N/A</td>\n<td></td>\n<td>N/A</td>\n<td>N/A</td>\n</tr>\n<tr>\n<td>insert</td>\n<td></td>\n<td></td>\n<td>Add-Member</td>\n<td></td>\n</tr>\n<tr>\n<td>is_empty</td>\n<td>is null</td>\n<td>String.InNullOrEmpty()</td>\n<td>String.InNullOrEmpty()</td>\n<td></td>\n</tr>\n<tr>\n<td>keep</td>\n<td>top,limit</td>\n<td>Take</td>\n<td>Select-Object -First</td>\n<td>head</td>\n</tr>\n<tr>\n<td>keep_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>keep_while</td>\n<td></td>\n<td>TakeWhile</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>kill</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Stop-Process, kill</td>\n<td>kill</td>\n</tr>\n<tr>\n<td>last</td>\n<td></td>\n<td>Last, LastOrDefault</td>\n<td>Select-Object -Last</td>\n<td>tail</td>\n</tr>\n<tr>\n<td>lines</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>File.ReadAllLines()</td>\n<td></td>\n</tr>\n<tr>\n<td>ls</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-ChildItem, dir, ls</td>\n<td>ls</td>\n</tr>\n<tr>\n<td>map_max_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>match(<code>*</code>)</td>\n<td>case when</td>\n<td>RegEx</td>\n<td>[regex]</td>\n<td></td>\n</tr>\n<tr>\n<td>merge</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>mkdir</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>mkdir, md</td>\n<td>mkdir</td>\n</tr>\n<tr>\n<td>mv</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Move-Item, mv, move, mi</td>\n<td>mv</td>\n</tr>\n<tr>\n<td>next</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>nth</td>\n<td>limit x offset y, rownumber =</td>\n<td>ElemantAt(x)</td>\n<td>[x], indexing operator, ElementAt(x)</td>\n<td></td>\n</tr>\n<tr>\n<td>open</td>\n<td></td>\n<td></td>\n<td>Get-Content, gc, cat, type</td>\n<td>cat</td>\n</tr>\n<tr>\n<td>parse</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>pivot</td>\n<td>pivot</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>post(<code>*</code>)</td>\n<td>N/A</td>\n<td>HttpClient,WebClient, HttpWebRequest/Response</td>\n<td>Invoke-WebRequest</td>\n<td></td>\n</tr>\n<tr>\n<td>prepend</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>prev</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>ps(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-Process, ps, gps</td>\n<td>ps</td>\n</tr>\n<tr>\n<td>pwd</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-Location, pwd</td>\n<td>pwd</td>\n</tr>\n<tr>\n<td>range</td>\n<td></td>\n<td>Range</td>\n<td>1..10, 'a'..'f'</td>\n<td></td>\n</tr>\n<tr>\n<td>reduce_by</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>reject</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>rename</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Rename-Item, ren, rni</td>\n<td>mv</td>\n</tr>\n<tr>\n<td>reverse</td>\n<td></td>\n<td>Reverse</td>\n<td>[Array]::Reverse($var)</td>\n<td></td>\n</tr>\n<tr>\n<td>rm</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Remove-Item, del, erase, rd, ri, rm, rmdir</td>\n<td>rm</td>\n</tr>\n<tr>\n<td>save</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Write-Output, Out-File</td>\n<td>&gt; foo.txt</td>\n</tr>\n<tr>\n<td>select(<code>***</code>)</td>\n<td>select</td>\n<td>Select</td>\n<td>Select-Object, select</td>\n<td></td>\n</tr>\n<tr>\n<td>shells</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>shuffle</td>\n<td></td>\n<td>Random</td>\n<td>$var</td>\n<td>Sort-Object {Get-Random}</td>\n</tr>\n<tr>\n<td>size</td>\n<td></td>\n<td></td>\n<td>Measure-Object, measure</td>\n<td>wc</td>\n</tr>\n<tr>\n<td>skip</td>\n<td>where row_number()</td>\n<td>Skip</td>\n<td>Select-Object -Skip</td>\n<td></td>\n</tr>\n<tr>\n<td>skip_until</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>skip_while</td>\n<td></td>\n<td>SkipWhile</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>sort-by</td>\n<td>order by</td>\n<td>OrderBy, OrderByDescending, ThenBy, ThenByDescending</td>\n<td>Sort-Object, sort</td>\n<td></td>\n</tr>\n<tr>\n<td>split_by</td>\n<td></td>\n<td>String.Split()</td>\n<td>String.Split()</td>\n<td></td>\n</tr>\n<tr>\n<td>split_column</td>\n<td></td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>split_row</td>\n<td></td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>str(<code>*</code>)</td>\n<td>string functions</td>\n<td>String class</td>\n<td>String class</td>\n<td></td>\n</tr>\n<tr>\n<td>sum</td>\n<td>sum</td>\n<td>Sum()</td>\n<td>Measure-Object, measure</td>\n<td></td>\n</tr>\n<tr>\n<td>sys(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-ComputerInfo</td>\n<td>uname, lshw, lsblk, lscpu, lsusb, hdparam, free</td>\n</tr>\n<tr>\n<td>table</td>\n<td></td>\n<td></td>\n<td>Format-Table, ft, Format-List, fl</td>\n<td></td>\n</tr>\n<tr>\n<td>tags</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>textview(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Get-Content, cat</td>\n<td></td>\n</tr>\n<tr>\n<td>tree(<code>*</code>)</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>tree</td>\n<td></td>\n</tr>\n<tr>\n<td>to bson</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to csv</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Export-Csv, ConvertTo-Csv</td>\n<td></td>\n</tr>\n<tr>\n<td>to html</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>ConvertTo-Html</td>\n<td></td>\n</tr>\n<tr>\n<td>to json</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>ConvertTo-Json</td>\n<td></td>\n</tr>\n<tr>\n<td>to md</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to sqlite</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to toml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to tsv</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to url</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>to yaml</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td></td>\n</tr>\n<tr>\n<td>touch</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>Set-Content</td>\n<td>touch</td>\n</tr>\n<tr>\n<td>trim</td>\n<td>rtrim, ltrim</td>\n<td>String.Trim()</td>\n<td>String.Trim()</td>\n<td></td>\n</tr>\n<tr>\n<td>uniq</td>\n<td>distinct</td>\n<td>Distinct</td>\n<td>Get-Unique, gu</td>\n<td>uniq</td>\n</tr>\n<tr>\n<td>update(<code>**</code>)</td>\n<td>As</td>\n<td>N/A</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>version</td>\n<td>select @@version</td>\n<td>N/A</td>\n<td>$PSVersionTable</td>\n<td></td>\n</tr>\n<tr>\n<td>with_env</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>$env:FOO = 'bar'</td>\n<td>export foo = &quot;bar&quot;</td>\n</tr>\n<tr>\n<td>what</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>where</td>\n<td>where</td>\n<td>Where</td>\n<td>Where-Object, where, &quot;?&quot; operator</td>\n<td></td>\n</tr>\n<tr>\n<td>which</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>N/A</td>\n<td>which</td>\n</tr>\n<tr>\n<td>wrap</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><code>*</code> - Pertenecen de los plugins standard</li>\n<li><code>**</code> - renombrada de <code>edit</code> a <code>update</code> en 0.13.1</li>\n<li><code>***</code> - renombrada de <code>pick</code> a <code>select</code> en 0.13.1</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Mapa de operadores en Nushell",
      "url": "www.nushell.sh/es/book/mapa_operador_nushell.html",
      "id": "www.nushell.sh/es/book/mapa_operador_nushell.html",
      "content_html": "<h1 id=\"mapa-de-operadores-en-nushell\" tabindex=\"-1\"> Mapa de operadores en Nushell</h1>\n<p>La idea detrás de esta tabla is ayudarte a entender como los operadores en Nu se relacionan con operadores de otros lenguajes. Hemos intentado producir un mapa de los operadores y sus equivalentes en otros lenguajes. Contribuciones son bienvenidas.</p>\n<p>Nota: esta tabla asume Nu 0.14.1 o posterior.</p>\n<table>\n<thead>\n<tr>\n<th>Nushell</th>\n<th>SQL</th>\n<th>Python</th>\n<th>.Net LINQ (C#)</th>\n<th>PowerShell</th>\n<th>Bash</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>=</td>\n<td>==</td>\n<td>==</td>\n<td>-eq, -is</td>\n<td>-eq</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>!=, &lt;&gt;</td>\n<td>!=</td>\n<td>!=</td>\n<td>-ne, -isnot</td>\n<td>-ne</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>&lt;</td>\n<td>&lt;</td>\n<td>&lt;</td>\n<td>-lt</td>\n<td>-lt</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>&lt;=</td>\n<td>&lt;=</td>\n<td>&lt;=</td>\n<td>-le</td>\n<td>-le</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>&gt;</td>\n<td>&gt;</td>\n<td>&gt;</td>\n<td>-gt</td>\n<td>-gt</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>&gt;=</td>\n<td>&gt;=</td>\n<td>&gt;=</td>\n<td>-ge</td>\n<td>-ge</td>\n</tr>\n<tr>\n<td>=~</td>\n<td>like</td>\n<td>re, in, startswith</td>\n<td>Contains, StartsWith</td>\n<td>-like, -contains</td>\n<td>=~</td>\n</tr>\n<tr>\n<td>!~</td>\n<td>not like</td>\n<td>not in</td>\n<td>Except</td>\n<td>-notlike, -notcontains</td>\n<td>! &quot;str1&quot; =~ &quot;str2&quot;</td>\n</tr>\n<tr>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n<td>+</td>\n</tr>\n<tr>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n<td>*</td>\n</tr>\n<tr>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n<td>/</td>\n</tr>\n<tr>\n<td>in</td>\n<td>in</td>\n<td>re, in, startswith</td>\n<td>Contains, StartsWith</td>\n<td>-In</td>\n<td>case in</td>\n</tr>\n<tr>\n<td>not-in</td>\n<td>not in</td>\n<td>not in</td>\n<td>Except</td>\n<td>-NotIn</td>\n<td></td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>and</td>\n<td>and</td>\n<td>&amp;&amp;</td>\n<td>-And</td>\n<td>-a, &amp;&amp;</td>\n</tr>\n<tr>\n<td>||</td>\n<td>or</td>\n<td>or</td>\n<td>||</td>\n<td>-Or</td>\n<td>-o, ||</td>\n</tr>\n</tbody>\n</table>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Matemáticas",
      "url": "www.nushell.sh/es/book/matematicas.html",
      "id": "www.nushell.sh/es/book/matematicas.html",
      "content_html": "<h1 id=\"matematicas\" tabindex=\"-1\"> Matemáticas</h1>\n<p>Hay veces que simplemente necesitas sumar un par de números cuando te encuentras resolviendo problemas. Nu ofrece un conjunto de operaciones matemáticas básicas que puedes utilizar. Expresiones matemáticas se encuentran disponibles cuando llamas a un comando.</p>\n<h2 id=\"sumar-restar-mupltiplicar-dividir\" tabindex=\"-1\"> Sumar, Restar, Mupltiplicar, Dividir</h2>\n<div><pre><code>> 1 + 3\n4\n</code></pre></div><p>En Nu puedes realizar lo usual: sumar, restar, mutiplicar y dividir con los operadores <code>+</code>, <code>-</code>, <code>*</code>, y <code>/</code> respectivamente. Precedencia de operadores es respetada, por lo que <code>1 + 2 * 3</code> será tratado como <code>1 + (2 * 3)</code>. Lo que nos lleva a paréntesis.</p>\n<h2 id=\"parentesis\" tabindex=\"-1\"> Paréntesis</h2>\n<p>Puedes usar paréntesis para agrupar expresiones matemáticas en modo <code>math</code>. Esto te permite escribir <code>(1 + 2) * 3</code> si deseas que adición tenga mayor precedencia.</p>\n<h2 id=\"in-y-not-in\" tabindex=\"-1\"> <code>in</code> y <code>not-in</code></h2>\n<p>Puedes revisar si un valor se encuentra dentro de un conjunto de valores o no, usando los operadores <code>in</code> y <code>not-in</code>.</p>\n<div><pre><code>> 1 in [1 2 3]\ntrue\n</code></pre></div><div><pre><code>> 1 not-in [1 2 3]\nfalse\n</code></pre></div><h2 id=\"y\" tabindex=\"-1\"> =~ y !~</h2>\n<p>Puedes revisar si una cadena se encuentra dentro de otra cadena o no, usando <code>=~</code> y <code>!~</code>.</p>\n<div><pre><code>> \"gallinagallo\" =~ \"gallo\"\ntrue\n</code></pre></div><div><pre><code>> \"gallinagallo\" !~ \"pollito\"\ntrue\n</code></pre></div><h2 id=\"comparaciones\" tabindex=\"-1\"> Comparaciones</h2>\n<p>Los siguientes comparadores también se encuentran disponibles:</p>\n<ul>\n<li><code>&lt;</code> - menor que</li>\n<li><code>&lt;=</code> - menor o igual que</li>\n<li><code>&gt;</code> - mayor que</li>\n<li><code>&gt;=</code> - mayor o igual que</li>\n<li><code>==</code> - igual a</li>\n<li><code>!=</code> - no es igual a</li>\n</ul>\n<h2 id=\"operadores-compuestos\" tabindex=\"-1\"> Operadores Compuestos</h2>\n<p>Nushell también soporta <code>&amp;&amp;</code> y <code>||</code> para unir dos operaciones que regresen valores booleanos, usando <code>y</code> y <code>o</code> respectivamente. Por ejemplo: <code>ls | where name in [&quot;uno&quot; &quot;dos&quot; &quot;tres&quot;] &amp;&amp; size &gt; 10kb</code></p>\n<h2 id=\"orden-de-operaciones\" tabindex=\"-1\"> Orden de operaciones</h2>\n<p>Las operaciones matemáticas son evaluadas de la siguiente manera (de mayor precedencia a menor):</p>\n<ul>\n<li>Parentesis (<code>()</code>)</li>\n<li>Multiplicación (<code>*</code>) y División (<code>/</code>)</li>\n<li>Suma (<code>+</code>) y Resta (<code>-</code>)</li>\n</ul>\n<div><pre><code>> 3 * (1 + 2)\n9\n</code></pre></div><h2 id=\"modo-matematico-abreviado\" tabindex=\"-1\"> Modo matemático abreviado</h2>\n<p>Hay una variación abreviada &quot;short-hand&quot; en modo matemático incluída en Nushell. La razón se debe a que permite una forma de acceder columnas de manera más simple.</p>\n<p>Es probable que ya la usaste antes. Por ejemplo, supongamos que deseamos ver filas de <code>ls</code> donde para cada uno por lo menos tenga 10 kilobytes, podemos escribir:</p>\n<div><pre><code>> ls | where size > 10kb\n</code></pre></div><p>El comando <code>where memoria &gt; 10kb</code> tiene dos partes: El nombre del comando <code>where</code> y su abreviación expresión matemática <code>size &gt; 10kb</code>. Indicamos <code>abreviada</code> debido a que <code>size</code> es una versión acortada de escribir <code>$it.size</code>. Si observamos su forma completamente expandida, veríamos:</p>\n<div><pre><code>> ls | where {|$it| $it.size > 10kb }\n</code></pre></div><p>Usamos el modo abreviado para trabajar con datos de columnas para no tener que repetir la forma expandida siempre.</p>\n<p>Para el funcionamiento apropiado de la abreviación acortada y por lo tanto su expansión, el nombre de la columna tiene que aparecer en el lado izquierdo de la operación. Arriba, <code>size</code> aparece en en lado izquierdo de la comparación que permite la expresión expanderse al modo completo matemático del bloque.</p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Metadatos",
      "url": "www.nushell.sh/es/book/metadatos.html",
      "id": "www.nushell.sh/es/book/metadatos.html",
      "content_html": "<h1 id=\"metadatos\" tabindex=\"-1\"> Metadatos</h1>\n<p>Al usar Nu es posible que hayan momentos que has encontrado como si algo extra sucediera detrás de escenas. Por ejemplo digamos que intentas abrir un archivo soportado por Nu para luego olvidarte e intentar convertir nuevamente:</p>\n<div><pre><code>> open Cargo.toml | from toml\nerror: Expected a string from pipeline\n- shell:1:18\n1 | open Cargo.toml | from toml\n  |                   ^^^^^^^^^ requires string input\n- shell:1:5\n1 | open Cargo.toml | from toml\n  |      ---------- object originates from here\n</code></pre></div><p>El mensaje de error nos indica que hemos proporcionado a <code>from toml</code> algo distinto a una cadena pero también el origen del valor. ¿Cómo puede saberlo?</p>\n<p>Valores que fluyen a través de la tubería en Nu comúnmente disponen de información adicional (o metadatos) adjuntadas en las mismas. Se conocen como etiquetas como las etiquetas en una tienda. Estas etiquetas no afecta los datos pero permiten a Nu mejorar la experiencia mientras se trabaja con esos datos.</p>\n<p>Nuevamente ejecutemos el comando <code>open</code> pero esta vez observaremos las etiquetas que nos devuelve:</p>\n<div><pre><code>> open Cargo.toml | tags\n----------+------------------------------------------\n span     | anchor\n----------+------------------------------------------\n [object] | /home/jonathan/Source/nushell/Cargo.toml\n----------+------------------------------------------\n</code></pre></div><p>Actualmente rastreamos dos pedazos de metadatos de los valores en la tubería. Puedes darte cuenta que disponemos del ancla que nos da la ubicación de dónde se cargaron los datos. Esto puede ayudar a Nu entender mejor como presentar datos.</p>\n<p>También hay lapso (span). Miremos más de cerca a eso:</p>\n<div><pre><code>> open Cargo.toml | tags | get span\n-------+-----\n start | end\n-------+-----\n 5     | 15\n-------+-----\n</code></pre></div><p>El lapso &quot;start&quot; y &quot;end&quot; aquí se refiere en dónde estará el subrayado en la línea. Si cuentas a partir de 5 y luego hasta 15 podrás observar que se alinea con el nombre de archivo &quot;Cargo.toml&quot;. Así es como Nu sabía qué subrayar apropiadamente en el error que vimos previamente.</p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "El pipeline",
      "url": "www.nushell.sh/es/book/pipeline.html",
      "id": "www.nushell.sh/es/book/pipeline.html",
      "content_html": "<h1 id=\"el-pipeline\" tabindex=\"-1\"> El pipeline</h1>\n<p>Uno de los diseños centrales de Nu es la tubería (pipeline), una idea de diseño que rastrea sus raíces décadas atrás hasta parte de la filosofía original detrás de Unix. Así como Nu extiende desde un solo dato tipo de cadena de Unix, Nu también extiende la idea de tuberías (pipelines) para incluir más que solo texto.</p>\n<h2 id=\"fundamentos\" tabindex=\"-1\"> Fundamentos</h2>\n<p>Una tubería (pipeline) es construída con tres partes: la entrada, el filtro, y la salida.</p>\n<div><pre><code>> open \"Cargo.toml\" | inc package.version | save \"Cargo_new.toml\"\n</code></pre></div><p>El primer comando, <code>open &quot;Cargo.toml&quot;</code>, es una entrada (a veces también llamada &quot;fuente&quot; o &quot;productor&quot;). Esto crea o carga datos y lo canaliza en la tubería. Es de entrada para la tubería tener valores y poder trabajarlas. Comandos como <code>ls</code> también son entradas ya que toman datos desde el sistema de archivos y lo canalizan a través de las tuberías para que puedan ser usadas.</p>\n<p>El segundo comando, <code>inc package.version</code>, es un filtro. Filtros toman los datos que se les entrega y comúnmente hacen algo con la misma. Puede que la cambien (tal como el comando <code>inc</code> en nuestro ejemplo), o pueden hacer otra operación, como registrar, mientras pasan los valores.</p>\n<p>El último comando, <code>save &quot;Cargo_new.toml&quot;</code>, es una salida (a veces llamado un &quot;sink&quot;). Una salida toma la entrada de la tubería y realiza alguna operación final. En nuestro ejemplo, grabamos lo que viene a través de la tubería hacia un archivo como paso final. Otros tipos de comandos de salida pueda que tomen valores y lo muestren para el usuario.</p>\n<h2 id=\"trabajando-con-comandos-externos\" tabindex=\"-1\"> Trabajando con comandos externos</h2>\n<p>Los comandos en Nu se comunican entre ellos usando los tipos de datos de Nu (mirar <a href=\"/es/book/tipos_de_datos.html\">tipos de datos</a>) pero, ¿qué hay de comandos fuera de Nu? Miremos algunos ejemplos trabajando con comandos externos:</p>\n<p><code>commando_interno | comando_externo</code></p>\n<p>Los datos fluirán desde comando_interno al comando_externo. Estos datos se esperan que sean cadenas para que puedan ser enviadas a entrada estándar <code>stdin</code> del comando_externo.</p>\n<p><code>comando_externo | comando_interno</code></p>\n<p>Los datos que vienen de un comando externo a Nu se coleccionará a una sola cadena y luego serán pasadas a comando_interno. Comandos como <code>lines</code> ayudan a facilitar datos provenientes de comandos externos de manera que sea más facil trabajarlas.</p>\n<p><code>comando_externo_1 | comando_externo_2</code></p>\n<p>Nu trabaja con datos canalizados entre dos comandos externos de la misma forma como en otras shells, como Bash lo haría. La salida estándar <code>stdout</code> de comando_externo_1 es conectada a la entrada estándar <code>stdin</code> de comando_externo_2. Esto permite que los datos fluyan naturalmente entre dos comandos.</p>\n<h2 id=\"detras-de-escenas\" tabindex=\"-1\"> Detrás de escenas</h2>\n<p>Es posible que te hayas preguntado como miramos una tabla si <code>ls</code> es una entrada y no una salida. Nu agrega esta salida por nosotros automáticamente usando otro comando llamado <code>autoview</code>. El comando <code>autoview</code> es añadido a cualquier tubería que no tenga una salida permitiéndonos ver el resultado.</p>\n<p>En efecto, el comando:</p>\n<div><pre><code>> ls\n</code></pre></div><p>y la tubería:</p>\n<div><pre><code>> ls | autoview\n</code></pre></div><p>Son uno y lo mismo.</p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Complementos (plugins)",
      "url": "www.nushell.sh/es/book/plugins.html",
      "id": "www.nushell.sh/es/book/plugins.html",
      "content_html": "<h1 id=\"complementos-plugins\" tabindex=\"-1\"> Complementos (plugins)</h1>\n<p>Se puede ampliar la funcionalidad de Nu a través de complementos. Los complementos pueden realizar muchas de las mismas operaciones que los comandos integrados de Nu con el beneficio adicional de que se pueden agregar separado de Nu.</p>\n<p>Para agregar un complemento simplemente compílalo y colóca el binario en el PATH. Los complementos de Nu empiezan con <code>nu_plugin_</code> de manera que Nu pueda encontrarlos entre otros binarios en su PATH.</p>\n<p><strong>Nota:</strong> en el futuro los complementos pueden que tengan un lugar específico que deban ser puestos para Nu encontrarlos.</p>\n<p>Cuándo Nu arranca escanea el sistema y carga los complementos que encuentre.</p>\n<p>El protocolo que usan los complementos de Nu está sujetos a cambios mientras Nu está bajo fuerte desarrollo. El mejor lugar para aprender más sobre el protocolo y cómo crear tus propios complementos es leyendo el código fuente de los <a href=\"https://github.com/nushell/nushell/tree/master/crates\" target=\"_blank\" rel=\"noopener noreferrer\">complementos en el repositorio de Nu</a>. También puedes dirigirte al <a href=\"https://github.com/nushell/contributor-book/blob/master/en/plugins.md\" target=\"_blank\" rel=\"noopener noreferrer\">capítulo de plugins en el manual para contribuyentes de Nu</a></p>\n",
      "date_modified": "2022-06-02T15:48:22.692Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Shells en shells",
      "url": "www.nushell.sh/es/book/shells_en_shells.html",
      "id": "www.nushell.sh/es/book/shells_en_shells.html",
      "content_html": "<h1 id=\"shells-en-shells\" tabindex=\"-1\"> Shells en shells</h1>\n<h2 id=\"trabajando-con-multiples-directorios\" tabindex=\"-1\"> Trabajando con múltiples directorios</h2>\n<p>Mientras es común trabajar en un directorio puede ser beneficioso trabajar en múltiples lugares al mismo tiempo. Para esto Nu ofrece el concepto de &quot;shells&quot;. Tal como implica, son una manera de tener activo múltiples shells en uno permitiendote rápidamente saltar entre directorios de trabajo y más.</p>\n<p>Para empezar entremos a un directorio:</p>\n<div><pre><code>/home/jonathan/Source/nushell(master)> enter ../lark\n/home/jonathan/Source/lark(master)> ls\n----+----------------+-----------+----------+---------+---------------+---------------\n #  | name           | type      | readonly | size    | accessed      | modified\n----+----------------+-----------+----------+---------+---------------+---------------\n 0  | Cargo.toml     | File      |          | 2.2 KB  | 6 months ago  | 6 months ago\n 1  | target         | Directory |          | 4.1 KB  | 10 months ago | 6 months ago\n 2  | notes          | Directory |          | 4.1 KB  | 10 months ago | 6 months ago\n</code></pre></div><p>Entrar es similar a cambiar directorios (como vimos previamente con el comando <code>cd</code>). Esto permite saltar al directorio para trabajar dentro del mismo. En lugar de cambiar de directorio, ahora estamos en dos directorios. Para ver esto con más claridad podemos usar el comando <code>shells</code> que enumera los directorios actualmente activos:</p>\n<div><pre><code>/home/jonathan/Source/lark(master)> shells\n---+---+------------+-------------------------------\n # |   | name       | path\n---+---+------------+-------------------------------\n 0 |   | filesystem | /home/jonathan/Source/nushell\n 1 | X | filesystem | /home/jonathan/Source/lark\n---+---+------------+-------------------------------\n</code></pre></div><p>El comando <code>shells</code> nos muestra que hay dos shells activos: nuestro directorio fuente original &quot;nushell&quot; y ahora este nuevo directorio &quot;lark&quot;.</p>\n<p>Podemos saltar entre estas shells con los accesos directos <code>n</code> y <code>p</code>, cortos de siguiente &quot;next&quot; y previo &quot;previous&quot;:</p>\n<div><pre><code>/home/jonathan/Source/lark(master)> n\n/home/jonathan/Source/nushell(master)> p\n/home/jonathan/Source/lark(master)>\n</code></pre></div><p>Podemos notar el directorio cambiando pero también siempre podremos regresar al directorio previo en el cual estábamos trabajando. Esto nos permite trabajar en múltiples directorio en la misma sesión.</p>\n<h2 id=\"saliendo-del-shell\" tabindex=\"-1\"> Saliendo del shell</h2>\n<p>Puedes salir de una shell que hayas entrado (usando <code>enter</code>) a través del comando <code>exit</code>. Si esta es la última shell, Nu se cerrará.</p>\n<p>Siempre puedes cerrar Nu incluso si tienes múltiples shells activas usando el comando <code>exit</code> pasando la bandera <code>--now</code> de la siguiente forma <code>exit --now</code></p>\n<h2 id=\"mas-alla-de-los-directorios\" tabindex=\"-1\"> Más allá de los directorios</h2>\n<p>Nu también puede crear shells de otras cosas aparte de las rutas del sistema de archivos. Digamos por ejemplo que estás trabajando con un gran conjunto de datos y no deseas perderte dentro del mismo.</p>\n<p>Para ver cómo funciona haremos el siguiente ejercicio. Actualmente en Nu tenemos enumerados los <a href=\"/es/book/plugins.html\">complementos</a> desarrollados (plugins) en &quot;Cargo.toml&quot; digamos que también acabamos de crear un nuevo complemento en el directorio src/plugins llamado &quot;doc.rs&quot; y nos interesa saber que se encuentre enumerado también en &quot;Cargo.toml&quot; para que se instale al compilar Nu.</p>\n<p>Entraremos al archivo &quot;Cargo.toml&quot; del código fuente de Nu:</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell(master)> enter Cargo.toml\n/> ls\n------------+--------------+------------------+----------+----------\n bin        | dependencies | dev-dependencies | lib      | package\n------------+--------------+------------------+----------+----------\n [11 items] | [object]     | [object]         | [object] | [object]\n------------+--------------+------------------+----------+----------\n</code></pre></div><p>Por el momento solo hemos entrado al archivo y podemos observar en la tabla devuelta por <code>ls</code> lo que hay. Si prestas atención hemos entrado a un archivo con formato que reconoce Nu (.toml). Nu también nos proyecta el contenido del archivo en forma de sistema de archivos para explorarlo como si estuvieramos dentro de un sistema de archivos.</p>\n<p>Antes de continuar revisemos las shells activas:</p>\n<div><pre><code>/> shells\n---+---+-------------------------------------------------+------------------------------------\n # |   | name                                            | path\n---+---+-------------------------------------------------+------------------------------------\n 0 |   | filesystem                                      | /Users/andresrobalino/Code/nushell\n 1 | X | {/Users/andresrobalino/Code/nushell/Cargo.toml} | /\n---+---+-------------------------------------------------+------------------------------------\n\n</code></pre></div><p>Observamos que hay dos activas indicándonos que nos encontramos dentro de &quot;Cargo.toml&quot; en la ruta predeterminada &quot;/&quot;. Revisemos el listado de nuevo:</p>\n<div><pre><code>/> ls\n------------+--------------+------------------+----------+----------\n bin        | dependencies | dev-dependencies | lib      | package\n------------+--------------+------------------+----------+----------\n [11 items] | [object]     | [object]         | [object] | [object]\n------------+--------------+------------------+----------+----------\n</code></pre></div><p>Puede que los complementos se encuentren en &quot;bin&quot;, vamos ahí:</p>\n<div><pre><code>> cd bin\n/bin> ls\n----+----------------------+---------------------------\n #  | name                 | path\n----+----------------------+---------------------------\n 0  | nu_plugin_inc        | src/plugins/inc.rs\n 1  | nu_plugin_sum        | src/plugins/sum.rs\n 2  | nu_plugin_add        | src/plugins/add.rs\n 3  | nu_plugin_edit       | src/plugins/edit.rs\n 4  | nu_plugin_str        | src/plugins/str.rs\n 5  | nu_plugin_skip       | src/plugins/skip.rs\n 6  | nu_plugin_sys        | src/plugins/sys.rs\n 7  | nu_plugin_tree       | src/plugins/tree.rs\n 8  | nu_plugin_binaryview | src/plugins/binaryview.rs\n 9  | nu_plugin_textview   | src/plugins/textview.rs\n 10 | nu                   | src/main.rs\n----+----------------------+---------------------------\n</code></pre></div><p>Notar que siempre podemos saltar de vuelta al directorio en el que estuvimos trabajando usando <code>p</code> (para previo).</p>\n<div><pre><code>/bin> p\n</code></pre></div><p>Verifiquemos las shells:</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell(master)> shells\n---+---+-------------------------------------------------+------------------------------------\n # |   | name                                            | path\n---+---+-------------------------------------------------+------------------------------------\n 0 | X | filesystem                                      | /Users/andresrobalino/Code/nushell\n 1 |   | {/Users/andresrobalino/Code/nushell/Cargo.toml} | /bin\n---+---+-------------------------------------------------+------------------------------------\n\n</code></pre></div><p>Nos encontramos ahora en la shell donde estuvimos antes de entrar al archivo &quot;Cargo.toml&quot;, vamos al directorio donde se encuentra el código fuente de los complementos (plugins):</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell(master)> cd src/plugins/\n/Users/andresrobalino/Code/nushell/src/plugins(master)> ls\n----+---------------+------+----------+---------+------------+------------\n #  | name          | type | readonly | size    | accessed   | modified\n----+---------------+------+----------+---------+------------+------------\n 0  | doc.rs        | File |          | 3.0 KB  | a week ago | a week ago\n 1  | sum.rs        | File |          | 3.0 KB  | a week ago | a week ago\n 2  | inc.rs        | File |          | 11.8 KB | a week ago | a week ago\n 3  | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n 4  | edit.rs       | File |          | 2.7 KB  | a week ago | a week ago\n 5  | str.rs        | File |          | 21.4 KB | 5 days ago | 5 days ago\n 6  | secret.rs     | File |          | 1.8 KB  | 2 days ago | 2 days ago\n 7  | skip.rs       | File |          | 1.7 KB  | a week ago | a week ago\n 8  | binaryview.rs | File |          | 13.0 KB | a week ago | a week ago\n 9  | tree.rs       | File |          | 3.0 KB  | a week ago | a week ago\n 10 | add.rs        | File |          | 2.7 KB  | a week ago | a week ago\n 11 | textview.rs   | File |          | 9.4 KB  | 5 days ago | 5 days ago\n----+---------------+------+----------+---------+------------+------------\n</code></pre></div><p>Ahora podemos comparar los dos para verificar si faltan complementos adicionales o si hay complementos adicionales que necesitemos agregar a nuestro archivo &quot;Cargo.toml&quot; (¡y claramente falta agregarlo a &quot;Cargo.toml&quot;!)</p>\n",
      "date_modified": "2022-06-02T15:48:22.693Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Tipos de datos",
      "url": "www.nushell.sh/es/book/tipos_de_datos.html",
      "id": "www.nushell.sh/es/book/tipos_de_datos.html",
      "content_html": "<h1 id=\"tipos-de-datos\" tabindex=\"-1\"> Tipos de datos</h1>\n<p>Tradicionalmente, comandos shell de Unix se han comunidado entre ellos usando cadenas de texto. Un comando generaría de salida texto a través de la salida estándar (comúnmente abreviada 'stdout') y el otro leer texto a través de la entrada estándar (o 'stdin').</p>\n<p>Podemos pensar de este tipo de comunicación como basada en cadenas.</p>\n<p>Nu adopta este enfoque para sus comandos y lo hacer crecer para incluir otro tipos de datos. Actualmente, Nu incluye soporte para dos tipos de datos: simple y estructurada.</p>\n<h2 id=\"datos-simples\" tabindex=\"-1\"> Datos simples</h2>\n<p>Al igual que muchos lenguajes de programación, Nu modela los datos usando un conjunto de tipos de datos simples y estructurados. Tipos de dato simple incluye enteros, decimales, cadenas, booleanos, fechas, y rutas. También incluye un tipo especial para tamaños de archivos.</p>\n<h3 id=\"enteros\" tabindex=\"-1\"> Enteros</h3>\n<p>Enteros (o redondos). Ejemplos incluye 1, 5, y 100.</p>\n<h3 id=\"decimales\" tabindex=\"-1\"> Decimales</h3>\n<p>Números decimales son números con algún component fraccional. Ejemplos incluye 1.5, 2.0, y 15.333.</p>\n<h3 id=\"cadenas\" tabindex=\"-1\"> Cadenas</h3>\n<p>Las cadenas son la manera fundamental de representar texto. Se indican con doble comillas. Ejemplos incluye &quot;Pedro&quot;, &quot;minombre.txt&quot;, and &quot;Lynchburg, VA&quot;.</p>\n<p>Cadenas en Nu son compatibles con Unicode de manera predeterminada, por lo que puedes pasar texto UTF-8 con facilidad.</p>\n<h3 id=\"booleanos\" tabindex=\"-1\"> Booleanos</h3>\n<p>Booleanos son el estado de verdadero o falso. En vez de escribir el valor directamente, comúnmente es el resultado de una comparación.</p>\n<h3 id=\"fechas\" tabindex=\"-1\"> Fechas</h3>\n<p>Fechas y horas se mantienen juntas en el valor tipo de dato Date. Valores Date usados por el sistema reconocen la zona horaria y de manera predeterminada usa la zona horaria UTC.</p>\n<h3 id=\"rutas\" tabindex=\"-1\"> Rutas</h3>\n<p>Las rutas son una forma independiente de la plataforma para representar rutas de archivos en el sistema operativo dado. Ejemplos incluyen: /usr/bin y C:\\Users\\archivo.txt.</p>\n<h3 id=\"bytes\" tabindex=\"-1\"> Bytes</h3>\n<p>Tamaños de archivos se mantienen dentro de un tipo especial de entero llamado bytes. Ejemplos incluye 100, 15kb, y 100mb.</p>\n<h2 id=\"datos-estructurados\" tabindex=\"-1\"> Datos estructurados</h2>\n<p>Los datos estructurados se construyen a partir de los datos simples. Por ejemplo, en lugar de un solo entero, datos estructurados nos ofrece una manera de representar múltiples enteros en el mismo valor. Esta es una lista actual de los tipos de dato estructurados soportadas: objetos, datos binarios, listas, y bloques.</p>\n<h3 id=\"objetos\" tabindex=\"-1\"> Objetos</h3>\n<p>El tipo de dato object representa lo que observarías en una fila de datos de una tabla. Tiene diferentes elementos de datos y cada elemento de dato se le asigna un nombre de columna.</p>\n<h3 id=\"datos-binarios\" tabindex=\"-1\"> Datos binarios</h3>\n<p>Datos binarios como los datos de un archivo de imagen, es un grupo de bytes sin formato.</p>\n<h3 id=\"listas\" tabindex=\"-1\"> Listas</h3>\n<p>Las listas pueden tener más de un valor. Esto les permite ser un buen contenedor de filas de datos de una tabla.</p>\n<h3 id=\"bloques\" tabindex=\"-1\"> Bloques</h3>\n<p>Bloques representan bloques de código en Nu. Por ejemplo, en el comando <code>where { $it.size &gt; 10kb }</code> el bloque es la porción contenida en las llaves, <code>{ $it.size &gt; 10kb }</code>. Los bloques son una manera útil de representar código que puede ser ejecutado para cada fila de datos.</p>\n",
      "date_modified": "2022-06-02T15:48:22.693Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Trabajando con tablas",
      "url": "www.nushell.sh/es/book/trabajando_con_tablas.html",
      "id": "www.nushell.sh/es/book/trabajando_con_tablas.html",
      "content_html": "<h1 id=\"trabajando-con-tablas\" tabindex=\"-1\"> Trabajando con tablas</h1>\n<p>Una de las maneras comunes de mirar datos en Nu es a través de una tabla. Nu viene con una serie de comandos que trabajan con tablas para que pueda ser más conveniente encontrar lo que estás buscando y para limitar los datos a solo lo que necesites.</p>\n<p>Para empezar, consigamos una tabla que podamos usar:</p>\n<div><pre><code>> ls\n---+---------------+------+----------+---------+------------+------------\n # | name          | type | readonly | size    | accessed   | modified\n---+---------------+------+----------+---------+------------+------------\n 0 | add.rs        | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 1 | sum.rs        | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 2 | inc.rs        | File |          | 11.8 KB | 2 days ago | 2 days ago\n 3 | str.rs        | File |          | 21.4 KB | 2 days ago | 2 days ago\n 4 | skip.rs       | File |          | 1.7 KB  | 2 days ago | 2 days ago\n 5 | textview.rs   | File |          | 9.4 KB  | 2 days ago | 2 days ago\n 6 | binaryview.rs | File |          | 13.0 KB | a day ago  | a day ago\n 7 | edit.rs       | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 8 | tree.rs       | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 9 | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n---+---------------+------+----------+---------+------------+------------\n</code></pre></div><h2 id=\"ordenando-los-datos\" tabindex=\"-1\"> Ordenando los datos</h2>\n<p>Podemos ordenar la tabla llamando el comando <code>sort-by</code> e indicándole qué columnas queremos usar al ordenar. Digamos que deseamos ordenar nuestra tabla por tamaño de archivo:</p>\n<div><pre><code>> ls | sort-by size\n---+---------------+------+----------+---------+------------+------------\n # | name          | type | readonly | size    | accessed   | modified\n---+---------------+------+----------+---------+------------+------------\n 0 | skip.rs       | File |          | 1.7 KB  | 2 days ago | 2 days ago\n 1 | add.rs        | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 2 | edit.rs       | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 3 | sum.rs        | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 4 | tree.rs       | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 5 | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n 6 | textview.rs   | File |          | 9.4 KB  | 2 days ago | 2 days ago\n 7 | inc.rs        | File |          | 11.8 KB | 2 days ago | 2 days ago\n 8 | binaryview.rs | File |          | 13.0 KB | a day ago  | a day ago\n 9 | str.rs        | File |          | 21.4 KB | 2 days ago | 2 days ago\n---+---------------+------+----------+---------+------------+------------\n</code></pre></div><p>Podemos ordenar una tabla con cualquier columna que pueda ser comparada. Por ejemplo, también pudimos haber ordenador usando las columnas &quot;name&quot;, &quot;accessed&quot;, o &quot;modified&quot;.</p>\n<h1 id=\"seleccionando-los-datos-que-quieres\" tabindex=\"-1\"> Seleccionando los datos que quieres</h1>\n<p>Podemos seleccionar datos de una tabla seleccionando columnas o filas específicas. Escojamos algunas columnas de nuestra tabla para usar:</p>\n<div><pre><code>> ls | select name size\n---+---------------+---------\n # | name          | size\n---+---------------+---------\n 0 | add.rs        | 2.7 KB\n 1 | sum.rs        | 3.0 KB\n 2 | inc.rs        | 11.8 KB\n 3 | str.rs        | 21.4 KB\n 4 | skip.rs       | 1.7 KB\n 5 | textview.rs   | 9.4 KB\n 6 | binaryview.rs | 13.0 KB\n 7 | edit.rs       | 2.7 KB\n 8 | tree.rs       | 3.0 KB\n 9 | sys.rs        | 9.2 KB\n---+---------------+---------\n</code></pre></div><p>Esto ayuda a crear una table más enfocada para lo que necesitamos. Siguiente, digamos que queremos ver los 5 archivos más livianos de este directorio:</p>\n<div><pre><code>> ls | sort-by size | first 5\n---+---------+------+----------+--------+------------+------------\n # | name    | type | readonly | size   | accessed   | modified\n---+---------+------+----------+--------+------------+------------\n 0 | skip.rs | File |          | 1.7 KB | 2 days ago | 2 days ago\n 1 | add.rs  | File |          | 2.7 KB | 2 days ago | 2 days ago\n 2 | edit.rs | File |          | 2.7 KB | 2 days ago | 2 days ago\n 3 | sum.rs  | File |          | 3.0 KB | 2 days ago | 2 days ago\n 4 | tree.rs | File |          | 3.0 KB | 2 days ago | 2 days ago\n---+---------+------+----------+--------+------------+------------\n</code></pre></div><p>Notarás que primero ordenamos la tabla por tamaño para llegar hasta el archivo más pequeño y luego usamos <code>first 5</code> que nos devuelve las primeras 5 filas de la tabla.</p>\n<p>También puedes saltarte filas con <code>skip</code> que no deseas. Saltemos las primeras dos de las 5 filas que obtuvimos arriba:</p>\n<div><pre><code>> ls | sort-by size | first 5 | skip 2\n---+---------+------+----------+--------+------------+------------\n # | name    | type | readonly | size   | accessed   | modified\n---+---------+------+----------+--------+------------+------------\n 0 | edit.rs | File |          | 2.7 KB | 2 days ago | 2 days ago\n 1 | sum.rs  | File |          | 3.0 KB | 2 days ago | 2 days ago\n 2 | tree.rs | File |          | 3.0 KB | 2 days ago | 2 days ago\n---+---------+------+----------+--------+------------+------------\n</code></pre></div><p>Hemos reducido a tres filas que nos interesa.</p>\n<p>Veamos algunos otros comandos para seleccionar datos. Es posible que te hayas preguntado por qué las filas de la tabla son números. Esto actúa como una forma práctica de llegar a una sola fila. Ordenemos nuestra tabla por el nombre del archivo y luego escojamos una de las filas con el comando <code>n-th</code> usando el número de fila:</p>\n<div><pre><code>> ls | sort-by name\n---+---------------+------+----------+---------+------------+------------\n # | name          | type | readonly | size    | accessed   | modified\n---+---------------+------+----------+---------+------------+------------\n 0 | add.rs        | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 1 | binaryview.rs | File |          | 13.0 KB | a day ago  | a day ago\n 2 | edit.rs       | File |          | 2.7 KB  | 2 days ago | 2 days ago\n 3 | inc.rs        | File |          | 11.8 KB | 2 days ago | 2 days ago\n 4 | skip.rs       | File |          | 1.7 KB  | 2 days ago | 2 days ago\n 5 | str.rs        | File |          | 21.4 KB | 2 days ago | 2 days ago\n 6 | sum.rs        | File |          | 3.0 KB  | 2 days ago | 2 days ago\n 7 | sys.rs        | File |          | 9.2 KB  | 2 days ago | 2 days ago\n 8 | textview.rs   | File |          | 9.4 KB  | 2 days ago | 2 days ago\n 9 | tree.rs       | File |          | 3.0 KB  | 2 days ago | 2 days ago\n---+---------------+------+----------+---------+------------+------------\n\n> ls | sort-by name | nth 5\n--------+------+----------+---------+------------+------------\n name   | type | readonly | size    | accessed   | modified\n--------+------+----------+---------+------------+------------\n str.rs | File |          | 21.4 KB | 2 days ago | 2 days ago\n--------+------+----------+---------+------------+------------\n</code></pre></div><h2 id=\"obteniendo-datos-de-una-tabla\" tabindex=\"-1\"> Obteniendo datos de una tabla</h2>\n<p>Hasta ahora hemos trabajado con tablas reduciendo la tabla a solo lo que necesitamos. A veces es posible que queramos ir un paso más allá y solo mirar los valores en las celdas en lugar the tomar una columna completa. Digamos, por ejemplo, que queramos obtener una lista de los nombres de los archivos. Para esto usamos el comando <code>get</code>:</p>\n<div><pre><code>> ls | get name\n---+---------------\n # | value\n---+---------------\n 0 | add.rs\n 1 | sum.rs\n 2 | inc.rs\n 3 | str.rs\n 4 | skip.rs\n 5 | textview.rs\n 6 | binaryview.rs\n 7 | edit.rs\n 8 | tree.rs\n 9 | sys.rs\n---+---------------\n</code></pre></div><p>Ahora tenemos los valores de cada nombre de los archivos.</p>\n<p>Puede parecerse al comando <code>select</code> que vimos previamente, probemos <code>select</code> para comparar los dos:</p>\n<div><pre><code>> ls | select name\n---+---------------\n # | name\n---+---------------\n 0 | add.rs\n 1 | sum.rs\n 2 | inc.rs\n 3 | str.rs\n 4 | skip.rs\n 5 | textview.rs\n 6 | binaryview.rs\n 7 | edit.rs\n 8 | tree.rs\n 9 | sys.rs\n---+---------------\n</code></pre></div><p>¡Se ven muy similares! Veamos si podemos explicar la diferencia entre estos dos comandos para aclarar:</p>\n<ul>\n<li><code>select</code> - crea una tabla donde incluye únicamente las columnas indicadas</li>\n<li><code>get</code> - devuelve los valores dentro de la columna indicada</li>\n</ul>\n<p>La manera de distinguirlas mirando la tabla de forma característica es con el nombre de columna <code>value</code> que nos permite saber que será una lista de valores con la que podemos trabajar.</p>\n<p>El comando <code>get</code> puede ir más allá y tomar una ruta para datos más profundos en la tabla. Esto simplifica trabajar con datos más complejos como las estructuras que podrías encontrar en archivos .json.</p>\n<h2 id=\"cambiando-datos-de-una-tabla\" tabindex=\"-1\"> Cambiando datos de una tabla</h2>\n<p>Además de seleccionar datos de una tabla, también podemos actualizar lo que contiene una tabla. Es posible que queramos agregar nuevas columnas o editar el contenido de una celda. En Nu, en lugar la misma tabla, cada uno de los comandos en la sección devolvera una nueva tabla en la tubería.</p>\n<h3 id=\"agregando-una-nueva-columna\" tabindex=\"-1\"> Agregando una nueva columna</h3>\n<p>Podemos utilizar el comando <code>add</code> para agregar una nueva columna a la tabla. Veamos un ejemplo:</p>\n<div><pre><code>> open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n</code></pre></div><p>Agreguemos una columna llamada &quot;next_edition&quot; con el valor 2021:</p>\n<div><pre><code>> open rustfmt.toml | add next_edition 2021\n---------+--------------\n edition | next_edition\n---------+--------------\n 2018    | 2021\n---------+--------------\n</code></pre></div><p>Observa que si abrimos el archivo original el contenido permanece igual:</p>\n<div><pre><code>> open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n</code></pre></div><p>Los cambios en Nu son cambios funcionales, lo que significa que funcionan en los valores mismos en vez de causar cambios permanentes. Esto nos permite realizar diferentes tipos de trabajo en nuestra tubería hasta que estemos listos para grabar los resultados con cualquier cambio que nos gustaría si así decidimos. Aquí podríamos grabar los resultados usando el comando <code>save</code>:</p>\n<div><pre><code>> open rustfmt.toml | add next_edition 2021 | save rustfmt2.toml\n/home/jonathan/Source/nushell(master)> open rustfmt2.toml\n---------+--------------\n edition | next_edition\n---------+--------------\n 2018    | 2021\n---------+--------------\n</code></pre></div><h3 id=\"editando-una-columna\" tabindex=\"-1\"> Editando una columna</h3>\n<p>Similarmente al comando <code>add</code>, también podemos usar el comando <code>edit</code> para cambiar el contenido de una columna a un nuevo valor. Abramos el mismo archivo para verlo en acción:</p>\n<div><pre><code>open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n</code></pre></div><p>y ahora, actualizemos la edición y que apunte a la siguiente edición que esperamos soportar:</p>\n<div><pre><code>> open rustfmt.toml | edit edition 2021\n---------\n edition\n---------\n 2021\n---------\n</code></pre></div><h3 id=\"incrementando-valores\" tabindex=\"-1\"> Incrementando valores</h3>\n<p>Hay un comando más en Nu que nos ayudará a trabajar con números y versiones: <code>inc</code>.</p>\n<div><pre><code>> open rustfmt.toml\n---------\n edition\n---------\n 2018\n---------\n> open rustfmt.toml | inc edition\n---------\n edition\n---------\n 2019\n---------\n</code></pre></div><p>Como el valor en &quot;edition&quot; es un número, podemos usar <code>inc</code> para actualizarlo. <code>inc</code> realmente brilla cuando trabajamos con versiones:</p>\n<div><pre><code>> open Cargo.toml | get package.version\n0.1.3\n> open Cargo.toml | inc package.version --minor | get package.version\n0.2.0\n</code></pre></div><p>Cuando trabajamos con versiones podemos usar banderas e indicar cómo incrementar la versión:</p>\n<ul>\n<li><strong>--major</strong> - incrementar major (0.1.3 -&gt; 1.0.0)</li>\n<li><strong>--minor</strong> - incrementar minor (0.1.3 -&gt; 0.2.0)</li>\n<li><strong>--patch</strong> - incrementar patch (0.1.3 -&gt; 0.1.4)</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.693Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Variables y Subexpresiones",
      "url": "www.nushell.sh/es/book/variables_y_subexpresiones.html",
      "id": "www.nushell.sh/es/book/variables_y_subexpresiones.html",
      "content_html": "<h1 id=\"variables-y-subexpresiones\" tabindex=\"-1\"> Variables y Subexpresiones</h1>\n<p>En Nushell hay dos tipos de expresiones de evaluación: variables y subexpresiones. Cuando lees expresiones que empiezan con el signo dólar (<code>$</code>) sabes que trabajas con una expresión de evaluación. Esto indica que cuando Nushell toma el valor en esta posición, necesitará ejecutar un paso de evaluación para procesar la expresión y posterioremente usar el valor del resultado. Ambas formas de expresión de evaluación soportan un modo simple y una forma ruta (<code>path</code>) para trabajar con datos más complejos.</p>\n<h2 id=\"variables\" tabindex=\"-1\"> Variables</h2>\n<p>La variable es el más simple de ambas expresiones de evaluación. Durante la evaluación, una variable es remplazada for su valor.</p>\n<p>Si creamos una variable, podemos imprimir su contenido al usar <code>$</code> para referir a la misma:</p>\n<div><pre><code>> let mi-valor = 4\n> echo $mi-valor\n4\n</code></pre></div><h2 id=\"variables-rutas-paths\" tabindex=\"-1\"> Variables rutas (paths)</h2>\n<p>Una variable ruta funciona al llegar dentro del contenido de una variable, navegando columnas dentro de la misma para alcanzar un valor final. Supongamos que en vez de <code>4</code>, hayamos asignado una tabla como valor:</p>\n<div><pre><code>> let mi-valor = [[nombre]; [pruebausuario]]\n</code></pre></div><p>Podemos usar variables ruta para evaluar la variable <code>$mi-valor</code> y obtener el valor de la columna <code>nombre</code> con un solo paso:</p>\n<div><pre><code>> echo $mi-valor.nombre\npruebausuario\n</code></pre></div><h2 id=\"subexpresiones\" tabindex=\"-1\"> Subexpresiones</h2>\n<p>Siempre puedes evaluar subexpresiones y usar su resultado envolviendo la expresión entre paréntesis <code>()</code>.</p>\n<p>Los paréntesis contienen una tubería que se ejecutará hasta completar, y su valor final será usado. Por ejemplo, <code>(ls)</code> ejecutaría el comando <code>ls</code>, devolviendo como resultado la tabla y <code>(git branch --show-current)</code> ejecutará el comando externo git y devolver una cadena con el nombre de la rama actual. También puedes usar paréntesis para ejecutar expresiones matemáticas como <code>(2 + 3)</code>.</p>\n<p>Subexpresiones también pueden ser tuberías y no solamente comandos individuales. Si desearamos una lista de nombres de archivos superiores a diez kilobytes, podemos utilizar subexpresiones para ejecutar una tubería y asignar el resultado a una variable:</p>\n<div><pre><code>> let nombres-de-archivos-grandes = (ls | where size > 10kb)\n> echo $nombres-de-archivos-grandes\n───┬────────────┬──────┬──────────┬──────────────\n # │    name    │ type │   size   │   modified\n───┼────────────┼──────┼──────────┼──────────────\n 0 │ Cargo.lock │ File │ 155.3 KB │ 17 hours ago\n 1 │ README.md  │ File │  15.9 KB │ 17 hours ago\n───┴────────────┴──────┴──────────┴──────────────\n</code></pre></div><h2 id=\"subexpresiones-y-rutas\" tabindex=\"-1\"> Subexpresiones y rutas</h2>\n<p>Subexpresiones también soportan rutas. Por ejemplo, supongamos que queremos una lista de nombres de archivos en el directorio actual. Una manera de hacerlo es con una tubería:</p>\n<div><pre><code>> ls | get name\n</code></pre></div><p>Pero también podemos hacer una acción similar con un solo paso usando una subexpresión de ruta:</p>\n<div><pre><code>> echo (ls).name\n</code></pre></div><p>Todo depende de las necesidades del código o estilo particular que trabaje mejor para ti.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Índice",
      "url": "www.nushell.sh/es/contributor-book/",
      "id": "www.nushell.sh/es/contributor-book/",
      "content_html": "<h1 id=\"indice\" tabindex=\"-1\"> Índice</h1>\n<ul>\n<li><a href=\"/es/contributor-book/introduccion.html\">Introducción</a> - Una introducción al libro para contribuyentes</li>\n<li><a href=\"/es/contributor-book/filosofia.html\">Filosofía</a> - La filosofía del diseño central</li>\n<li><a href=\"/es/contributor-book/valores.html\">Valores</a> - Los valores (tipos de datos)</li>\n<li><a href=\"/es/contributor-book/comandos.html\">Comandos</a> - Cómo funcionan los comandos</li>\n<li>Streams - Cómo funcionan los streams</li>\n<li><a href=\"/es/contributor-book/metadatos.html\">Metadatos</a> - El sistema de metadatos</li>\n<li>Plugins - Cómo escribir plugins</li>\n<li>Shells - Cómo funciona el sistema de shell</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Comandos",
      "url": "www.nushell.sh/es/contributor-book/comandos.html",
      "id": "www.nushell.sh/es/contributor-book/comandos.html",
      "content_html": "<h1 id=\"comandos\" tabindex=\"-1\"> Comandos</h1>\n<p>Los comandos son los bloques de construcción para las tuberías (pipeline) en Nu. Realizan la acción de la tubería, ya sea creando datos, cambiando datos mientras fluye desde entradas y salidas, o viendo los datos una vez que salen de la tubería. Hay dos tipos de comandos: comandos internos, son aquellos contruídos para ejecución interna de Nu, y comandos externos, comandos que se encuentra fuera de Nu y se comunican con <code>stdin</code> / <code>stdout</code> de estilo Unix estándar.</p>\n<h2 id=\"comandos-internos\" tabindex=\"-1\"> Comandos internos</h2>\n<p>Todos los comandos dentro de Nu, incluyendo complementos (plugins), son comandos internos. Comandos internos se comunican entre ellos usando streams de <code>Tagged&lt;Value&gt;</code> y ShellError (TODO: Enlace a tipos de datos)</p>\n<h3 id=\"firma\" tabindex=\"-1\"> Firma</h3>\n<p>Los comandos utilizan verificación de tipado ligero para garantizar que los argumentos pasados puedan ser manejados correctamente. Para habilitar esto, cada comando proporciona una firma que le dice a Nu:</p>\n<ul>\n<li>El nombre del comando</li>\n<li>Los argumentos posicionales (ej, en <code>start x y</code> la <code>x</code> y la <code>y</code> son argumentos posicionales)</li>\n<li>Si el comando</li>\n<li>Si el comando toma un número adicional ilimitado de argumentos posicionales (ej, <code>start a1 a2 a3 ... a99 a100</code>)</li>\n<li>Los argumentos nombrados (ej, <code>start --now</code>)</li>\n<li>Si el comando es un filtro o sink</li>\n</ul>\n<p>Con esta información, se puede verificar problemas potenciales antes de la ejecución de la tubería.</p>\n<h2 id=\"comandos-externos\" tabindex=\"-1\"> Comandos externos</h2>\n<p>Un comando externo es cualquier comando que no forma parte de los comandos o complementos (plugins) integrados de Nu. Si se llama un comando que Nu desconoce, llamará al entorno subyacente con los argumentos suministrados para intentar el comando como un programa externo.</p>\n<h2 id=\"comunicacion-entre-comandos-internos-y-externos\" tabindex=\"-1\"> Comunicación entre comandos internos y externos</h2>\n<h3 id=\"interno-a-interno\" tabindex=\"-1\"> Interno a interno</h3>\n<p>Los comandos internos se comunican entre ellos usando el stream completo que proporciona Nu, que incluye todos los tipos de archivos integrados. Esto incluye la comunicación entre comandos internos y complementos (en ambas direcciones).</p>\n<h3 id=\"intero-a-externo\" tabindex=\"-1\"> Intero a externo</h3>\n<p>Los comandos internos que envían texto a comandos externos necesitan tener cadenas de texto preparadas con anticipación. Si un objeto es enviado directamente a un comando externo, se considerará como un error ya que no hay forma de inferir cómo los datos estructurados serán representados para el programa externo. Se espera que el usuario se limite a una simple celda de datos o usar uno de los convertidores (como <code>to-json</code>) para convertir la tabla en una representación de cadena.</p>\n<p>El comando externo se abre para que si entrada estándar <code>stdin</code> sea redireccionada, de modo que los datos se puedan enviar a él.</p>\n<h3 id=\"externo-a-interno\" tabindex=\"-1\"> Externo a interno</h3>\n<p>Los comandos externos envían una serie de cadenas a través de su salida estándar <code>stdout</code>. Estas cadenas se leen en la tubería y se ponen a disposición al comando interno que sigue en la tubería, o se muestran al usuario si el comando externo es el último paso en la tubería.</p>\n<h3 id=\"externo-a-externo\" tabindex=\"-1\"> Externo a externo</h3>\n<p>Los comandos externos se comunican entre sí a través de estándar <code>stdin</code>/<code>stdout</code>. Como Nu detectará esta situación, redirigirá la salida estándar <code>stdout</code> del primer comando a la entrada estándar <code>stdin</code> del siguiente comando externo. De esta forma, se mantiene el comportamiento esperado de una tubería de shell entre comandos externos.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Filosofia",
      "url": "www.nushell.sh/es/contributor-book/filosofia.html",
      "id": "www.nushell.sh/es/contributor-book/filosofia.html",
      "content_html": "<h1 id=\"filosofia\" tabindex=\"-1\"> Filosofia</h1>\n<h2 id=\"valores-fundamentales\" tabindex=\"-1\"> Valores Fundamentales</h2>\n<p>El valor central de Nu es que trabajar en un shell debe ser divertido. Para esto, creemos que:</p>\n<ul>\n<li>Una shell moderna debe ser diseñada para usabilidad y ergonomía. <strong>Por encima de todo, Nu debería ser divertido de usar.</strong></li>\n<li>Debería proporcionar buenos mensajes informativos de errores cuando un comando no finalizará correctamente. Esto es de vital importancia. Un shell divertido da mensajes de errores <strong>claros y procesables</strong></li>\n<li>Debe construirse en torno al uso casual, ya que esta es la mayoría del uso en una shell, incluso para usuarios con experiencia. Construyendo una shell que sea <strong>divertido para uso casual se traduce a una shell divertida para todos</strong>.</li>\n<li>Nu soporta experimentación y <strong>crecer ideas de experimentos a programas</strong>. La habilidad de evolucionar ideas desde líneas simples, scripts, y posteriormente a programas es un papel clave que se desempeña en una shell. Para respaldar esto, Nu se basa en la idea de comandos componibles que funcionan en un conjutos compartido de tipos de datos.</li>\n</ul>\n<h2 id=\"no-metas\" tabindex=\"-1\"> No metas</h2>\n<ul>\n<li><em>Rendimiento óptimo</em>. Si bien nos preocupa rendimiento, el enfoque en el rendimiento debe estar al servicio de hacer que Nu sea más usable y agradable de usar. El mejor rendimiento en micro-puntos de referencia no es un objetivo.</li>\n<li><em>Estricto</em>. Queremos ayudar a los usuarios a escribir buenos scripts, pero centrándonos en que dichos scripts sean correctos con buenos errores y buena documentación.</li>\n<li><em>Cumplimiento-POSIX</em>. Nu se optimiza intencionalmente para una experiencia placentera en vez de igualar cómo programas de línea de comandos funcionan de una manera POSIX-compliant. Es importante poder interoperar entre comandos de Nu y comandos externos, pero mantener compatibilidad estricta no es una meta.</li>\n<li><em>Adhesión de paradigma</em>. Nu mira el espacio de shells flexiblemente, y presta buenas ideas de programación funcional, programación de sistemas, orientación a objetos, y más donde sea posible. Seguir algun paradigma en particular de manera rígida no sirve para los objetivos del proyecto Nu.</li>\n</ul>\n<h2 id=\"diseno-basico\" tabindex=\"-1\"> Diseño Básico</h2>\n<p>El diseño central de Nu es el modelo de datos. Comandos siguen en gran medida en el servicio para facilitar la creación de datos, trabajar con datos, y ver datos. Una de las piezas visibles de este trabajo es la canalización a través de la tubería, que se basa en gran medida en las ideas originales de Unix de conectar comandos simples en comandos más complejos. Nu toma esta filosofía de Unix y la extiende desde solo cádenas de texto al más amplio conjuntos de datos que es más común en lenguajes modernos de programación.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Introducción",
      "url": "www.nushell.sh/es/contributor-book/introduccion.html",
      "id": "www.nushell.sh/es/contributor-book/introduccion.html",
      "content_html": "<h1 id=\"introduccion\" tabindex=\"-1\"> Introducción</h1>\n<p>Hola y bienvenido al manual de Nushell para contribuyentes. Nushell, o Nu como se lo llama a menudo, es un shell moderno escrito en Rust. Para más información sobre Nu y cómo usarlo puedes aprenderlo en <a href=\"/es/book\">El libro Nu</a>. En este manual, veremos cómo contribuir al proyecto Nu, cómo está organizado el código, y los conceptos centrales detrás de su diseño.</p>\n<p>Contribuir a Nu requerirá al menos algo de experiencia básica en programación, y es útil tener algo de experiencia con Rust. Dicho esto, hemos tenido personas que han contribuído a Nu sin antes haber escrito una línea de Rust antes de que escribieran su primera contribución. Si te interesa contribuir, hay una comunidad creciente de personas con deseos de ayudarte a tener éxito.</p>\n<p>Este manual está dividido en tres partes:</p>\n<ol>\n<li>El diseño de Nu</li>\n<li>La implementación de Nu</li>\n<li>Mejores prácticas de código en Nu</li>\n</ol>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Metadatos",
      "url": "www.nushell.sh/es/contributor-book/metadatos.html",
      "id": "www.nushell.sh/es/contributor-book/metadatos.html",
      "content_html": "<h1 id=\"metadatos\" tabindex=\"-1\"> Metadatos</h1>\n<p>Todos los valores que fluyen dentro y fuera de los comandos en Nu están etiquetadas con metadatos. Lo encontrarás comúnmente alrededor del código como <code>Tagged&lt;Value&gt;</code></p>\n<p>Aunque los metadatos que se rastrean sigue en sus primeros días, esperamos expandir esto a medida que Nu madure.</p>\n<p>Actualmente, hay dos piezas de metadatos rastreados en cada valor:</p>\n<h2 id=\"origin\" tabindex=\"-1\"> Origin</h2>\n<p>Origin representa la ubicación de donde vino originalmente el valor. Si el valor fue cargado desde un archivo, será el nombre del archivo. Si fue cargado desde una Url, serea la Url, y así sucesivamente.</p>\n<p>Para ahorrar espacio y mantener los metadatos Copy(copiables), el origen se guarda como un UUID. Este identificador apunta a una tabla de búsqueda donde el UUID se puede traducir al origen completo.</p>\n<h2 id=\"span\" tabindex=\"-1\"> Span</h2>\n<p>Span(tramos) es la ubicación de inicio y fin del valor donde fue creado o referenciado en la línea de comandos. Estas se ven comúnmente representadas como el subrayado debajo de un mensaje de error.</p>\n<p>Mientras los spans(tramos) de lenguajes de programación tradicionalmente también llevan el archivo del que proviene el tramo, aquí asumimos que el tramo siempre abarca un valor referenciado en la línea de comandos en lugar de un archivo de código fuente. A medida que Nu tenga la capacidad de ejecutar sus propios archivos de código fuente, esto probablemente tendrá que ser revisado.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Valores",
      "url": "www.nushell.sh/es/contributor-book/valores.html",
      "id": "www.nushell.sh/es/contributor-book/valores.html",
      "content_html": "<h1 id=\"valores\" tabindex=\"-1\"> Valores</h1>\n<p>Un Value es el tipo de dato de estructura básica en Nu.</p>\n<div><pre><code><span>pub</span> <span>struct</span> <span>Value</span> <span>{</span>\n    <span>pub</span> value<span>:</span> <span>UntaggedValue</span><span>,</span>\n    <span>pub</span> tag<span>:</span> <span>Tag</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Donde el campo <code>value</code> es cualquier tipo de valor <code>UntaggedValue</code> dado y el campo <code>tag</code> contiene <a href=\"/es/contributor-book/metadatos.html\">metadatos</a> asociado con él.</p>\n<p>Un <code>UntaggedValue</code> cubre los siguientes tipos de valores:</p>\n<div><pre><code><span>pub</span> <span>enum</span> <span>UntaggedValue</span> <span>{</span>\n    <span>Primitive</span><span>(</span><span>Primitive</span><span>)</span><span>,</span>\n    <span>Row</span><span>(</span><span>Dictionary</span><span>)</span><span>,</span>\n    <span>Table</span><span>(</span><span>Vec</span><span>&lt;</span><span>Value</span><span>></span><span>)</span><span>,</span>\n\n    <span>Error</span><span>(</span><span>ShellError</span><span>)</span><span>,</span>\n\n    <span>Block</span><span>(</span><span>Evaluate</span><span>)</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Donde <code>Primitive</code> es:</p>\n<div><pre><code><span>pub</span> <span>enum</span> <span>Primitive</span> <span>{</span>\n    <span>Nothing</span><span>,</span>\n    <span>Int</span><span>(</span><span>BigInt</span><span>)</span><span>,</span>\n    <span>Decimal</span><span>(</span><span>BigDecimal</span><span>)</span><span>,</span>\n    <span>Bytes</span><span>(</span><span>u64</span><span>)</span><span>,</span>\n    <span>String</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>Line</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>ColumnPath</span><span>(</span><span>ColumnPath</span><span>)</span><span>,</span>\n    <span>Pattern</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>Boolean</span><span>(</span><span>bool</span><span>)</span><span>,</span>\n    <span>Date</span><span>(</span><span>DateTime</span><span>&lt;</span><span>Utc</span><span>></span><span>)</span><span>,</span>\n    <span>Duration</span><span>(</span><span>u64</span><span>)</span><span>,</span>\n    <span>Range</span><span>(</span><span>Box</span><span>&lt;</span><span>Range</span><span>></span><span>)</span><span>,</span>\n    <span>Path</span><span>(</span><span>PathBuf</span><span>)</span><span>,</span>\n    <span>Binary</span><span>(</span><span>Vec</span><span>&lt;</span><span>u8</span><span>></span><span>)</span><span>,</span>\n\n    <span>// Stream markers (used as bookend markers rather than actual values)</span>\n    <span>BeginningOfStream</span><span>,</span>\n    <span>EndOfStream</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Revisemos al revés para ver cómo se construyen tipos de datos completos a partir de los primitivos:</p>\n<h2 id=\"primitivos-primitive\" tabindex=\"-1\"> Primitivos (<code>Primitive</code>)</h2>\n<p>El tipo de dato <code>Primitive</code> es el tipo fundamental en Nu. Mientras hay similaridades a tipos de datos fundamentales de lenguajes de programación, hay algunas diferencias debido a las capacidades en la shell de Nu.</p>\n<p>Nu viene con dos tipos de números 'grandes': <code>BigInt</code> para enteros y <code>BigDecimal</code> para números decimales. Esto permite en el futuro lograr operaciones matemáticas y mantener precisión más tiempo en Nu.</p>\n<p>Otros tipo de datos, quizás un poco diferentes a la norma:</p>\n<ul>\n<li><code>Nothing</code> = representa un valor vacío</li>\n<li><code>Bytes(u64)</code> = tamaños de archivo en números de bytes</li>\n<li><code>Line(String)</code> = valor de cadena con un final de retorno de carro implícito (o cr / lf)</li>\n<li><code>ColumnPath(ColumnPath)</code> = rutas para extraer valores de las tablas</li>\n<li><code>Pattern(string)</code> = un patrón glob (como <code>nu*</code> en <code>ls nu*</code>)</li>\n<li><code>Duration(u64)</code> = representa duración en segundos (como <code>1hr</code> en <code>ls | where modified &lt; 1hr</code> )</li>\n<li><code>Range(Box&lt;Range&gt;)</code> = rangos (como <code>0..2</code> en <code>ls | range 0..2</code>)</li>\n<li><code>Path(PathBuf)</code> = una ruta de archivo</li>\n<li><code>Binary(Vec&lt;u8&gt;)</code> = un arreglo de bytes</li>\n<li><code>BeginningOfStream</code> = un marcador para denotar el inicio de un stream</li>\n<li><code>EndOfStream</code> = un marador para denotar el fin de un stream</li>\n</ul>\n<h2 id=\"untaggedvalue\" tabindex=\"-1\"> UntaggedValue</h2>\n<p>Además de los tipos primitivos, Nu admite tipos de datos agregados. Colectivamente, estos tipos agregados se llaman <code>UntaggedValue</code>s.</p>\n<p>Actualmente, Nu admite 5 tipos de valor <code>UntaggedValue</code>: <code>Row</code>, <code>Table</code>, <code>Block</code>, <code>Primitive</code>, y <code>Error</code>.</p>\n<h3 id=\"tablas-y-filas-table-y-row\" tabindex=\"-1\"> Tablas y Filas (<code>Table</code> y <code>Row</code>)</h3>\n<p>Nu utiliza un conjunto de términos que coinciden un poco más con las hojas de cálculo. En lugar de tener listas de objetos, Nu tiene una tabla que contiene filas. Cada fila contiene los nombres de columna y sus valores correspondientes.</p>\n<h3 id=\"bloques-block\" tabindex=\"-1\"> Bloques (<code>Block</code>)</h3>\n<p>Bloques representa código listo para ser ejecutado por el evaluador. Un ejemplo de esto es la condición <code>where {$it &gt; 10}</code>.</p>\n<h3 id=\"errores-error\" tabindex=\"-1\"> Errores (<code>Error</code>)</h3>\n<p>Representa los errores que pueden ocurrir cuando se ejecutan los comandos en la tubería.</p>\n",
      "date_modified": "2022-06-02T15:48:22.694Z",
      "authors": [],
      "tags": []
    }
  ]
}