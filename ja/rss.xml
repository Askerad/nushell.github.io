<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="www.nushell.sh/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Nushell</title>
    <link>www.nushell.sh/ja/</link>
    <description>新しいタイプのシェル</description>
    <language>ja</language>
    <pubDate>Fri, 03 Jun 2022 05:34:12 GMT</pubDate>
    <lastBuildDate>Fri, 03 Jun 2022 05:34:12 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>目次</title>
      <link>www.nushell.sh/ja/book/</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/</guid>
      <source url="www.nushell.sh/rss.xml">目次</source>
      <content:encoded><![CDATA[<h1 id="目次" tabindex="-1"> 目次</h1>
<ul>
<li><a href="/ja/book/installation.html">インストール</a> - nushell のインストール</li>
<li><a href="/ja/book/introduction.html">はじめに</a> - nushell をはじめよう</li>
<li><a href="/ja/book/moving_around.html">ファイルシステムの操作</a> - nushell からファイルシステムを扱おう</li>
<li><a href="/ja/book/types_of_data.html">データ型</a> - nushell のデータ型</li>
<li><a href="/ja/book/loading_data.html">データの読み込み</a> - データの読み込みとその利用方法</li>
<li><a href="/ja/book/working_with_tables.html">テーブル</a> - テーブルを利用してみよう</li>
<li><a href="/ja/book/pipeline.html">パイプライン</a> - パイプラインの仕組み</li>
<li><a href="/ja/book/configuration.html">設定</a> - nushell の設定方法</li>
<li><a href="/ja/book/aliases.html">エイリアス</a> - コードブロックに名前をつけよう</li>
<li><a href="/ja/book/math.html">Math</a> - nushell で計算する</li>
<li><a href="/ja/book/environment.html">環境変数</a> - 環境変数の設定</li>
<li><a href="/ja/book/metadata.html">メタデータ</a> - nushell におけるメタデータについて</li>
<li><a href="/ja/book/shells_in_shells.html">シェル</a> - 複数の場所で作業しよう</li>
<li><a href="/ja/book/escaping.html">コマンドのエスケープ</a> - Nu コマンドと同じ名前のコマンドを実行するには</li>
<li><a href="/ja/book/plugins.html">プラグイン</a> - プラグインを利用して nushell を拡張する</li>
<li><a href="/ja/book/coming_from_bash.html">Bash から来た人向け</a> - bash から nushell に来た人向けガイド</li>
<li><a href="/ja/book/nushell_map.html">shells/DSL と nushell の対応表</a> - nushell と SQL, Linq, PowerShell, Bash との対応表。コントリビューション歓迎。</li>
<li><a href="/ja/book/nushell_map_imperative.html">命令形言語と nushell の対応表</a> - nushell と Python, Kotlin, C++, C#, Rust との対応表。コントリビューション歓迎。</li>
<li><a href="/ja/book/nushell_map_functional.html">関数型言語と nushell の対応表</a> - nushell と Clojure, Tablecloth (Ocaml / Elm), Haskell との対応表。コントリビューション歓迎。</li>
<li><a href="/ja/book/nushell_operator_map.html">Nushell 演算子対応表</a> - 演算子の対応表。</li>
<li><a href="/ja/book/command_reference.html">Command Reference</a> - A list of all Nushell's commands.</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>エイリアス</title>
      <link>www.nushell.sh/ja/book/aliases.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/aliases.html</guid>
      <source url="www.nushell.sh/rss.xml">エイリアス</source>
      <content:encoded><![CDATA[<h1 id="エイリアス" tabindex="-1"> エイリアス</h1>
<p>Nu ではパイプラインを利用して自由にデータやシステムを操作できますが、その反面多くのタイピングを要してしまいます。一度作成したパイプラインを保存しておき再利用できるようにしておきたいところです。</p>
<p>そこでエイリアスの出番です。</p>
<p>エイリアスを使うとコマンドのブロックに名前をつけることができます。エイリアスを実行するとそのコマンドブロックが実行されます。</p>
<p>例:</p>
<div><pre><code>> alias ls-names [] { ls | select name }
> ls-names
────┬────────────────────
 #  │ name
────┼────────────────────
  0 │ 404.html
  1 │ CONTRIBUTING.md
  2 │ Gemfile
  3 │ Gemfile.lock
  4 │ LICENSE
</code></pre></div><h2 id="パラメータ" tabindex="-1"> パラメータ</h2>
<p>エイリアスは、ブロックに渡されるオプションのパラメータをもつことができます。これらはブロック内の新しい変数になります。</p>
<div><pre><code>> alias e [msg] { echo $msg }
> e "hello world"
hello world
</code></pre></div><p>パラメータは任意の数設定することができ、ユーザが値を提供しなかった場合、ブロック内では Nothing と評価されて削除されます。</p>
<h2 id="保存" tabindex="-1"> 保存</h2>
<p>デフォルトでは、エイリアスは現在のセッションでのみ有効です。これは一時的なヘルパーや新しいエイリアスをテストするのに便利ですが、エイリアスを有効に活用するには保存しておく必要があります。エイリアスを保存するには、alias を<code>--save</code>(もしくは<code>-s</code>)つきで実行します。例えば</p>
<div><pre><code>alias e --save [msg] { echo $msg }
</code></pre></div><p>エイリアスは起動時の設定に保存され、<code>config get startup</code>で確認することができます。<code>startup</code>設定がまだ存在していない場合はエラーが表示されます。</p>
<p>config.toml ファイルのエイリアスを直接編集することもできます。<code>vi</code>を使う場合は</p>
<div><pre><code>config path | vi $it
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Bash から来た人向け</title>
      <link>www.nushell.sh/ja/book/coming_from_bash.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/coming_from_bash.html</guid>
      <source url="www.nushell.sh/rss.xml">Bash から来た人向け</source>
      <content:encoded><![CDATA[<h1 id="bash-から来た人向け" tabindex="-1"> Bash から来た人向け</h1>
<p>注: このテーブルは Nu 1.14.1 以降を想定しています。</p>
<table>
<thead>
<tr>
<th>Bash</th>
<th>Nu</th>
<th>Task</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ls</code></td>
<td><code>ls</code></td>
<td>Lists the files in the current directory</td>
</tr>
<tr>
<td><code>ls &lt;dir&gt;</code></td>
<td><code>ls &lt;dir&gt;</code></td>
<td>Lists the files in the given directory</td>
</tr>
<tr>
<td><code>ls pattern*</code></td>
<td><code>ls pattern*</code></td>
<td>Lists files that match a given pattern</td>
</tr>
<tr>
<td><code>ls -la</code></td>
<td><code>ls --long --all</code> or <code>ls -la</code></td>
<td>List files with all available information, including hidden files</td>
</tr>
<tr>
<td><code>ls -d */</code></td>
<td><code>ls | where type == Dir</code></td>
<td>List directories</td>
</tr>
<tr>
<td><code>find . -name *.rs</code></td>
<td><code>ls **/*.rs</code></td>
<td>Find recursively all files that match a given pattern</td>
</tr>
<tr>
<td><code>cd &lt;directory&gt;</code></td>
<td><code>cd &lt;directory&gt;</code></td>
<td>Change to the given directory</td>
</tr>
<tr>
<td><code>cd</code></td>
<td><code>cd</code></td>
<td>Change to the home directory</td>
</tr>
<tr>
<td><code>mkdir &lt;path&gt;</code></td>
<td><code>mkdir &lt;path&gt;</code></td>
<td>Creates the given path</td>
</tr>
<tr>
<td><code>mkdir -p &lt;path&gt;</code></td>
<td><code>mkdir &lt;path&gt;</code></td>
<td>Creates the given path, creating parents as necessary</td>
</tr>
<tr>
<td><code>touch test.txt</code></td>
<td><code>touch test.txt</code></td>
<td>Create a file</td>
</tr>
<tr>
<td><code>&gt; &lt;path&gt;</code></td>
<td><code>| save --raw &lt;path&gt;</code></td>
<td>Save string into a file</td>
</tr>
<tr>
<td><code>cat &lt;path&gt;</code></td>
<td><code>open --raw &lt;path&gt;</code></td>
<td>Display the contents of the given file</td>
</tr>
<tr>
<td></td>
<td><code>open &lt;path&gt;</code></td>
<td>Read a file as structured data</td>
</tr>
<tr>
<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>
<td>Move file to new location</td>
</tr>
<tr>
<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>
<td>Copy file to new location</td>
</tr>
<tr>
<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>
<td>Copy directory to a new location, recursively</td>
</tr>
<tr>
<td><code>rm &lt;path&gt;</code></td>
<td><code>rm &lt;path&gt;</code></td>
<td>Remove the given file</td>
</tr>
<tr>
<td></td>
<td><code>rm -t &lt;path&gt;</code></td>
<td>Move the given file to the system trash</td>
</tr>
<tr>
<td><code>rm -rf &lt;path&gt;</code></td>
<td><code>rm -r &lt;path&gt;</code></td>
<td>Recursively removes the given path</td>
</tr>
<tr>
<td><code>chmod</code></td>
<td><code>&lt;not yet possible&gt;</code></td>
<td>Changes the file attributes</td>
</tr>
<tr>
<td><code>date -d &lt;date&gt;</code></td>
<td><code>echo &lt;date&gt; | str to-datetime -f &lt;format&gt;</code></td>
<td>Parse a date (<a href="https://docs.rs/chrono/0.4.15/chrono/format/strftime/index.html" target="_blank" rel="noopener noreferrer">format documentation</a>)</td>
</tr>
<tr>
<td><code>sed</code></td>
<td><code>str find-replace</code></td>
<td>Find and replace a pattern in a string</td>
</tr>
<tr>
<td><code>grep &lt;pattern&gt;</code></td>
<td><code>where $it =~ &lt;substring&gt;</code></td>
<td>Filter strings that contain the substring</td>
</tr>
<tr>
<td><code>man &lt;command&gt;</code></td>
<td><code>help &lt;command&gt;</code></td>
<td>Get the help for a given command</td>
</tr>
<tr>
<td></td>
<td><code>help commands</code></td>
<td>List all available commands</td>
</tr>
<tr>
<td></td>
<td><code>help --find &lt;string&gt;</code></td>
<td>Search for match in all available commands</td>
</tr>
<tr>
<td><code>command1 &amp;&amp; command2</code></td>
<td><code>command1; command2</code></td>
<td>Run a command, and if it's successful run a second</td>
</tr>
<tr>
<td><code>stat $(which git)</code></td>
<td><code>stat (which git).path</code></td>
<td>Use command output as argument for other command</td>
</tr>
<tr>
<td><code>echo $PATH</code></td>
<td><code>echo $nu.path</code></td>
<td>See the current path</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>config set path [&lt;dir1&gt; &lt;dir2&gt; ...]</code></td>
<td>Update PATH permanently</td>
</tr>
<tr>
<td><code>export PATH = $PATH:/usr/other/bin</code></td>
<td><code>pathvar add &lt;path&gt;</code></td>
<td>Update PATH temporarily</td>
</tr>
<tr>
<td><code>export</code></td>
<td><code>echo $nu.env</code></td>
<td>List the current environment variables</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>echo $nu.env | insert var value | config set_into env</code></td>
<td>Update environment variables permanently</td>
</tr>
<tr>
<td><code>FOO=BAR ./bin</code></td>
<td><code>FOO=BAR ./bin</code></td>
<td>Update environment temporarily</td>
</tr>
<tr>
<td><code>export FOO=BAR</code></td>
<td><code>let-env FOO = BAR</code></td>
<td>Set environment variable for current session</td>
</tr>
<tr>
<td><code>unset FOO</code></td>
<td><code>let-env FOO = $nothing</code></td>
<td>Unset environment variable for current session</td>
</tr>
<tr>
<td><code>alias s=&quot;git status -sb&quot;</code></td>
<td><code>alias s = git status -sb</code></td>
<td>Define an alias temporarily</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>alias --save myecho [msg] { echo Hello $msg }</code></td>
<td>Define an alias for all sessions (persist it in startup config)</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>&lt;update nu/config.toml&gt;</code></td>
<td>Add and edit alias permanently (for new shells), find path for the file with <code>config path</code></td>
</tr>
<tr>
<td><code>bash -c &lt;commands&gt;</code></td>
<td><code>nu -c &lt;commands&gt;</code></td>
<td>Run a pipeline of commands (requires 0.9.1 or later)</td>
</tr>
<tr>
<td><code>bash &lt;script file&gt;</code></td>
<td><code>nu &lt;script file&gt;</code></td>
<td>Run a script file (requires 0.9.1 or later)</td>
</tr>
<tr>
<td><code>\</code></td>
<td><code>&lt;not yet possible&gt;</code></td>
<td>Line continuation is not yet supported.</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>Command Reference</title>
      <link>www.nushell.sh/ja/book/command_reference.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/command_reference.html</guid>
      <source url="www.nushell.sh/rss.xml">Command Reference</source>
      <content:encoded><![CDATA[<h1 id="command-reference" tabindex="-1"> Command Reference</h1>
<table>
  <tr>
    <th>コマンド</th>
    <th>説明 </th>
  </tr>
  <tr v-for="command in commands">
   <td><a :href="command.path"><code>{{ command.title }}</code></a></td>
   <td style="white-space: pre-wrap;">{{ command.frontmatter.usage }}</td>
  </tr>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>設定</title>
      <link>www.nushell.sh/ja/book/configuration.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/configuration.html</guid>
      <source url="www.nushell.sh/rss.xml">設定</source>
      <content:encoded><![CDATA[<h1 id="設定" tabindex="-1"> 設定</h1>
<p>Nu には、見た目や挙動を変更させるための内部的な変数があります。
以下がそのリストです。</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>completion_mode</td>
<td>&quot;list&quot; or &quot;circular&quot;</td>
<td>利用する自動補完のモード</td>
</tr>
<tr>
<td>ctrlc_exit</td>
<td>boolean</td>
<td>ctrl-c を複数回押したときに Nu を exit するかどうか</td>
</tr>
<tr>
<td>disable_table_indexes</td>
<td>boolean</td>
<td>テーブルインデックスカラムを無効にするかどうか</td>
</tr>
<tr>
<td>edit_mode</td>
<td>&quot;vi&quot; or &quot;emacs&quot;</td>
<td>行の編集モードを&quot;vi&quot;か&quot;emacs&quot;モードに変更する</td>
</tr>
<tr>
<td>env</td>
<td>row</td>
<td>外部コマンドに渡す環境変数</td>
</tr>
<tr>
<td>header_align</td>
<td>&quot;center&quot;, &quot;right&quot;, or other</td>
<td>テーブルのヘッダーの揃え方</td>
</tr>
<tr>
<td>key_timeout</td>
<td>integer</td>
<td>edit モードのスイッチ時のタイムアウト</td>
</tr>
<tr>
<td>nonzero_exit_errors</td>
<td>boolean</td>
<td>外部コマンドが 0 以外の終了ステータスの場合にエラーを表示するかどうか</td>
</tr>
<tr>
<td>path</td>
<td>list of strings</td>
<td>バイナリーを検索する PATH</td>
</tr>
<tr>
<td>startup</td>
<td>list of strings</td>
<td><code>alias</code>のような nushell 起動時に実行するコマンド</td>
</tr>
<tr>
<td>table_mode</td>
<td>&quot;light&quot; or other</td>
<td>テーブルのモード</td>
</tr>
<tr>
<td>no_auto_pivot</td>
<td>boolean</td>
<td>自動で 1 行のデータを pivot するかどうか</td>
</tr>
<tr>
<td>skip_welcome_message</td>
<td>boolean</td>
<td>nushell 起動時にウェルカムメッセージの表示をスキップするかどうか</td>
</tr>
</tbody>
</table>
<h2 id="利用方法" tabindex="-1"> 利用方法</h2>
<h3 id="変数の設定" tabindex="-1"> 変数の設定</h3>
<p>これらの変数のいずれかを設定するには<code>config set</code> コマンドを利用します。例えば</p>
<div><pre><code>> config set edit_mode "vi"
</code></pre></div><h3 id="パイプラインからの変数を設定" tabindex="-1"> パイプラインからの変数を設定</h3>
<p>設定したい値をパイプラインを通じて設定することもできます。このためには<code>set_into</code>フラグを利用します。</p>
<div><pre><code>> echo "bar" | config set_into foo
</code></pre></div><p>この方法は、<code>env</code>や<code>path</code>変数を設定する際に便利です。</p>
<h3 id="すべての変数の表示" tabindex="-1"> すべての変数の表示</h3>
<p><code>config</code>コマンドを引数なしで実行すると現在の設定されている変数を表示します。</p>
<div><pre><code>> config
─────────────────┬──────────────────
 completion_mode │ circular
 env             │ [row 51 columns]
 path            │ [table 9 rows]
 startup         │ [table 1 rows]
─────────────────┴──────────────────
</code></pre></div><p>注: もしまだ変数を設定していない場合、出力が空の場合があります。</p>
<h3 id="変数の取得" tabindex="-1"> 変数の取得</h3>
<p><code>get</code>フラグを利用して特定の変数の値を取得できます。</p>
<div><pre><code>> config get edit_mode
</code></pre></div><h3 id="変数の削除" tabindex="-1"> 変数の削除</h3>
<p>変数を削除する場合、<code>remove</code>フラグを利用します。</p>
<div><pre><code>> config remove edit_mode
</code></pre></div><h3 id="設定全体のクリア" tabindex="-1"> 設定全体のクリア</h3>
<p>設定全体をクリアして、最初からやりなおしたい場合は<code>--clear</code>フラグを利用できます。このコマンドを実行すると設定ファイルもクリアされるので注意してください。</p>
<div><pre><code>> config clear
</code></pre></div><h3 id="設定が保存されている場所をみつける" tabindex="-1"> 設定が保存されている場所をみつける</h3>
<p>設定ファイルはデフォルトの場所から読み込まれます。この場所をみつけるには<code>-path</code>フラグを利用します。</p>
<div><pre><code>> config path
/home/jonathant/.config/nu/config.toml
</code></pre></div><h3 id="ファイルから設定を読み込む" tabindex="-1"> ファイルから設定を読み込む</h3>
<p>デフォルトとは違う設定ファイルを読み込みたい場合は、<code>load</code> パラメーターを利用します。</p>
<div><pre><code>> config load myconfiguration.toml
</code></pre></div><h2 id="nu-をログインシェルとして設定する" tabindex="-1"> Nu をログインシェルとして設定する</h2>
<p>Nu をログインシェルとして利用するには、<code>path</code>と<code>env</code>変数を設定する必要があります。これらによりログインシェルとして外部コマンドを実行するのに十分なサポートが得られます。</p>
<p>切り替える前に、Bash 等の別のシェルから Nu を実行します。そして次のコマンドで環境変数と PATH をシェルから取得します。</p>
<div><pre><code>> config set path $nu.path
> config set env $nu.env
</code></pre></div><p>0.7.2 より以前のバージョンでは</p>
<div><pre><code>> config --set [path $nu:path]
> config --set [env $nu:env]
</code></pre></div><p><code>$nu.path</code>および<code>$nu.env</code>にはそれぞれ、現在の PATH と環境変数がセットされています。これらをセットすると、のちに Nu をログインシェルとして利用したさいに利用できるようになります。</p>
<p>次にいくつかのディストリビューションでは、Nu が<code>/etc/shells</code>のリストに含まれているかを確認する必要があります。</p>
<div><pre><code>❯ cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/bin/dash
/bin/bash
/bin/rbash
/usr/bin/screen
/usr/bin/fish
/home/jonathan/.cargo/bin/nu
</code></pre></div><p>これにより、<code>chsh</code>で Nu をログインシェルとして設定できるようになります。ログアウト後、次回のログイン時に Nu の素敵なプロンプトが表示されます。</p>
<h2 id="プロンプトの設定" tabindex="-1"> プロンプトの設定</h2>
<p>プロンプトの設定は<code>prompt</code>の値を設定することで行います。<br>
例えば、<a href="https://starship.rs" target="_blank" rel="noopener noreferrer">starship</a>を使うには、ダウンロードして次のコマンドを実行します。(0.18.2 and later)</p>
<div><pre><code>config set prompt "starship prompt"
</code></pre></div><p>Nu を再起動すると</p>
<div><pre><code>nushell on 📙 master [$] is 📦 v0.18.2 via 🦀 v1.48.0-nightly
❯
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>環境変数</title>
      <link>www.nushell.sh/ja/book/environment.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/environment.html</guid>
      <source url="www.nushell.sh/rss.xml">環境変数</source>
      <content:encoded><![CDATA[<h1 id="環境変数" tabindex="-1"> 環境変数</h1>
<p>外部アプリケーションが使用する環境を制御することはシェルの一般的なタスクです。多くの場合、環境はパッケージ化されて外部のアプリケーション起動時に与えられることで自動的に行われます。しかし時には、アプリケーションが利用する環境変数をより正確に制御したい場合があります。</p>
<p>アプリケーションに送られる現在の環境変数は<code>$nu.env</code>の値を echo して確認することができます。</p>
<div><pre><code>> echo $nu.env
──────────────────────────┬──────────────────────────────
 COLORTERM                │ truecolor
 DBUS_SESSION_BUS_ADDRESS │ unix:path=/run/user/1000/bus
 DESKTOP_SESSION          │ gnome
 DISPLAY                  │ :1
</code></pre></div><p>環境は Nu の設定と Nu が実行されている環境から作られます。<a href="/ja/book/configuration.html">設定の章</a>に記載されている方法で環境を恒久的に更新できます。</p>
<p>コマンドやパイプラインを実行するときに一時的に環境変数を更新することもできます。</p>
<div><pre><code>> with-env [FOO BAR] { echo $nu.env.FOO }
BAR
</code></pre></div><p><code>with-env</code>コマンドは、環境変数を一時的に与えられた値に設定します(ここでは変数&quot;FOO&quot;に&quot;BAR&quot;という値がセットされます)。ブロックは新しい環境変数が設定された状態で実行されます。</p>
<p>Bash などにヒントを得た一般的な省略記法も用意されています。上の例は次のように書くことができます。</p>
<div><pre><code>> FOO=BAR echo $nu.env.FOO
BAR
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>エスケープ</title>
      <link>www.nushell.sh/ja/book/escaping.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/escaping.html</guid>
      <source url="www.nushell.sh/rss.xml">エスケープ</source>
      <content:encoded><![CDATA[<h1 id="エスケープ" tabindex="-1"> エスケープ</h1>
<p>Nu は様々な OS で使用できる一連のコマンドを提供します。このような一貫性があると便利です。ただし、ときには Nu コマンドと同じ名前のコマンドを実行したいときがあります。例えば、ローカルの<code>ls</code>や<code>date</code>コマンドなどです。このような場合にはキャレット(^)コマンドを使用します。</p>
<p>Nu のコマンド:</p>
<div><pre><code>> ls
</code></pre></div><p>ローカルコマンドへのエスケープ:</p>
<div><pre><code>> ^ls
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Nu のインストール</title>
      <link>www.nushell.sh/ja/book/installation.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/installation.html</guid>
      <source url="www.nushell.sh/rss.xml">Nu のインストール</source>
      <content:encoded><![CDATA[<h1 id="nu-のインストール" tabindex="-1"> Nu のインストール</h1>
<p>今のところ Nu をインストールするもっともよい方法は、<a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a>からインストールするか、ビルド済のバイナリーを<a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">リリースページ</a>からダウンロードするか、ソースからビルドすることです。
Docker を利用してビルド済のコンテナをプルしてくる方法もあります。</p>
<h2 id="ビルド済みのバイナリー" tabindex="-1"> ビルド済みのバイナリー</h2>
<p>ビルド済の Nu は<a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">リリースページ</a>からダウンロードできます。もし、macOS で<a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">Homebrew</a> を利用しているなら、<code>brew install nushell</code>を実行して、バイナリーをインストールできます。</p>
<h2 id="windows" tabindex="-1"> Windows</h2>
<p><strong>Note</strong> Nu は Windows 10 で動作しますが、現在のところ 7/8.1 はサポートされていません。</p>
<p><a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">リリースページ</a>から<code>.zip</code>ファイルをダウンロードして、例えば次の箇所に解凍します。</p>
<div><pre><code>C:<span>\</span>Program Files
</code></pre></div><p>そして、<code>nu</code>フォルダを PATH に追加します。これが済めば、<code>nu</code>コマンドで Nu を起動できます。</p>
<div><pre><code><span>></span> nu
C:<span>\</span>Users<span>\</span>user<span>></span>
</code></pre></div><p>もし、<a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener noreferrer">Windows Terminal</a>を使っているなら、次のようにして<code>nu</code>をデフォルトシェルに指定できます。</p>
<div><pre><code><span>{</span>
  <span>"guid"</span><span>:</span> <span>"{2b372ca1-1ee2-403d-a839-6d63077ad871}"</span>,
  <span>"hidden"</span><span>:</span> false,
  <span>"icon"</span><span>:</span> <span>"https://www.nushell.sh/icon.png"</span>,
  <span>"name"</span><span>:</span> <span>"Nu Shell"</span>,
  <span>"commandline"</span><span>:</span> <span>"nu.exe"</span>
<span>}</span>
</code></pre></div><p>この設定を Terminal Settings の<code>&quot;profiles&quot;</code>に追加します。そして、<code>&quot;defaultProfile&quot;</code>を次のように変更します。</p>
<div><pre><code><span>"defaultProfile"</span><span>:</span> <span>"{2b372ca1-1ee2-403d-a839-6d63077ad871}"</span>,
</code></pre></div><p>これで<code>nu</code>が Windows Terminal の起動時にロードされます。</p>
<h2 id="事前準備" tabindex="-1"> 事前準備</h2>
<p>Nu をインストールする前に、システムに必要なツールがそろっているか確認する必要があります。現在、Rust のツールチェインといくつかの依存関係が必要です。</p>
<h3 id="コンパイラスイートのインストール" tabindex="-1"> コンパイラスイートのインストール</h3>
<p>Rust が適切に機能するには、互換性のあるコンパイラスイートがシステムにインストールされている必要があります。推奨されるコンパイラスイートは次のとおりです。</p>
<ul>
<li>Linux: GCC or Clang</li>
<li>macOS: Clang (install Xcode)</li>
<li>Windows: <a href="https://visualstudio.microsoft.com/vs/community/" target="_blank" rel="noopener noreferrer">Visual Studio Community Edition</a></li>
</ul>
<p>Linux と macOS の場合、コンパイラのインストールが完了すれば、<code>rustup</code>での Rust のインストールの準備が整います。</p>
<p>Windows の場合、Visual Studio Community Edition をインストールするときに、「C ++ビルドツール」をインストールする必要があります。
オプショナルなインストールとして提供されている<code>link.exe</code>が必要なためです。これで次のステップに進む準備ができました。</p>
<h3 id="rust-のインストール" tabindex="-1"> Rust のインストール</h3>
<p>Rust がシステムにまだインストールされていない場合は、<a href="https://rustup.rs/" target="_blank" rel="noopener noreferrer">rustup</a>を利用して Rust をインストールする方法がベストです。Rustup は、異なる Rust のバージョンのインストールを管理するツールです。</p>
<p>Nu は現在、<strong>最新の stable(1.46 or later)</strong> バージョンの Rust を必要とします。
<code>rustup</code>で正しい version を選択するのが良い方法です。
最初に&quot;rustup&quot;を実行すると、インストールする Rust のバージョンを尋ねられます。</p>
<div><pre><code>Current installation options:

default <span>host</span> triple: x86_64-unknown-linux-gnu
default toolchain: stable
profile: default
modify <span>PATH</span> variable: <span>yes</span>

<span>1</span><span>)</span> Proceed with installation <span>(</span>default<span>)</span>
<span>2</span><span>)</span> Customize installation
<span>3</span><span>)</span> Cancel installation
</code></pre></div><p>準備ができたら、1 を押してからエンターを押します。</p>
<p>もし、<code>rustup</code>を経由して Rust をインストールしたくない場合、他の方法でもインストールすることができます。(例えば、Linux ディストリビューションのパッケージから)
その場合でも Rust の 1.46 以上のバージョンがインストールされるようにしてください。</p>
<h2 id="依存関係" tabindex="-1"> 依存関係</h2>
<h3 id="debian-ubuntu" tabindex="-1"> Debian / Ubuntu</h3>
<p>&quot;pkg-config&quot;および&quot;libssl-dev&quot;パッケージをインストールしてください。</p>
<div><pre><code><span>apt</span> <span>install</span> pkg-config libssl-dev
</code></pre></div><p><code>rawkey</code>や<code>clipboard</code>機能を使用する Linux ユーザーは&quot;libx11-dev&quot;および&quot;libxcb-composite0-dev&quot;パッケージをインストールする必要があります。</p>
<div><pre><code><span>apt</span> <span>install</span> libxcb-composite0-dev libx11-dev
</code></pre></div><h3 id="rhel-based-distros" tabindex="-1"> RHEL based distros</h3>
<p>&quot;libxcb&quot;, &quot;openssl-devel&quot;および&quot;libX11-devel&quot;パッケージをインストールする必要があります。</p>
<div><pre><code>yum <span>install</span> libxcb openssl-devel libX11-devel
</code></pre></div><h3 id="macos" tabindex="-1"> macOS</h3>
<p><a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">Homebrew</a>を利用して、&quot;openssl&quot;と&quot;cmake&quot;をインストールしてください。</p>
<div><pre><code>brew <span>install</span> openssl cmake
</code></pre></div><h2 id="crates-ioからのインストール" tabindex="-1"> <a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a>からのインストール</h2>
<p>必要となる依存関係が準備できたら、Rust コンパイラーに付属している<code>cargo</code>を使って、Nu をインストールできます。
cargo は Nu とそのソースの依存関係をダウンロードし、ビルドしたあと、実行できるように cargo の bin path にインストールします。</p>
<div><pre><code><span>></span> cargo <span>install</span> nu
</code></pre></div><p>これでおしまいです！<code>cargo</code>は Nu のソースコードとその依存関係をダウンロードしてビルドし、<code>cargo</code>のバイナリーパスにインストールすることで Nu を実行できるようにします。</p>
<p>より多くの機能をインストールするには、次のようにします。</p>
<div><pre><code><span>></span> cargo <span>install</span> nu --features<span>=</span>extra
</code></pre></div><p>すべての機能を利用するための最も簡単な方法は Nu をチェックアウトして、Rust ツールを利用してビルドすることです。</p>
<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git
<span>></span> <span>cd</span> nushell
nushell<span>></span> cargo <span>install</span> --path <span>.</span> --features<span>=</span>extra
</code></pre></div><p>上で示したすべての依存関係がシステムにあることを確認してください。
インストールが完了すると、<code>nu</code>コマンドで Nu を実行できます。</p>
<div><pre><code>$ nu
/home/jt/Source<span>></span>
</code></pre></div><h2 id="ソースからビルド" tabindex="-1"> ソースからビルド</h2>
<p>github のソースから直接ビルドすることもできます。こうすることで、最新の機能やバグ修正にすぐにアクセスすることができます。</p>
<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git
</code></pre></div><p>Git でメインの nushell リポジトリをクローンし、Nu をビルドして実行できます。</p>
<div><pre><code><span>></span> <span>cd</span> nushell
nushell<span>></span> cargo build --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --features<span>=</span>extra
</code></pre></div><p>リリースモードで Nu をビルドし実行することもできます。</p>
<div><pre><code>nushell<span>></span> cargo build --release --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --release --features<span>=</span>extra
</code></pre></div><p>Rust に慣れている人は、&quot;run&quot;がデフォルトでビルドを行うのに、なぜ&quot;build&quot;と&quot;run&quot;の両方を行うのか疑問に思うかもしれません。
これは Cargo の新しい<code>default-run</code>オプションの欠点を回避し、全てのプラグインがビルドされるようにするためですが、将来的には必要なくなるかもしれません。</p>
<h2 id="ログインシェルとして設定するには" tabindex="-1"> ログインシェルとして設定するには</h2>
<p><strong>!!! Nu は開発中なので、日常使いのシェルとしての安定性を欠く可能性があります!!!</strong></p>
<p><a href="https://linux.die.net/man/1/chsh" target="_blank" rel="noopener noreferrer"><code>chsh</code></a>コマンドを使用して、ログインシェルを設定できます。
一部の Linux ディストリビューションには<code>/etc/shells</code>に有効なシェルのリストが記載されており、Nu がホワイトリストに登録されるまで変更ができません。
<code>shells</code>ファイルを更新していない場合は次のようなエラーが表示される場合があります。</p>
<div><pre><code>chsh: /home/username/.cargo/bin/nu is an invalid shell
</code></pre></div><p>Nu バイナリを<code>shells</code>ファイルに追加することにより、許可されたシェルのリストに Nu を追加できます。
追加するパスは<code>which nu</code>コマンドで見つけることができます。通常は<code>$HOME/.cargo/bin/nu</code>です。</p>
]]></content:encoded>
    </item>
    <item>
      <title>はじめに</title>
      <link>www.nushell.sh/ja/book/introduction.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/introduction.html</guid>
      <source url="www.nushell.sh/rss.xml">はじめに</source>
      <content:encoded><![CDATA[<h1 id="はじめに" tabindex="-1"> はじめに</h1>
<p>こんにちは、Nushell プロジェクトへようこそ。このプロジェクトのゴールは、シンプルなコマンドをパイプでつなぎ合わせるというシェルの Unix 哲学を現代の開発スタイルにもちこむことです。</p>
<p>Nu は Bash のような伝統的なシェル、PowerShell などの高度なシェル、関数型プログラミング、システムプログラミングなど、多くの分野からヒントを得ています。しかし Nu は何でもこなせることを目指すのではなく、いくつかのことをうまくこなせることに注力しています。</p>
<ul>
<li>モダンな雰囲気をもつ柔軟なクロスプラットフォームシェルを作ること</li>
<li>データ構造を理解するコマンドラインアプリケーションを組みあわせることができること</li>
<li>現代的な CLI アプリケーションが提供する UX をそなえること</li>
</ul>
<p>Nu になにができるかをみるには、実際に使ってみることが一番です。</p>
<p><code>ls</code>コマンドを実行して最初に気づくことは、テキストブロックではなく、構造化されたテーブルデータが返ってくることです。</p>
<div><pre><code><span>></span> <span>ls</span>
╭────┬───────────────────────┬──────┬───────────┬─────────────╮
│ <span>#  │         name          │ type │   size    │  modified   │</span>
├────┼───────────────────────┼──────┼───────────┼─────────────┤
│  <span>0</span> │ <span>404</span>.html              │ <span>file</span> │     <span>429</span> B │ <span>3</span> days ago  │
│  <span>1</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>8</span> mins ago  │
│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>3</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │
│  <span>4</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>5</span> │ README.md             │ <span>file</span> │     <span>213</span> B │ <span>3</span> days ago  │
<span>..</span>.
</code></pre></div><p>このテーブルはディレクトリの内容を別の方法で表示しているだけではありません。このテーブルを利用するとスプレッドシートと同じように、よりインタラクティブにデータを操作できます。</p>
<p>最初に行うことはテーブルをサイズでソートすることです。これを行うには<code>ls</code>の出力を取得して、カラムの内容に基づいてテーブルをソートするコマンドに入力します。</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> reverse
╭────┬───────────────────────┬──────┬───────────┬─────────────╮
│ <span>#  │         name          │ type │   size    │  modified   │</span>
├────┼───────────────────────┼──────┼───────────┼─────────────┤
│  <span>0</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │
│  <span>1</span> │ SUMMARY.md            │ <span>file</span> │   <span>3.7</span> KiB │ <span>3</span> days ago  │
│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>3</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>4</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>9</span> mins ago  │
│  <span>5</span> │ books.md              │ <span>file</span> │     <span>687</span> B │ <span>3</span> days ago  │
<span>..</span>.
</code></pre></div><p>この作業をおこなうために、<code>ls</code>にコマンドライン引数を渡していないことがわかります。代わりに、Nu が提供する<code>sort-by</code>コマンドを利用して、<code>ls</code>コマンドの出力をソートしています。また、一番大きなファイルを表示するために逆順に並び替えています。</p>
<p>Nu にはテーブルを扱うための多くのコマンドが用意されています。例えば、1 キロバイトを超えるファイルのみを表示するように<code>ls</code>コマンドの出力をフィルターできます。</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 1kb
╭───┬───────────────────┬──────┬─────────┬────────────╮
│ <span># │       name        │ type │  size   │  modified  │</span>
├───┼───────────────────┼──────┼─────────┼────────────┤
│ <span>0</span> │ Gemfile           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │
│ <span>1</span> │ Gemfile.lock      │ <span>file</span> │ <span>6.9</span> KiB │ <span>3</span> days ago │
│ <span>2</span> │ LICENSE           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │
│ <span>3</span> │ SUMMARY.md        │ <span>file</span> │ <span>3.7</span> KiB │ <span>3</span> days ago │
╰───┴───────────────────┴──────┴─────────┴────────────╯
</code></pre></div><p>Unix 哲学にあるように、コマンドをつなぎ合わせることで様々な組み合わせを作り出すことができます。別のコマンドをみてみましょう。</p>
<div><pre><code><span>></span> <span>ps</span>
╭─────┬──────┬──────────────────────┬─────────┬───────┬───────────┬──────────╮
│  <span>#  │ pid  │         name         │ status  │  cpu  │    mem    │ virtual  │</span>
├─────┼──────┼──────────────────────┼─────────┼───────┼───────────┼──────────┤
│   <span>0</span> │ <span>7570</span> │ nu                   │ Running │  <span>1.96</span> │  <span>23.2</span> MiB │ <span>32.8</span> GiB │
│   <span>1</span> │ <span>3533</span> │ remindd              │ Sleep   │  <span>0.00</span> │ <span>103.6</span> MiB │ <span>32.3</span> GiB │
│   <span>2</span> │ <span>3495</span> │ TVCacheExtension     │ Sleep   │  <span>0.00</span> │  <span>11.9</span> MiB │ <span>32.2</span> GiB │
│   <span>3</span> │ <span>3490</span> │ MusicCacheExtension  │ Sleep   │  <span>0.00</span> │  <span>12.9</span> MiB │ <span>32.2</span> GiB │
<span>..</span>.
</code></pre></div><p>もしあなたが Linux を利用しているなら<code>ps</code>コマンドには馴染みがあるでしょう。これを使うと、現在システムが実行しているすべてのプロセスの状態や名前の一覧を取得することができます。プロセスの CPU 負荷も確認することができます。</p>
<p>CPU をアクティブに利用しているプロセスを表示したい場合はどうでしょうか。さきほどの<code>ls</code>コマンドと同じように、<code>ps</code>コマンドが返すテーブルを利用することができます。</p>
<div><pre><code><span>></span> <span>ps</span> <span>|</span> where cpu <span>></span> <span>5</span>
╭───┬──────┬────────────────┬─────────┬────────┬───────────┬──────────╮
│ <span># │ pid  │      name      │ status  │  cpu   │    mem    │ virtual  │</span>
├───┼──────┼────────────────┼─────────┼────────┼───────────┼──────────┤
│ <span>0</span> │ <span>1583</span> │ Terminal       │ Running │  <span>20.69</span> │ <span>127.8</span> MiB │ <span>33.0</span> GiB │
│ <span>1</span> │  <span>579</span> │ photoanalysisd │ Running │ <span>139.50</span> │  <span>99.9</span> MiB │ <span>32.3</span> GiB │
╰───┴──────┴────────────────┴─────────┴────────┴───────────┴──────────╯
</code></pre></div><p>これまで、<code>ls</code>と<code>ps</code>を利用してファイルやプロセスの一覧を表示しました。Nu はこの他にも便利なテーブルを作り出すコマンドを提供します。次に<code>date</code>と<code>sys</code>をみてみましょう。</p>
<p><code>date now</code>を実行すると、現在の日時と時間に関する情報が得られます。</p>
<div><pre><code><span>></span> <span>date</span> now
<span>2022</span>-03-07 <span>14</span>:14:51.684619600 -08:00
</code></pre></div><p><code>sys</code>は Nu が実行されているシステムに関する情報を提供します。</p>
<div><pre><code><span>></span> sys
╭───────┬───────────────────╮
│ <span>host</span>  │ <span>{</span>record <span>6</span> fields<span>}</span> │
│ cpu   │ <span>[</span>table <span>4</span> rows<span>]</span>    │
│ disks │ <span>[</span>table <span>3</span> rows<span>]</span>    │
│ mem   │ <span>{</span>record <span>4</span> fields<span>}</span> │
│ temp  │ <span>[</span>table <span>1</span> row<span>]</span>     │
│ net   │ <span>[</span>table <span>4</span> rows<span>]</span>    │
╰───────┴───────────────────╯
</code></pre></div><p>これはさきほどまでのテーブルと少し異なります。<code>sys</code>コマンドは単純な値ではなくセルに構造化されたテーブルを含むテーブルを提供します。このデータを見るには表示する列を選択する必要があります。</p>
<div><pre><code><span>></span> sys <span>|</span> get <span>host</span>
╭────────────────┬────────────────────────╮
│ name           │ Debian GNU/Linux       │
│ os version     │ <span>11</span>                     │
│ kernel version │ <span>5.10</span>.92-v8+            │
│ <span>hostname</span>       │ lifeless               │
│ <span>uptime</span>         │ 19day 21hr 34min 45sec │
│ sessions       │ <span>[</span>table <span>1</span> row<span>]</span>          │
╰────────────────┴────────────────────────╯
</code></pre></div><p><code>get</code>コマンドを利用するとテーブルのカラムの内容を調べることができます。ここでは、Nu が実行されているホストに関する情報を含む&quot;host&quot;列を調べています。OS の名前、ホスト名、CPU などです。システム上のユーザーの名前を取得してみましょう。</p>
<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name
╭───┬────╮
│ <span>0</span> │ jt │
╰───┴────╯
</code></pre></div><p>現在、システムには&quot;jonathan&quot;という名前のユーザが１人だけいます。列の名前だけではなくパスも渡せることに気づくでしょう。Nu はパスを受け取るとテーブルの対応するデータを取得します。</p>
<p>テーブルデータではなく、文字列&quot;jonathan&quot;を取得したことに気づかれたかもしれません。Nu はテーブルだけでなく文字列も扱います。文字列は Nu 以外のコマンドを扱う上で重要な役割をはたします。</p>
<p>実際に Nu の外で文字列がどのように機能するか見てみましょう。先ほどの例で外部の<code>echo</code>コマンドを実行します。(<code>^</code>は組込みの<code>echo</code>コマンドを使用しないよう指示しています)。</p>
<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> ^echo <span>$it</span> <span>}</span>
jt
</code></pre></div><p>するどい読者にはこれが以前ものと似ていると思われるでしょう。しかし、さきほどの出力で<code>echo</code>を呼び出しているという重要な違いがあります。このように、Nu からデータを<code>echo</code>(または<code>git</code>のような Nu 以外の任意のコマンド)にわたすことができるのです。</p>
<p>注：Nu の組み込みコマンドのヘルプテキストは、<code>help</code>コマンドで検出できます。</p>
<div><pre><code><span>></span> <span>help</span> path
Explore and manipulate paths.

There are three ways to represent a path:

* As a path literal, e.g., <span>'/home/viking/spam.txt'</span>
* As a structured path: a table with <span>'parent'</span>, <span>'stem'</span>, and <span>'extension'</span> <span>(</span>and
* <span>'prefix'</span> on Windows<span>)</span> columns. This <span>format</span> is produced by the <span>'path parse'</span>
  subcommand.
* As an inner list of path parts, e.g., <span>'[[ / home viking spam.txt ]]'</span><span>.</span>
  Splitting into parts is <span>done</span> by the <span><span>`</span>path <span>split</span><span>`</span></span> command.

All subcommands accept all three variants as an input. Furthermore, the <span>'path
join'</span> subcommand can be used to <span>join</span> the structured path or path parts back into
the path literal.

Usage:
  <span>></span> path

Subcommands:
  path <span>basename</span> - Get the final component of a path
  path <span>dirname</span> - Get the parent directory of a path
  path exists - Check whether a path exists
  path <span>expand</span> - Try to <span>expand</span> a path to its absolute form
  path <span>join</span> - Join a structured path or a list of path parts.
  path parse - Convert a path into structured data.
  path relative-to - Get a path as relative to another path.
  path <span>split</span> - Split a path into parts by a separator.
  path <span>type</span> - Get the <span>type</span> of the object a path refers to <span>(</span>e.g., file, dir, symlink<span>)</span>

Flags:
  -h, --help
      Display this <span>help</span> message
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>データの読み込み</title>
      <link>www.nushell.sh/ja/book/loading_data.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/loading_data.html</guid>
      <source url="www.nushell.sh/rss.xml">データの読み込み</source>
      <content:encoded><![CDATA[<h1 id="データの読み込み" tabindex="-1"> データの読み込み</h1>
<p>これまでに、<code>ls</code>、<code>ps</code>、<code>date</code>、および<code>sys</code>コマンドを使って、ファイル、プロセス、日付そしてシステム自身の情報を取得する方法をみてきました。各コマンドはテーブル情報を提供しますが、他にもデータをテーブルに読み込む方法があります。</p>
<h2 id="ファイルを開く" tabindex="-1"> ファイルを開く</h2>
<p>データを操作するための Nu の最も強力なコマンドのひとつが<code>open</code>コマンドです。これは様々なデータ形式に対応したマルチツールです。これがなにを意味するかをみるために、json ファイルを開いてみましょう。</p>
<div><pre><code>> open editors/vscode/package.json
──────────────────┬───────────────────────────────────────────────────────────────────────────────
 name             │ lark
 description      │ Lark support for VS Code
 author           │ Lark developers
 license          │ MIT
 version          │ 1.0.0
 repository       │ [row type url]
 publisher        │ vscode
 categories       │ [table 0 rows]
 keywords         │ [table 1 rows]
 engines          │ [row vscode]
 activationEvents │ [table 1 rows]
 main             │ ./out/extension
 contributes      │ [row configuration grammars languages]
 scripts          │ [row compile postinstall test vscode:prepublish watch]
 devDependencies  │ [row @types/mocha @types/node tslint typescript vscode vscode-languageclient]
──────────────────┴───────────────────────────────────────────────────────────────────────────────
</code></pre></div><p><code>ls</code>と同様、Nu が理解できるタイプのファイルを開くと、単なるテキスト(またはバイトストリーム)以上のものが返ってきます。ここでは、JavaScript プロジェクト内の&quot;package.json&quot;ファイルを開いています。Nu は JSON テキストを認識し、テーブルデータを返すことができます。</p>
<p>プロジェクトのバージョンを確認したい場合は、<code>get</code>コマンドを利用します。</p>
<div><pre><code>> open editors/vscode/package.json | get version
1.0.0
</code></pre></div><p>Nu が現在、直接データをテーブルに読み込める形式は次の通りです。</p>
<ul>
<li>json</li>
<li>yaml</li>
<li>toml</li>
<li>xml</li>
<li>csv</li>
<li>ini</li>
</ul>
<p>しかし、これらのいずれでもないテキストファイルを読み込むとどうなるでしょうか、試してみましょう。</p>
<div><pre><code>> open README.md
</code></pre></div><p>ファイルの内容が表示されます。ファイルが大きすぎる場合は、便利なスクロールビューでファイルの中身を確認してからターミナルに戻ってることができます。読みやすさのために、ソースファイルやマークダウンといった一般的なファイル形式ではシンタックスハイライトを提供します。</p>
<p>裏側では、Nu はこれらのファイルをひとつの大きな文字列としてみています。次に、これらの文字列から必要なデータを取得する方法について説明します。</p>
<h2 id="文字列を扱う" tabindex="-1"> 文字列を扱う</h2>
<p>Nu の外からきたデータを Nu がいつも理解できるとは限らないことを理解しておくのは重要なことです。多くの場合このデータは文字列として与えられます。</p>
<p>以下のファイルが与えられたと想定してみましょう。</p>
<div><pre><code>> open people.txt
Octavia | Butler | Writer
Bob | Ross | Painter
Antonio | Vivaldi | Composer
</code></pre></div><p>必要なデータはパイプ('|')記号で区切られており、各行はそれぞれの人物を表しています。Nu はデフォルトではパイプで区切られたファイル形式を知らないので、明示的にこのファイルをパースする必要があります。</p>
<p>ファイルを読み込むときに最初に行うことは、１行ずつ作業することです。</p>
<div><pre><code>> open people.txt | lines
───┬──────────────────────────────
 0 │ Octavia | Butler | Writer
 1 │ Bob | Ross | Painter
 2 │ Antonio | Vivaldi | Composer
───┴──────────────────────────────
</code></pre></div><p>テーブルにもどってきたので、行を使って作業していることがわかります。次のステップは、行をもうすこし便利なものに分割できるかみてみることです。そのために、<code>split</code>コマンドを利用します。名前からわかるように、<code>split</code>は区切り文字を含む文字列を列に分割する方法を提供します。<code>split</code>の<code>column</code>サブコマンドを使って、複数の列に分割するします。必要なのは区切り文字を指定することだけです。</p>
<div><pre><code>> open people.txt | lines | split column "|"
───┬──────────┬───────────┬───────────
 # │ Column1  │ Column2   │ Column3
───┼──────────┼───────────┼───────────
 0 │ Octavia  │  Butler   │  Writer
 1 │ Bob      │  Ross     │  Painter
 2 │ Antonio  │  Vivaldi  │  Composer
───┴──────────┴───────────┴───────────
</code></pre></div><p>ほとんど正しいように見えますが、余分なスペースを含んでいます。余分なスペースを<code>trim</code>してみましょう。</p>
<div><pre><code>> open people.txt | lines | split column "|" | str trim
───┬─────────┬─────────┬──────────
 # │ Column1 │ Column2 │ Column3
───┼─────────┼─────────┼──────────
 0 │ Octavia │ Butler  │ Writer
 1 │ Bob     │ Ross    │ Painter
 2 │ Antonio │ Vivaldi │ Composer
───┴─────────┴─────────┴──────────
</code></pre></div><p>悪くありません。<code>split</code>コマンドは利用可能なデータとデフォルトのカラム名をつけてくれます。</p>
<div><pre><code>> open people.txt | lines | split column "|" | str trim | get Column1
───┬─────────
 0 │ Octavia
 1 │ Bob
 2 │ Antonio
───┴─────────
</code></pre></div><p>デフォルトの名前を利用するかわりに、列に名前をつけることもできます。</p>
<div><pre><code>> open people.txt | lines | split column "|" first_name last_name job | str trim
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Octavia    │ Butler    │ Writer
 1 │ Bob        │ Ross      │ Painter
 2 │ Antonio    │ Vivaldi   │ Composer
───┴────────────┴───────────┴──────────
</code></pre></div><p>データをテーブルに変換できたので、これまでテーブルに利用してきたすべてのコマンドをつかうことができます。</p>
<div><pre><code>> open people.txt | lines | split column "|" first_name last_name job | str trim | sort-by first_name
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Antonio    │ Vivaldi   │ Composer
 1 │ Bob        │ Ross      │ Painter
 2 │ Octavia    │ Butler    │ Writer
───┴────────────┴───────────┴──────────
</code></pre></div><p>文字列を操作するために使用できるその他のコマンドです。</p>
<ul>
<li>str</li>
<li>lines</li>
<li>size</li>
</ul>
<p>データが Nu が理解できる構造をもっていることがわかっている場合に呼び出すことのできるヘルパーコマンドのセットもあります。例えば、Rust のロックファイルを開いてみましょう。</p>
<div><pre><code>> open Cargo.lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
[[package]]
name = "adhoc_derive"
version = "0.1.2"
</code></pre></div><p>&quot;Cargo.lock&quot;ファイルは実際には.toml ファイルですが、ファイル拡張子が.toml ではありません。でも大丈夫です、<code>from toml</code>コマンドが使えます。</p>
<div><pre><code>> open Cargo.lock | from toml
──────────┬───────────────────
 metadata │ [row 107 columns]
 package  │ [table 130 rows]
──────────┴───────────────────
</code></pre></div><p><code>from</code>コマンドはサポートされているテキストフォーマットをサブコマンドとして渡すことで Nu が扱える構造化データごとに利用できます。</p>
<h2 id="raw-モードで開く" tabindex="-1"> raw モードで開く</h2>
<p>ファイルを開いてそのデータのテーブルをすぐに操作できると便利ですが、これは必ずしもやりたいことであるとは限りません。テキストをそのまま取得するために、<code>open</code>コマンドに<code>--raw</code>オプションフラグを渡すことができます。</p>
<div><pre><code>> open Cargo.toml --raw
[package]                                                                                        name = "nu"
version = "0.1.3"
authors = ["Yehuda Katz &lt;wycats@gmail.com>", "Jonathan Turner &lt;jonathan.d.turner@gmail.com>"]
description = "A shell for the GitHub era"
license = "MIT"
</code></pre></div><h2 id="url-からの取得" tabindex="-1"> URL からの取得</h2>
<p>ファイルシステムからファイルを読み込むことに加えて、<code>fetch</code>コマンドを利用して URL からリソースを取得できます。
これはインターネットから URL の内容をフェッチして返してくれます。</p>
<div><pre><code>> fetch https://www.jonathanturner.org/feed.xml
─────┬───────────────────────────
 rss │ [row attributes children]
─────┴───────────────────────────
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>Math</title>
      <link>www.nushell.sh/ja/book/math.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/math.html</guid>
      <source url="www.nushell.sh/rss.xml">Math</source>
      <content:encoded><![CDATA[<h1 id="math" tabindex="-1"> Math</h1>
<p>何かの作業をしているとき、いくつかの数字を足し算したくなるときがあります。Nu には基本的な数学演算が用意されています。</p>
<p>&quot;math mode&quot;にするには、コマンドの先頭に<code>=</code>をつけます。これにより演算子を使用するコマンドを書くことができます。<code>where</code>コマンドのように自動でおこなってくれるコマンドもあります。</p>
<h2 id="四則演算" tabindex="-1"> 四則演算</h2>
<div><pre><code>> = 1 + 3
4
</code></pre></div><p>Nu では足し算、引き算、掛け算、割り算をそれぞれ<code>+</code>,<code>-</code>,<code>*</code>そして<code>/</code>演算子でおこなうことができます。演算子の優先順位が考慮されるので<code>1 + 2 * 3</code>は<code>1 + (2 * 3)</code>として扱われます。</p>
<h2 id="括弧" tabindex="-1"> 括弧</h2>
<p>math mode では括弧を利用して数式をグループ化できます。これにより足し算を優先したいときは<code>(1 + 2) * 3</code>と書くことができます。</p>
<h2 id="inとnot-in" tabindex="-1"> <code>in</code>と<code>not-in</code></h2>
<p><code>in</code>と<code>not-in</code>演算子を使って、値が集合に含まれるかどうかを調べることができます。</p>
<div><pre><code>> = 1 in [1 2 3]
true
</code></pre></div><div><pre><code>> = 1 not-in [1 2 3]
false
</code></pre></div><h2 id="と" tabindex="-1"> <code>=~</code>と<code>!~</code></h2>
<p><code>=~</code>と<code>!~</code>演算子を使って文字列が他の文字列の中にあるかどうかを調べることができます。</p>
<div><pre><code>> = "foobar" =~ "foo"
true
</code></pre></div><div><pre><code>> = "foobar" !~ "baz"
true
</code></pre></div><h2 id="比較演算子" tabindex="-1"> 比較演算子</h2>
<p>以下の比較演算子が利用可能です。</p>
<ul>
<li><code>&lt;</code> - less than</li>
<li><code>&lt;=</code> - less than or equal to</li>
<li><code>&gt;</code> - greater than</li>
<li><code>&gt;=</code> - greater than or equal to</li>
<li><code>==</code> - equal to</li>
<li><code>!=</code> - not equal to</li>
</ul>
<h2 id="複合演算子" tabindex="-1"> 複合演算子</h2>
<p><code>&amp;&amp;</code>と<code>||</code>を使ってブーリアンを返す２つの操作を結合できます。例えば: <code>ls | where name in [&quot;one&quot; &quot;two&quot; &quot;three&quot;] &amp;&amp; size &gt; 10kb</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>メタデータ</title>
      <link>www.nushell.sh/ja/book/metadata.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/metadata.html</guid>
      <source url="www.nushell.sh/rss.xml">メタデータ</source>
      <content:encoded><![CDATA[<h1 id="メタデータ" tabindex="-1"> メタデータ</h1>
<p>Nu を使用していると裏でなにか特別なことがおきているのではないかと思うことがあるでしょう。例えば、Nu がサポートしているファイル形式を忘れていて、余計に変換しようとしてしまったとしましょう。</p>
<div><pre><code>> open Cargo.toml | from toml
error: Expected a string from pipeline
- shell:1:18
1 | open Cargo.toml | from toml
  |                   ^^^^^^^^^ requires string input
- shell:1:5
1 | open Cargo.toml | from toml
  |      ---------- object originates from here
</code></pre></div><p>エラーメッセージは、<code>from toml</code>に渡したものが文字列ではなかったことだけではなく、元の値がどこから来たかも示しています。どうやってこれを知るのでしょうか。</p>
<p>Nu のパイプラインを流れる値には、多くの場合、メタデータと呼ばれる一連の追加情報が付加されます。これらはストアにあるアイテムにつけられているタグのようにタグと呼ばれています。これらのタグはデータには影響しませんが、データを操作する際の体験を向上させます。</p>
<p>もう一度<code>open</code>コマンドを実行してみましょう、ただし今回は、返されるタグを確認します。</p>
<div><pre><code>> open Cargo.toml | tags
────────┬───────────────────────────────────────────
 span   │ [row end start]
 anchor │ /home/jonathant/Source/nushell/Cargo.toml
────────┴───────────────────────────────────────────
</code></pre></div><p>現在、パイプライン上の値について２つのメタデータを追跡しています。このデータがどこから読み込まれたかをしめす anchor があることに気づくでしょう。これにより Nu はデータの表示方法をよりよく理解できるのです。</p>
<p>今度は span をみてみましょう。</p>
<div><pre><code>> open Cargo.toml | tags | get span
───────┬────
 start │ 5
 end   │ 15
───────┴────
</code></pre></div><p>ここでの&quot;start&quot;と&quot;end&quot;の span は下線が行のどこにあるのかを示しています。5 から 15 まで数えてみるとそれが&quot;Cargo.toml&quot;ファイル名と一致することがわかるでしょう。このようにして、さきほどみたエラーはどこに下線をひくべきかをしったのです。</p>
]]></content:encoded>
    </item>
    <item>
      <title>システム内の移動</title>
      <link>www.nushell.sh/ja/book/moving_around.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/moving_around.html</guid>
      <source url="www.nushell.sh/rss.xml">システム内の移動</source>
      <content:encoded><![CDATA[<h1 id="システム内の移動" tabindex="-1"> システム内の移動</h1>
<p>初期のシェルを使うとシステム内を移動してコマンドを実行することができますが、Nu のような現代的なシェルでも同じことができます。システムを操作する際によく使われるコマンドをいくつか見てみましょう。</p>
<h2 id="ディレクトリの内容を確認する" tabindex="-1"> ディレクトリの内容を確認する</h2>
<div><pre><code><span>></span> <span>ls</span>
</code></pre></div><p>他の章でみてきたように、<code>ls</code>はパスの内容を表示するためのコマンドです。Nu はパスの内容をテーブルとして返してくれます。</p>
<p><code>ls</code>コマンドには表示する内容を変更するためにオプションで引数を渡すことができます。例えば&quot;.md&quot;で終わるファイルの一覧を表示することができます。glob&quot;*.md&quot;はファイルが'.md'で終わっていればマッチすると読むことができます。</p>
<div><pre><code><span>></span> <span>ls</span> *.md
───┬────────────────────┬──────┬─────────┬────────────
 <span># │ name               │ type │ size    │ modified </span>
───┼────────────────────┼──────┼─────────┼────────────
 <span>0</span> │ CODE_OF_CONDUCT.md │ File │  <span>3.4</span> KB │ <span>5</span> days ago 
 <span>1</span> │ CONTRIBUTING.md    │ File │   <span>886</span> B │ <span>5</span> days ago 
 <span>2</span> │ README.md          │ File │ <span>15.0</span> KB │ <span>5</span> days ago 
 <span>3</span> │ TODO.md            │ File │  <span>1.6</span> KB │ <span>5</span> days ago 
───┴────────────────────┴──────┴─────────┴────────────
</code></pre></div><p>上記のオプション引数&quot;*.txt&quot;の中で利用されているアスタリスク(*)はしばしばワイルドカードやグロブと呼ばれ、何にでもマッチします。グロブ&quot;*.txt&quot;は&quot;'.txt'で終わる任意のファイルにマッチする&quot;と読むことができます。</p>
<p>Nu はより深いディレクトリにアクセスできる最新のグロブも利用します。</p>
<div><pre><code> <span>ls</span> **/*.md
────┬───────────────────────────────────────────┬──────┬─────────┬────────────
 <span>#  │ name                                      │ type │ size    │ modified </span>
────┼───────────────────────────────────────────┼──────┼─────────┼────────────
  <span>0</span> │ .github/ISSUE_TEMPLATE/bug_report.md      │ File │   <span>592</span> B │ <span>5</span> days ago 
  <span>1</span> │ .github/ISSUE_TEMPLATE/feature_request.md │ File │   <span>595</span> B │ <span>5</span> days ago 
  <span>2</span> │ CODE_OF_CONDUCT.md                        │ File │  <span>3.4</span> KB │ <span>5</span> days ago 
  <span>3</span> │ CONTRIBUTING.md                           │ File │   <span>886</span> B │ <span>5</span> days ago 
  <span>4</span> │ README.md                                 │ File │ <span>15.0</span> KB │ <span>5</span> days ago 
  <span>5</span> │ TODO.md                                   │ File │  <span>1.6</span> KB │ <span>5</span> days ago 
  <span>6</span> │ crates/nu-source/README.md                │ File │  <span>1.7</span> KB │ <span>5</span> days ago 
  <span>7</span> │ docker/packaging/README.md                │ File │  <span>1.5</span> KB │ <span>5</span> days ago 
  <span>8</span> │ docs/commands/README.md                   │ File │   <span>929</span> B │ <span>5</span> days ago 
  <span>9</span> │ docs/commands/alias.md                    │ File │  <span>1.7</span> KB │ <span>5</span> days ago 
 <span>10</span> │ docs/commands/append.md                   │ File │  <span>1.4</span> KB │ <span>5</span> days ago
</code></pre></div><p>ここでは&quot;.md&quot;で終わるファイルを探していますが、２つのアスタリスクはさらに&quot;ここから始まる任意のディレクトリにある&quot;という意味です。</p>
<h2 id="現在のディレクトリを変更する" tabindex="-1"> 現在のディレクトリを変更する</h2>
<div><pre><code><span>></span> <span>cd</span> new_directory
</code></pre></div><p>現在のディレクトリを変更するには<code>cd</code>コマンドを使います。他のシェルと同じように、ディレクトリの名前か上の階層に移動する場合は<code>..</code>ショートカットを利用します。</p>
<p><code>cd</code>を省略してパスだけを指定することでも現在の作業ディレクトリを変更することができます。</p>
<div><pre><code><span>></span> ./new_directory
</code></pre></div><h2 id="ファイルシステムのコマンド" tabindex="-1"> ファイルシステムのコマンド</h2>
<p>Nu はクロスプラットフォームで動作するいくつかの基本的なファイルシステムのコマンドも提供します。</p>
<p><code>mv</code>コマンドを利用すればアイテムをある場所から別の場所へ移動できます。</p>
<div><pre><code><span>></span> <span>mv</span> item location
</code></pre></div><p>ある場所から別の場所へアイテムのコピーができます。</p>
<div><pre><code><span>></span> <span>cp</span> item location
</code></pre></div><p>アイテムの削除ができます。</p>
<div><pre><code><span>></span> <span>rm</span> item
</code></pre></div><p>３つのコマンドは<code>ls</code>コマンドでみたグロブ機能も利用できます。</p>
<p>最後に、<code>mkdir</code>コマンドで新しいディレクトリを作成できます。</p>
<div><pre><code><span>></span> <span>mkdir</span> new_directory
</code></pre></div>]]></content:encoded>
    </item>
    <item>
      <title>他のシェルと DSL から Nu への対応表</title>
      <link>www.nushell.sh/ja/book/nushell_map.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/nushell_map.html</guid>
      <source url="www.nushell.sh/rss.xml">他のシェルと DSL から Nu への対応表</source>
      <content:encoded><![CDATA[<h1 id="他のシェルと-dsl-から-nu-への対応表" tabindex="-1"> 他のシェルと DSL から Nu への対応表</h1>
<p>このテーブルは Nu の組込みコマンドやプラグインと他のシェルや DLS(Domain Specific Languages)との対応関係を理解することを助けるためのものです。ここでは全ての Nu コマンドとそのコマンドが他の言語でどう使われているかをマッピングしています。コントリビューション歓迎です。</p>
<p>注: Nu が 0.14.1 以降であることを想定しています。</p>
<table>
<thead>
<tr>
<th>Nushell</th>
<th>SQL</th>
<th>.Net LINQ (C#)</th>
<th>PowerShell (without external modules)</th>
<th>Bash</th>
</tr>
</thead>
<tbody>
<tr>
<td>alias</td>
<td>-</td>
<td>-</td>
<td>alias</td>
<td>alias</td>
</tr>
<tr>
<td>append</td>
<td>-</td>
<td>Append</td>
<td>-Append</td>
<td></td>
</tr>
<tr>
<td>args</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>autoview</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>average(<code>*</code>)</td>
<td>avg</td>
<td>Average</td>
<td>Measure-Object, measure</td>
<td></td>
</tr>
<tr>
<td>binaryview(<code>*</code>)</td>
<td>-</td>
<td></td>
<td>Format-Hex</td>
<td></td>
</tr>
<tr>
<td>calc, = math</td>
<td>math operators</td>
<td>Aggregate, Average, Count, Max, Min, Sum</td>
<td></td>
<td>bc</td>
</tr>
<tr>
<td>cd</td>
<td>-</td>
<td>-</td>
<td>Set-Location, cd</td>
<td>cd</td>
</tr>
<tr>
<td>clear</td>
<td>-</td>
<td>-</td>
<td>Clear-Host</td>
<td>clear</td>
</tr>
<tr>
<td>clip</td>
<td>-</td>
<td>-</td>
<td>Set-Clipboard, scb</td>
<td>clip, clipboard, xclip, pbcopy</td>
</tr>
<tr>
<td>compact</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>config</td>
<td>-</td>
<td>-</td>
<td>$Profile</td>
<td>vi .bashrc, .profile</td>
</tr>
<tr>
<td>count</td>
<td>count</td>
<td>Count</td>
<td>Measure-Object, measure</td>
<td>wc</td>
</tr>
<tr>
<td>cp</td>
<td>-</td>
<td>-</td>
<td>Copy-Item, cp, copy</td>
<td>cp</td>
</tr>
<tr>
<td>date</td>
<td>NOW() / getdate()</td>
<td>DateTime class</td>
<td>Get-Date</td>
<td>date</td>
</tr>
<tr>
<td>debug</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>= dec</td>
<td></td>
<td>x--</td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>drop</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>du</td>
<td>-</td>
<td>-</td>
<td></td>
<td>du</td>
</tr>
<tr>
<td>each</td>
<td>cursor</td>
<td></td>
<td>ForEach-Object, foreach, for</td>
<td></td>
</tr>
<tr>
<td>echo</td>
<td>print</td>
<td>-</td>
<td>Write-Output, write</td>
<td>echo</td>
</tr>
<tr>
<td>enter</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>evaluate_by</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>exit</td>
<td>-</td>
<td></td>
<td>exit</td>
<td>exit</td>
</tr>
<tr>
<td>fetch(<code>*</code>)</td>
<td>-</td>
<td>HttpClient,WebClient, HttpWebRequest/Response</td>
<td>Invoke-WebRequest</td>
<td>wget</td>
</tr>
<tr>
<td>first</td>
<td>top, limit</td>
<td>First, FirstOrDefault</td>
<td>Select-Object -First</td>
<td>head</td>
</tr>
<tr>
<td>format</td>
<td></td>
<td>String.Format</td>
<td>String.Format</td>
<td></td>
</tr>
<tr>
<td>from</td>
<td>import flatfile, openjson, cast(variable as xml)</td>
<td>-</td>
<td>Import/ConvertFrom-{Csv,Xml,Html,Json}</td>
<td></td>
</tr>
<tr>
<td>get</td>
<td></td>
<td>Select</td>
<td>(cmd).column</td>
<td></td>
</tr>
<tr>
<td>group_by</td>
<td>group by</td>
<td>GroupBy, group</td>
<td>Group-Object, group</td>
<td></td>
</tr>
<tr>
<td>headers</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>help</td>
<td>sp_help</td>
<td>-</td>
<td>Get-Help, help, man</td>
<td>man</td>
</tr>
<tr>
<td>histogram</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>history</td>
<td>-</td>
<td>-</td>
<td>Get-History, history</td>
<td>history</td>
</tr>
<tr>
<td>inc(<code>*</code>)</td>
<td>-</td>
<td></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>insert</td>
<td></td>
<td></td>
<td>Add-Member</td>
<td></td>
</tr>
<tr>
<td>is_empty</td>
<td>is null</td>
<td>String.InNullOrEmpty</td>
<td>String.InNullOrEmpty</td>
<td></td>
</tr>
<tr>
<td>keep, =take</td>
<td>top, limit</td>
<td>Take</td>
<td>Select-Object -First</td>
<td>head</td>
</tr>
<tr>
<td>keep_until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>keep_while</td>
<td></td>
<td>TakeWhile</td>
<td></td>
<td></td>
</tr>
<tr>
<td>kill</td>
<td>-</td>
<td>-</td>
<td>Stop-Process, kill</td>
<td>kill</td>
</tr>
<tr>
<td>last</td>
<td></td>
<td>Last, LastOrDefault</td>
<td>Select-Object -Last</td>
<td>tail</td>
</tr>
<tr>
<td>lines</td>
<td>-</td>
<td>-</td>
<td>File.ReadAllLines</td>
<td></td>
</tr>
<tr>
<td>ls</td>
<td>-</td>
<td>-</td>
<td>Get-ChildItem, dir, ls</td>
<td>ls</td>
</tr>
<tr>
<td>map_max_by</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>match(<code>*</code>)</td>
<td>case when</td>
<td>Regex.IsMatch</td>
<td>[regex]</td>
<td></td>
</tr>
<tr>
<td>merge</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mkdir</td>
<td>-</td>
<td>-</td>
<td>mkdir, md</td>
<td>mkdir</td>
</tr>
<tr>
<td>mv</td>
<td>-</td>
<td>-</td>
<td>Move-Item, mv, move, mi</td>
<td>mv</td>
</tr>
<tr>
<td>next</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nth</td>
<td>limit x offset y, rownumber =</td>
<td>ElementAt</td>
<td>[x], indexing operator, ElementAt</td>
<td></td>
</tr>
<tr>
<td>open</td>
<td></td>
<td></td>
<td>Get-Content, gc, cat, type</td>
<td>cat</td>
</tr>
<tr>
<td>parse</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pivot, =transpose</td>
<td>pivot</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>post(<code>*</code>)</td>
<td>-</td>
<td>HttpClient,WebClient, HttpWebRequest/Response</td>
<td>Invoke-WebRequest</td>
<td></td>
</tr>
<tr>
<td>prepend</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ps(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>Get-Process, ps, gps</td>
<td>ps</td>
</tr>
<tr>
<td>pwd</td>
<td>-</td>
<td>-</td>
<td>Get-Location, pwd</td>
<td>pwd</td>
</tr>
<tr>
<td>range</td>
<td></td>
<td>Range</td>
<td>1..10, 'a'..'f'</td>
<td></td>
</tr>
<tr>
<td>reduce_by</td>
<td></td>
<td>Aggregate</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reject</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rename</td>
<td>-</td>
<td>-</td>
<td>Rename-Item, ren, rni</td>
<td>mv</td>
</tr>
<tr>
<td>reverse</td>
<td></td>
<td>Reverse</td>
<td>[Array]::Reverse($var)</td>
<td></td>
</tr>
<tr>
<td>rm</td>
<td>-</td>
<td>-</td>
<td>Remove-Item, del, erase, rd, ri, rm, rmdir</td>
<td>rm</td>
</tr>
<tr>
<td>save</td>
<td>-</td>
<td>-</td>
<td>Write-Output, Out-File</td>
<td>&gt; foo.txt</td>
</tr>
<tr>
<td>select(<code>***</code>)</td>
<td>select</td>
<td>Select</td>
<td>Select-Object, select</td>
<td></td>
</tr>
<tr>
<td>shells</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>shuffle</td>
<td></td>
<td>Random</td>
<td>$var</td>
<td>Sort-Object {Get-Random}</td>
</tr>
<tr>
<td>size</td>
<td></td>
<td></td>
<td>Measure-Object, measure</td>
<td>wc</td>
</tr>
<tr>
<td>skip</td>
<td>where row_number()</td>
<td>Skip</td>
<td>Select-Object -Skip</td>
<td></td>
</tr>
<tr>
<td>skip_until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip_while</td>
<td></td>
<td>SkipWhile</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sort-by</td>
<td>order by</td>
<td>OrderBy, OrderByDescending, ThenBy, ThenByDescending</td>
<td>Sort-Object, sort</td>
<td></td>
</tr>
<tr>
<td>split_by</td>
<td></td>
<td>Split</td>
<td>Split</td>
<td></td>
</tr>
<tr>
<td>split_column</td>
<td></td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>split_row</td>
<td></td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>str(<code>*</code>)</td>
<td>string functions</td>
<td>String class</td>
<td>String class</td>
<td></td>
</tr>
<tr>
<td>sum</td>
<td>sum</td>
<td>Sum</td>
<td>Measure-Object, measure</td>
<td></td>
</tr>
<tr>
<td>sys(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>Get-ComputerInfo</td>
<td>uname, lshw, lsblk, lscpu, lsusb, hdparam, free</td>
</tr>
<tr>
<td>table</td>
<td></td>
<td></td>
<td>Format-Table, ft, Format-List, fl</td>
<td></td>
</tr>
<tr>
<td>tags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>textview(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>Get-Content, cat</td>
<td></td>
</tr>
<tr>
<td>tree(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>tree</td>
<td></td>
</tr>
<tr>
<td>to</td>
<td>-</td>
<td>-</td>
<td>Export/ConvertTo-{Csv,Xml,Html,Json}</td>
<td></td>
</tr>
<tr>
<td>touch</td>
<td>-</td>
<td>-</td>
<td>Set-Content</td>
<td>touch</td>
</tr>
<tr>
<td>trim</td>
<td>rtrim, ltrim</td>
<td>Trim, TrimStart, TrimEnd</td>
<td>Trim</td>
<td></td>
</tr>
<tr>
<td>uniq</td>
<td>distinct</td>
<td>Distinct</td>
<td>Get-Unique, gu</td>
<td>uniq</td>
</tr>
<tr>
<td>update(<code>**</code>)</td>
<td>As</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>version</td>
<td>select @@version</td>
<td>-</td>
<td>$PSVersionTable</td>
<td></td>
</tr>
<tr>
<td>with_env</td>
<td>-</td>
<td>-</td>
<td>$env:FOO = 'bar'</td>
<td>export foo = &quot;bar&quot;</td>
</tr>
<tr>
<td>what</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>where</td>
<td>where</td>
<td>Where</td>
<td>Where-Object, where, &quot;?&quot; operator</td>
<td></td>
</tr>
<tr>
<td>which</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>which</td>
</tr>
<tr>
<td>wrap</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><code>*</code> - these commands are part of the standard plugins</li>
<li><code>**</code> - renamed from <code>edit</code> to <code>update</code> in 0.13.1</li>
<li><code>***</code> - renamed from <code>pick</code> to <code>select</code> in 0.13.1</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>関数型言語から Nu への対応表</title>
      <link>www.nushell.sh/ja/book/nushell_map_functional.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/nushell_map_functional.html</guid>
      <source url="www.nushell.sh/rss.xml">関数型言語から Nu への対応表</source>
      <content:encoded><![CDATA[<h1 id="関数型言語から-nu-への対応表" tabindex="-1"> 関数型言語から Nu への対応表</h1>
<p>このテーブルは Nu の組込みコマンドやプラグインと他の関数型言語との対応関係を理解することを助けるためのものです。ここでは全ての Nu コマンドとそのコマンドが他の言語でどう使われているかをマッピングしています。コントリビューション歓迎です。</p>
<p>注: Nu が 0.14.1 以降であることを想定しています。</p>
<p>| Nushell           | Clojure                      | Tablecloth (Ocaml / Elm)        | Haskell                  |
| ----------------- | ---------------------------- | ------------------------------- | ------------------------ | --- |
| alias             |                              |                                 |                          |     |
| append            | conj, into, concat           | append, (++), concat, concatMap | (++)                     |     |
| args              |                              |                                 |                          |     |
| autoview          |                              |                                 |                          |     |
| average(<code>*</code>)      |                              |                                 |                          |     |
| binaryview(<code>*</code>)   | Integer/toHexString          |                                 | showHex                  |     |
| calc, = math      | math operators               |                                 |                          |     |
| cd                |                              |                                 |                          |     |
| clear             |                              |                                 |                          |     |
| clip              |                              |                                 |                          |     |
| compact           |                              |                                 |                          |     |
| config            |                              |                                 |                          |     |
| count             | count                        | length, size                    | length, size             |     |
| cp                |                              |                                 |                          |     |
| date              | java.time.LocalDate/now      |                                 |                          |     |
| debug             |                              |                                 |                          |     |
| default           |                              |                                 |                          |     |
| drop              |                              |                                 |                          |     |
| du                |                              |                                 |                          |     |
| each              | map, mapv, iterate           | map, forEach                    | map                      |     |
| echo              | println                      |                                 | putStrLn, print          |     |
| enter             |                              |                                 |                          |     |
| evaluate_by       |                              |                                 |                          |     |
| exit              | System/exit                  |                                 |                          |     |
| fetch(<code>*</code>)        |                              |                                 |                          |     |
| first             | first                        | head                            | head                     |     |
| format            | format                       |                                 | Text.Printf.printf       |     |
| from              |                              |                                 |                          |     |
| get               |                              |                                 |                          |     |
| group_by          | group-by                     |                                 | group, groupBy           |     |
| headers           |                              |                                 |                          |     |
| help              | doc                          |                                 |                          |     |
| histogram         |                              |                                 |                          |     |
| history           |                              |                                 |                          |     |
| inc(<code>*</code>)          | inc                          |                                 | succ                     |     |
| insert            |                              |                                 |                          |     |
| is_empty          | empty?                       | isEmpty                         |                          |     |
| keep              | take, drop-last, pop         | take, init                      | take, init               |     |
| keep_until        |                              |                                 |                          |     |
| keep_while        | take-while                   | takeWhile                       | takeWhile                |     |
| kill              |                              |                                 |                          |     |
| last              | last, peek, take-last        | last                            | last                     |     |
| lines             |                              |                                 | lines, words, split-with |     |
| ls                |                              |                                 |                          |     |
| map_max_by        |                              |                                 |                          |     |
| match(<code>*</code>)        | re-matches, re-seq, re-find  |                                 |                          |     |
| merge             |                              |                                 |                          |     |
| mkdir             |                              |                                 |                          |     |
| mv                |                              |                                 |                          |     |
| next              |                              |                                 |                          |     |
| nth               | nth                          | Array.get                       | lookup                   |     |
| open              | with-open                    |                                 |                          |     |
| parse             |                              |                                 |                          |     |
| pivot, =transpose | (apply mapv vector matrix)   |                                 | transpose                |     |
| post(<code>*</code>)         |                              |                                 |                          |     |
| prepend           | cons                         | cons, ::                        | ::                       |     |
| prev              |                              |                                 |                          |     |
| ps(<code>*</code>)           |                              |                                 |                          |     |
| pwd               |                              |                                 |                          |     |
| range             | range                        | range                           | 1..10, 'a'..'f'          |     |
| reduce_by         | reduce, reduce-kv            | foldr                           | foldr                    |     |
| reject            |                              |                                 |                          |     |
| rename            |                              |                                 |                          |     |
| reverse           | reverse, rseq                | reverse, reverseInPlace         | reverse                  |     |
| rm                |                              |                                 |                          |     |
| save              |                              |                                 |                          |     |
| select(<code>***</code>)     | select-keys                  |                                 |                          |     |
| shells            |                              |                                 |                          |     |
| shuffle           | shuffle                      |                                 |                          |     |
| size              | count                        |                                 | size, length             |     |
| skip              | rest                         | tail                            | tail                     |     |
| skip_until        |                              |                                 |                          |     |
| skip_while        | drop-while                   | dropWhile                       | dropWhile, dropWhileEnd  |     |
| sort-by           | sort, sort-by, sorted-set-by | sort, sortBy, sortWith          | sort, sortBy             |     |
| split_by          | split, split-{at,with,lines} | split, words, lines             | split, words, lines      |     |
| split_column      |                              |                                 |                          |     |
| split_row         |                              |                                 |                          |     |
| str(<code>*</code>)          | clojure.string functions     | String functions                |                          |     |
| sum               | apply +                      | sum                             | sum                      |     |
| sys(<code>*</code>)          |                              |                                 |                          |     |
| table             |                              |                                 |                          |     |
| tags              |                              |                                 |                          |     |
| textview(<code>*</code>)     |                              |                                 |                          |     |
| tree(<code>*</code>)         |                              |                                 |                          |     |
| to                |                              |                                 |                          |     |
| touch             |                              |                                 |                          |     |
| trim              | trim, triml, trimr           | trim, trimLeft, trimRight       | strip                    |     |
| uniq              | set                          | Set.empty                       | Data.Set                 |     |
| update(<code>**</code>)      |                              |                                 |                          |     |
| version           |                              |                                 |                          |     |
| with_env          |                              |                                 |                          |     |
| what              |                              |                                 |                          |     |
| where             | filter, filterv, select      | filter, filterMap               | filter                   |     |
| which             |                              |                                 |                          |     |
| wrap              |                              |                                 |                          |     |</p>
<ul>
<li><code>*</code> - these commands are part of the standard plugins</li>
<li><code>**</code> - renamed from <code>edit</code> to <code>update</code> in 0.13.1</li>
<li><code>***</code> - renamed from <code>pick</code> to <code>select</code> in 0.13.1</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令形言語から Nu への対応表</title>
      <link>www.nushell.sh/ja/book/nushell_map_imperative.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/nushell_map_imperative.html</guid>
      <source url="www.nushell.sh/rss.xml">命令形言語から Nu への対応表</source>
      <content:encoded><![CDATA[<h1 id="命令形言語から-nu-への対応表" tabindex="-1"> 命令形言語から Nu への対応表</h1>
<p>このテーブルは Nu の組込みコマンドやプラグインと他の命令型言語との対応関係を理解することを助けるためのものです。ここでは全ての Nu コマンドとそのコマンドが他の言語でどう使われているかをマッピングしています。コントリビューション歓迎です。</p>
<p>注: Nu が 0.14.1 以降であることを想定しています。</p>
<table>
<thead>
<tr>
<th>Nushell</th>
<th>Python</th>
<th>Kotlin (Java)</th>
<th>C++</th>
<th>Rust</th>
</tr>
</thead>
<tbody>
<tr>
<td>alias</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>append</td>
<td>list.append, set.add</td>
<td>add</td>
<td>push_back, emplace_back</td>
<td>push, push_back</td>
</tr>
<tr>
<td>args</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>autoview</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>average(<code>*</code>)</td>
<td>statistics.mean</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>binaryview(<code>*</code>)</td>
<td>&quot;{:x}&quot;.format</td>
<td>Integer.toHexString</td>
<td></td>
<td></td>
</tr>
<tr>
<td>calc, = math</td>
<td>math operators</td>
<td>math operators</td>
<td>math operators</td>
<td>math operators</td>
</tr>
<tr>
<td>cd</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>clear</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>clip</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>compact</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>config</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>count</td>
<td>len</td>
<td>size, length</td>
<td>length</td>
<td>len</td>
</tr>
<tr>
<td>cp</td>
<td>shutil.copy</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>datetime.date.today</td>
<td>java.time.LocalDate.now</td>
<td></td>
<td></td>
</tr>
<tr>
<td>debug</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>drop</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>du</td>
<td>shutil.disk_usage</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>each</td>
<td>for</td>
<td>for</td>
<td>for</td>
<td>for</td>
</tr>
<tr>
<td>echo</td>
<td>print</td>
<td>println</td>
<td>printf</td>
<td>println!</td>
</tr>
<tr>
<td>enter</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>evaluate_by</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>exit</td>
<td>exit</td>
<td>System.exit, kotlin.system.exitProcess</td>
<td>exit</td>
<td>exit</td>
</tr>
<tr>
<td>fetch(<code>*</code>)</td>
<td>urllib.request.urlopen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>first</td>
<td>list[0]</td>
<td>List[0], peek</td>
<td>vector[0], top</td>
<td>Vec[0]</td>
</tr>
<tr>
<td>format</td>
<td>format</td>
<td>format</td>
<td>format</td>
<td>format!</td>
</tr>
<tr>
<td>from</td>
<td>csv, json, sqlite3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>get</td>
<td>dict[&quot;key&quot;]</td>
<td>Map[&quot;key&quot;]</td>
<td>map[&quot;key&quot;]</td>
<td>HashMap[&quot;key&quot;], get, entry</td>
</tr>
<tr>
<td>group_by</td>
<td>itertools.groupby</td>
<td>groupBy</td>
<td></td>
<td>group_by</td>
</tr>
<tr>
<td>headers</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>help</td>
<td>help</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>histogram</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>history</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>inc(<code>*</code>)</td>
<td>x += 1</td>
<td>x++</td>
<td>x++</td>
<td>x += 1</td>
</tr>
<tr>
<td>insert</td>
<td>list.insert</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>is_empty</td>
<td>is None</td>
<td>isEmpty</td>
<td>empty</td>
<td>is_empty</td>
</tr>
<tr>
<td>keep</td>
<td>list[:x]</td>
<td></td>
<td></td>
<td>&amp;Vec[..x]</td>
</tr>
<tr>
<td>keep_until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>keep_while</td>
<td>itertools.takewhile</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>kill</td>
<td>os.kill</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>last</td>
<td>list[-1]</td>
<td></td>
<td></td>
<td>&amp;Vec[Vec.len()-1]</td>
</tr>
<tr>
<td>lines</td>
<td>split, splitlines</td>
<td>split</td>
<td>views::split</td>
<td>split, split_whitespace, rsplit, lines</td>
</tr>
<tr>
<td>ls</td>
<td>os.listdir</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>map_max_by</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>match(<code>*</code>)</td>
<td>re.findall</td>
<td>Regex.matches</td>
<td>regex_match</td>
<td></td>
</tr>
<tr>
<td>merge</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mkdir</td>
<td>os.mkdir</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mv</td>
<td>shutil.move</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>next</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nth</td>
<td>list[x]</td>
<td>List[x]</td>
<td>vector[x]</td>
<td>Vec[x]</td>
</tr>
<tr>
<td>open</td>
<td>open</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>parse</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pivot, =transpose</td>
<td>zip(*matrix)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>post(<code>*</code>)</td>
<td>urllib.request.urlopen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>prepend</td>
<td>deque.appendleft</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ps(<code>*</code>)</td>
<td>os.listdir('/proc')</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pwd</td>
<td>os.getcwd</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>range</td>
<td>.., until, downTo, step</td>
<td>iota</td>
<td>..</td>
</tr>
<tr>
<td>reduce_by</td>
<td>functools.reduce</td>
<td>reduce</td>
<td>reduce</td>
<td>fold, rfold, scan</td>
</tr>
<tr>
<td>reject</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rename</td>
<td>shutil.move</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reverse</td>
<td>reversed, list.reverse</td>
<td>reverse, reversed, asReversed</td>
<td>reverse</td>
<td>rev</td>
</tr>
<tr>
<td>rm</td>
<td>os.remove</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>save</td>
<td>io.TextIOWrapper.write</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>select(<code>***</code>)</td>
<td>{k:dict[k] for k in keylist}</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>shells</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>shuffle</td>
<td>random.shuffle</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>len</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>list[x:]</td>
<td></td>
<td></td>
<td>&amp;Vec[x..]</td>
</tr>
<tr>
<td>skip_until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip_while</td>
<td>itertools.dropwhile</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sort-by</td>
<td>sorted, list.sort</td>
<td>sortedBy, sortedWith, Arrays.sort, Collections.sort</td>
<td>sort</td>
<td>sort</td>
</tr>
<tr>
<td>split_by</td>
<td>str.split{,lines}, re.split</td>
<td>split</td>
<td>views::split</td>
<td>split</td>
</tr>
<tr>
<td>split_column</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>split_row</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>str(<code>*</code>)</td>
<td>str functions</td>
<td>String functions</td>
<td>string functions</td>
<td>&amp;str, String functions</td>
</tr>
<tr>
<td>sum</td>
<td>sum</td>
<td>sum</td>
<td>reduce</td>
<td>sum</td>
</tr>
<tr>
<td>sys(<code>*</code>)</td>
<td>sys</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>table</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>textview(<code>*</code>)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tree(<code>*</code>)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>to</td>
<td>csv, json, sqlite3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>touch</td>
<td>open(path, 'a').close()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>trim</td>
<td>strip, rstrip, lstrip</td>
<td>trim, trimStart, trimEnd</td>
<td>regex</td>
<td>trim, trim*{start,end}, strip*{suffix,prefix}</td>
</tr>
<tr>
<td>uniq</td>
<td>set</td>
<td>Set</td>
<td>set</td>
<td>HashSet</td>
</tr>
<tr>
<td>update(<code>**</code>)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>version</td>
<td>sys.version, sys.version_info</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>with_env</td>
<td>os.environ</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>what</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>where</td>
<td>filter</td>
<td>filter</td>
<td>filter</td>
<td>filter</td>
</tr>
<tr>
<td>which</td>
<td>shutil.which</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>wrap</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><code>*</code> - these commands are part of the standard plugins</li>
<li><code>**</code> - renamed from <code>edit</code> to <code>update</code> in 0.13.1</li>
<li><code>***</code> - renamed from <code>pick</code> to <code>select</code> in 0.13.1</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Nushell 演算子対応表</title>
      <link>www.nushell.sh/ja/book/nushell_operator_map.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/nushell_operator_map.html</guid>
      <source url="www.nushell.sh/rss.xml">Nushell 演算子対応表</source>
      <content:encoded><![CDATA[<h1 id="nushell-演算子対応表" tabindex="-1"> Nushell 演算子対応表</h1>
<p>このテーブルは Nu の演算子と他言語の演算子の対応関係を理解するのを助けるためのものです。ここでは全ての Nu の演算子とその演算子が他の言語でどう使われているかをマッピングしています。コントリビューション歓迎です。</p>
<p>注: Nu が 0.14.1 以降であることを想定しています。</p>
<table>
<thead>
<tr>
<th>Nushell</th>
<th>SQL</th>
<th>Python</th>
<th>.Net LINQ (C#)</th>
<th>PowerShell</th>
<th>Bash</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>=</td>
<td>==</td>
<td>==</td>
<td>-eq, -is</td>
<td>-eq</td>
</tr>
<tr>
<td>!=</td>
<td>!=, &lt;&gt;</td>
<td>!=</td>
<td>!=</td>
<td>-ne, -isnot</td>
<td>-ne</td>
</tr>
<tr>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>-lt</td>
<td>-lt</td>
</tr>
<tr>
<td>&lt;=</td>
<td>&lt;=</td>
<td>&lt;=</td>
<td>&lt;=</td>
<td>-le</td>
<td>-le</td>
</tr>
<tr>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>-gt</td>
<td>-gt</td>
</tr>
<tr>
<td>&gt;=</td>
<td>&gt;=</td>
<td>&gt;=</td>
<td>&gt;=</td>
<td>-ge</td>
<td>-ge</td>
</tr>
<tr>
<td>=~</td>
<td>like</td>
<td>re, in, startswith</td>
<td>Contains, StartsWith</td>
<td>-like, -contains</td>
<td>=~</td>
</tr>
<tr>
<td>!~</td>
<td>not like</td>
<td>not in</td>
<td>Except</td>
<td>-notlike, -notcontains</td>
<td>! &quot;str1&quot; =~ &quot;str2&quot;</td>
</tr>
<tr>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>/</td>
<td>/</td>
<td>/</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>in</td>
<td>in</td>
<td>re, in, startswith</td>
<td>Contains, StartsWith</td>
<td>-In</td>
<td>case in</td>
</tr>
<tr>
<td>not-in</td>
<td>not in</td>
<td>not in</td>
<td>Except</td>
<td>-NotIn</td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>and</td>
<td>and</td>
<td>&amp;&amp;</td>
<td>-And</td>
<td>-a, &amp;&amp;</td>
</tr>
<tr>
<td>||</td>
<td>or</td>
<td>or</td>
<td>||</td>
<td>-Or</td>
<td>-o, ||</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>パイプライン</title>
      <link>www.nushell.sh/ja/book/pipeline.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/pipeline.html</guid>
      <source url="www.nushell.sh/rss.xml">パイプライン</source>
      <content:encoded><![CDATA[<h1 id="パイプライン" tabindex="-1"> パイプライン</h1>
<p>Nu のコアデザインのひとつがパイプラインです。パイプラインは Unix の背後にある哲学にまでそのルーツを遡ることができるデザインアイデアです。Nu は、Unix の文字列データを拡張したように、パイプラインの概念も拡張してテキスト以外のものも扱えるようにします。</p>
<h2 id="基礎" tabindex="-1"> 基礎</h2>
<p>パイプラインは、入力、フィルター、出力の３つの部分から構成されます。</p>
<div><pre><code>> open "Cargo.toml" | inc package.version | save "Cargo_new.toml"
</code></pre></div><p>最初のコマンド<code>open &quot;Cargo.toml&quot;</code>が入力です(しばしば&quot;source&quot;や&quot;producer&quot;と呼ばれます)。これによりデータが作成またはロードされパイプラインに送られます。パイプラインは入力から渡された値を扱います。<code>ls</code>のようなコマンドも入力です。ファイルシステムからデータを取得し、パイプラインを経由して扱えるようにするからです。</p>
<p>２番目のコマンド<code>inc package.version</code>はフィルターです。フィルターは与えられたデータをうけとると大抵の場合はなにかします。それは変更(<code>inc</code>コマンドの例のように)であったり、ロギングなどの別の操作かもしれません。</p>
<p>最後のコマンド<code>save &quot;Cargo_new.toml&quot;</code>が出力です(&quot;sink&quot;と呼ばれることもあります)。出力はパイプラインから入力を受け取り、最終的な操作を実行します。この例では、最終ステップとして、パイプラインを介しておくられてきたものをファイルに保存しています。他の出力コマンドとしては、値をうけとりユーザのために表示するものがあります。</p>
<h2 id="外部コマンドの使用" tabindex="-1"> 外部コマンドの使用</h2>
<p>Nu のコマンドは互いに Nu のデータ型(<a href="/ja/book/types_of_data.html">types of data</a>を参照してください)を利用してやりとりします。しかし、Nu 以外のコマンドはどうでしょうか。外部コマンドの使用例をみてみましょう。</p>
<p><code>internal_command | external_command</code></p>
<p>データは内部コマンドから外部コマンドにむかって流れます。このデータは文字列であることが期待されるので、外部コマンドの<code>stdin</code>に送られます。</p>
<p><code>external_command | internal_command</code></p>
<p>外部コマンドから Nu に送られるデータは単一の文字列にまとめられ、内部コマンドに渡されます。<code>lines</code>のようなコマンドは外部からのデータを取り込む際に便利です。</p>
<p><code>external_command_1 | external_command_2</code></p>
<p>Nu は Bash のような他のシェルと同じように２つの外部コマンドでパイプされるデータを処理します。外部コマンド１の<code>stdout</code>は外部コマンド２の<code>stdin</code>につながれます。これにより２つのコマンドの間でデータは自然にやりとりされます。</p>
<h2 id="内部の仕組み" tabindex="-1"> 内部の仕組み</h2>
<p><code>ls</code>が出力ではなく入力の場合、テーブルがどのように表示されるのか疑問に思われるかもしれません。Nu は<code>autoview</code>とよばれるコマンドを自動的に出力に加えます。<code>autoview</code>コマンドは結果を確認できる出力をもたないパイプラインに追加されるのです。</p>
<p>実質的にこのコマンドと</p>
<div><pre><code>> ls
</code></pre></div><p>このパイプラインは</p>
<div><pre><code>> ls | autoview
</code></pre></div><p>同じものです。</p>
]]></content:encoded>
    </item>
    <item>
      <title>プラグイン</title>
      <link>www.nushell.sh/ja/book/plugins.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/plugins.html</guid>
      <source url="www.nushell.sh/rss.xml">プラグイン</source>
      <content:encoded><![CDATA[<h1 id="プラグイン" tabindex="-1"> プラグイン</h1>
<p>プラグインを用いることで Nu の機能を拡張することができます。プラグインは、Nu の組み込みコマンドと同じ操作の多くを実行することができ、Nu 本体とは別に追加できるという利点もあります。</p>
<p>プラグインを追加するには、ビルドして PATH にバイナリーを配置するだけです。Nu のプラグインは、PATH 内の他のバイナリーと区別できるように<code>nu_plugin_</code>というファイル名ではじまります。</p>
<p><strong>注:</strong> 将来的には、プラグインは Nu がみつけられるように特定の場所に配置されることになるかもしれません。</p>
<p>Nu が起動すると、システムがスキャンされ、見つかったプラグインがロードされます。</p>
<p>Nu プラグインが利用するプロトコルは Nu の開発中に変更される可能性があります。プロトコルの詳細と独自のプラグインの作成方法を学ぶのに最適なのは、<a href="https://github.com/nushell/nushell/tree/master/crates" target="_blank" rel="noopener noreferrer">Nu リポジトリのプラグインのソース</a>を読むことです。
<a href="https://github.com/nushell/contributor-book/blob/master/en/plugins.md" target="_blank" rel="noopener noreferrer">コントリビュータブックのプラグインの章</a>も参照してください。</p>
]]></content:encoded>
    </item>
    <item>
      <title>シェルの中のシェル</title>
      <link>www.nushell.sh/ja/book/shells_in_shells.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/shells_in_shells.html</guid>
      <source url="www.nushell.sh/rss.xml">シェルの中のシェル</source>
      <content:encoded><![CDATA[<h1 id="シェルの中のシェル" tabindex="-1"> シェルの中のシェル</h1>
<h2 id="複数のディレクトリで作業する" tabindex="-1"> 複数のディレクトリで作業する</h2>
<p>ひとつのディレクトリで作業することが一般的ですが、同時に複数の場所で作業できれば便利です。このため、Nu は&quot;shells&quot;という概念を提供します。その名の通り、これらは同じ場所で複数のシェルを実行する方法であり、作業ディレクトリ間をすばやく移動することができます。</p>
<p>まずはじめに、ディレクトリを入力しましょう。</p>
<div><pre><code>/home/jonathant/Source/nushell(master)> enter ../book
/home/jonathant/Source/book(master)> ls
────┬────────────────────┬──────┬────────┬─────────────
 #  │ name               │ type │ size   │ modified
────┼────────────────────┼──────┼────────┼─────────────
  0 │ 404.html           │ File │  429 B │ 2 hours ago
  1 │ CONTRIBUTING.md    │ File │  955 B │ 2 hours ago
  2 │ Gemfile            │ File │ 1.1 KB │ 2 hours ago
  3 │ Gemfile.lock       │ File │ 6.9 KB │ 2 hours ago
</code></pre></div><p><code>enter</code>はディレクトリの変更に似ています(<code>cd</code>コマンドでみたように)。これによりディレクトリにジャンプして作業することができます。ディレクトリを変更するかわりに、２つのディレクトリに移動しました。このことをより明確にするために、<code>shells</code>コマンドを実行して、アクティブな現在のディレクトリの一覧を表示してみましょう。</p>
<div><pre><code>/home/jonathan/Source/book(master)> shells
───┬────────┬────────────┬─────────────────────────────────
 # │ active │ name       │ path
───┼────────┼────────────┼─────────────────────────────────
 0 │        │ filesystem │ /home/jonathant/Source/nushell/
 1 │ X      │ filesystem │ /home/jonathant/Source/book
───┴────────┴────────────┴─────────────────────────────────
</code></pre></div><p><code>shells</code>コマンドは現在２つのシェルがアクティブであることを示しています。もともといた&quot;nushell&quot;のソースディレクトリと新しい&quot;book&quot;ディレクトリです。</p>
<p>&quot;next&quot;と&quot;previous&quot;のショートカットである<code>n</code>と<code>p</code>を利用して、両者のシェルを行き来できます。</p>
<div><pre><code>/home/jonathant/Source/book(master)> n
/home/jonathant/Source/nushell(master)> p
/home/jonathant/Source/book(master)>
</code></pre></div><p>ディレクトリを変更できることがわかります。そしていつでも元いた作業ディレクトリに戻ることができるのです。これにより、同じセッションにいながら複数のディレクトリで作業できます。</p>
<h2 id="シェルを終了する" tabindex="-1"> シェルを終了する</h2>
<p><code>exit</code>コマンドを利用して<code>enter</code>したシェルを終了することができます。もし最後のシェルを終了したときは Nu が終了します。</p>
<p><code>exit --now</code>のように、<code>--now</code>フラグを<code>exit</code>コマンドに渡すことで、複数のシェルがアクティブな場合でもすぐに Nu を終了することができます。 こんなふうに: <code>exit --now</code></p>
<h2 id="ディレクトリを超えて" tabindex="-1"> ディレクトリを超えて</h2>
<p>Nu はファイルシステムのパスとは別に、他のものからシェルを作ることもできます。たとえば、大規模なデータセットを使用していて、その中の場所を失いたくないとしましょう。</p>
<p>これがどのように機能するかを見るために、次の演習を行いましょう。現在、&quot;Cargo.toml&quot;ファイルの中に開発した<a href="/ja/book/plugins.html">Nu プラグイン</a>をリストしています。src/plugins ディレクトリの中に&quot;doc.rs&quot;とよばれる新しいプラグインを作成したので、正しくコンパイルされインストールされるか確認したいので&quot;Cargo.toml&quot;にリストされているか知りたいとしましょう。</p>
<p>Nu のソースコードから&quot;Cargo.toml&quot;ファイルに<code>enter</code>してみましょう。</p>
<div><pre><code>/home/jonathant/Source/nushell(master)> enter Cargo.toml
/> ls
────────────────────┬───────────────────────────
 bin                │ [table 18 rows]
 build-dependencies │ [row nu-build serde toml]
 dependencies       │ [row 29 columns]
 dev-dependencies   │ [row nu-test-support]
 features           │ [row 19 columns]
 package            │ [row 12 columns]
 workspace          │ [row members]
────────────────────┴───────────────────────────
</code></pre></div><p>今のところ、ファイルに<code>enter</code>し、<code>ls</code>から得られたテーブルで中身を確認できます。注意深くみてみると、今回は Nu が理解できる(.toml)ファイル形式にエンターしていることがわかります。Nu はファイルの中身をファイルシステムのように表示するので、あたかも通常のファイルシステムのように内容を確認することができます。</p>
<p>続きを始める前に、アクティブなシェルを確認しておきましょう。</p>
<div><pre><code>> shells
───┬────────┬─────────────────────────────────────────────┬─────────────────────────────────
 # │ active │ name                                        │ path
───┼────────┼─────────────────────────────────────────────┼─────────────────────────────────
 0 │        │ filesystem                                  │ /home/jonathant/Source/nushell/
 1 │ X      │ {/home/jonathant/Source/nushell/Cargo.toml} │ /
───┴────────┴─────────────────────────────────────────────┴─────────────────────────────────
</code></pre></div><p>２つのアクティブなシェルがあり、&quot;Cargo.toml&quot;内のデフォルトのルートパスである&quot;/&quot;にいることがわかります。内容をもう一度表示してみましょう。</p>
<div><pre><code>/> ls
────────────────────┬───────────────────────────
 bin                │ [table 18 rows]
 build-dependencies │ [row nu-build serde toml]
 dependencies       │ [row 29 columns]
 dev-dependencies   │ [row nu-test-support]
 features           │ [row 19 columns]
 package            │ [row 12 columns]
 workspace          │ [row members]
────────────────────┴───────────────────────────
</code></pre></div><p>今探しているのは、&quot;bin&quot;列の中なので、そこにいってみましょう。</p>
<div><pre><code>> cd bin
/bin> ls
────┬─────────────────────────────┬────────────────────────────────────────────┬───────────────────
 #  │ name                        │ path                                       │ required-features
────┼─────────────────────────────┼────────────────────────────────────────────┼───────────────────
  0 │ fail                        │ crates/nu-test-support/src/bins/fail.rs    │ [table 1 rows]
  1 │ chop                        │ crates/nu-test-support/src/bins/chop.rs    │ [table 1 rows]
  2 │ cococo                      │ crates/nu-test-support/src/bins/cococo.rs  │ [table 1 rows]
  3 │ nonu                        │ crates/nu-test-support/src/bins/nonu.rs    │ [table 1 rows]
  4 │ iecho                       │ crates/nu-test-support/src/bins/iecho.rs   │ [table 1 rows]
  5 │ nu_plugin_core_textview     │ src/plugins/nu_plugin_core_textview.rs     │ [table 1 rows]
</code></pre></div><p>ここから、<code>p</code>(previous)を使うことでいつでも以前の作業ディレクトリに戻ることができます。</p>
<div><pre><code>/bin> p
</code></pre></div><p>シェルをもう一度確認しましょう。</p>
<div><pre><code>/home/jonathant/Source/nushell/(simple_list_view)> shells
───┬────────┬─────────────────────────────────────────────┬─────────────────────────────────
 # │ active │ name                                        │ path
───┼────────┼─────────────────────────────────────────────┼─────────────────────────────────
 0 │ X      │ filesystem                                  │ /home/jonathant/Source/nushell/
 1 │        │ {/home/jonathant/Source/nushell/Cargo.toml} │ /bin
───┴────────┴─────────────────────────────────────────────┴─────────────────────────────────


</code></pre></div><p>&quot;Cargo.toml&quot;ファイルにエンターする前の作業ディレクトリにもどっていることがわかります。</p>
]]></content:encoded>
    </item>
    <item>
      <title>目次</title>
      <link>www.nushell.sh/ja/book/table_of_contents.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/table_of_contents.html</guid>
      <source url="www.nushell.sh/rss.xml">目次</source>
      <content:encoded><![CDATA[<h1 id="目次" tabindex="-1"> 目次</h1>
<ul>
<li><a href="/ja/book/installation.html">インストール</a> - nushell のインストール</li>
<li><a href="/ja/book/introduction.html">はじめに</a> - nushell をはじめよう</li>
<li><a href="/ja/book/moving_around.html">ファイルシステムの操作</a> - nushell からファイルシステムを扱おう</li>
<li><a href="/ja/book/types_of_data.html">データ型</a> - nushell のデータ型</li>
<li><a href="/ja/book/loading_data.html">データの読み込み</a> - データの読み込みとその利用方法</li>
<li><a href="/ja/book/working_with_tables.html">テーブル</a> - テーブルを利用してみよう</li>
<li><a href="/ja/book/pipeline.html">パイプライン</a> - パイプラインの仕組み</li>
<li><a href="/ja/book/configuration.html">設定</a> - nushell の設定</li>
<li><a href="/ja/book/metadata.html">メタデータ</a> - nushell におけるメタデータについて</li>
<li><a href="/ja/book/shells_in_shells.html">シェル</a> - 複数の場所で作業しよう</li>
<li><a href="/ja/book/escaping.html">コマンドのエスケープ</a> - Nu コマンドと同じ名前のコマンドを実行するには</li>
<li><a href="/ja/book/plugins.html">プラグイン</a> - プラグインを利用して nushell を拡張する</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>データ型</title>
      <link>www.nushell.sh/ja/book/types_of_data.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/types_of_data.html</guid>
      <source url="www.nushell.sh/rss.xml">データ型</source>
      <content:encoded><![CDATA[<h1 id="データ型" tabindex="-1"> データ型</h1>
<p>従来、Unix シェルコマンドは文字列テキストを通じて互いに通信してきました。あるコマンドは標準出力(しばしば'stdout'と略されます)を介してテキストを出力し、他方のコマンドは標準入力(または'stdin')を介してテキストを読み込みます。このようにして、２つのコマンドは通信できます。</p>
<p>この種の通信は文字列ベースと考えることができます。</p>
<p>Nu はコマンドに対してこのアプローチを採用しつつ、他の種類のデータを扱えるよう拡張しています。現在、Nu はシンプルなデータと構造化されたデータ、２つの種類をサポートしています。</p>
<h2 id="シンプルなデータ" tabindex="-1"> シンプルなデータ</h2>
<p>多くのプログラミング言語と同様に、Nu はシンプルなデータと構造化されたデータを用いてデータをモデル化します。シンプルなデータ型には、整数、浮動小数点、文字列、真偽値、日付、およびパスが含まれます。ファイルサイズのための特別な型もこれに含まれます。</p>
<h3 id="整数" tabindex="-1"> 整数</h3>
<p>整数(または丸めた数)。例として、１，５，および 100 があります。</p>
<h3 id="浮動小数点" tabindex="-1"> 浮動小数点</h3>
<p>浮動小数点は小数部を含む数です。例として、1.5、2.0、および 15.333 があります。</p>
<h3 id="文字列" tabindex="-1"> 文字列</h3>
<p>文字列はテキストを表す基本的な方法です。文字列はダブルクォートを使って表されます。例として、&quot;Fred&quot;, &quot;myname.txt&quot;, and &quot;Lynchburg, VA&quot;があります。</p>
<p>Nu の文字列はデフォルトで Unicode に対応しているため UTF-8 のテキストを簡単に渡すことができます。</p>
<h3 id="lines" tabindex="-1"> Lines</h3>
<p>Lines は OS に依存した行末をもつ文字列です。使用される場合は、OS 固有の行末が使用されます。</p>
<h3 id="column-paths" tabindex="-1"> Column paths</h3>
<p>Column paths はテーブルにおける特定のサブテーブル、列、行、またはセルへのパスです。</p>
<h3 id="パターン" tabindex="-1"> パターン</h3>
<p>&quot;glob&quot;パターンと呼ばれたりもするパターンはシェルでよく利用されるファイル名のマッチング方法です。<br>
<code>*</code>は何にでもマッチし、<code>?</code>は一文字にマッチすることを表しています。</p>
<p>例) <code>ls test*</code>における<code>test*</code>がパターンです。</p>
<h3 id="真偽値" tabindex="-1"> 真偽値</h3>
<p>真偽値は真か偽かの状態をとります。しばしば比較の結果を表すために使われます。</p>
<p>真偽値の２つの値は、<code>$true</code>と<code>$false</code>です。</p>
<h3 id="日付" tabindex="-1"> 日付</h3>
<p>日付と時間は日付型のデータに一緒に保持されます。システムで利用される日付データはタイムゾーンをもち、デフォルトでは UTC タイムゾーンが使用されます。</p>
<h3 id="duration" tabindex="-1"> Duration</h3>
<p>Duration は時間の長さを表します。1 秒、5 週間、1 年はすべて Duration の値です。</p>
<p>例) <code>1wk</code>は 1 週間を表す Duration です。</p>
<p>この表は現在サポートされているすべての Duration を示しています。</p>
<table>
<thead>
<tr>
<th>Duration</th>
<th>Length</th>
</tr>
</thead>
<tbody>
<tr>
<td>1sec</td>
<td>one second</td>
</tr>
<tr>
<td>1min</td>
<td>one minute</td>
</tr>
<tr>
<td>1hr</td>
<td>one hour</td>
</tr>
<tr>
<td>1day</td>
<td>one day</td>
</tr>
<tr>
<td>1wk</td>
<td>one week</td>
</tr>
</tbody>
</table>
<h3 id="ranges" tabindex="-1"> Ranges</h3>
<p>値の範囲を表すこともできます。大抵は、開始と終了の間の数値を表すために利用します。</p>
<p>例) <code>ls | range 1..4</code></p>
<h3 id="パス" tabindex="-1"> パス</h3>
<p>パスは、特定の OS でファイルパスを表すプラットフォームに依存しない方法です。例として、<code>/usr/bin</code>や<code>C:\Users\file.txt</code>があげられます。</p>
<h3 id="バイト" tabindex="-1"> バイト</h3>
<p>ファイルサイズはバイトと呼ばれる特別な整数型で保持されます。例として、<code>100</code>, <code>15kb</code>、<code>100mb</code>があります。</p>
<h3 id="バイナリデータ" tabindex="-1"> バイナリデータ</h3>
<p>バイナリデータは、画像ファイルのデータのように、生のバイトの集まりです。</p>
<h2 id="構造化データ" tabindex="-1"> 構造化データ</h2>
<p>構造化データはシンプルなデータから作られます。例えば、構造化データは、複数の整数を表す方法を提供します。現在サポートされている構造化データは次のとおりです。rows, lists, そして blocks です。</p>
<h3 id="rows" tabindex="-1"> Rows</h3>
<p>row データ型は表の１行のデータで見えるものを表しています。異なる要素のデータをもち、データにはそれぞれ列名が与えられます。</p>
<h3 id="lists" tabindex="-1"> Lists</h3>
<p>Lists は一つ以上の値を保持できます。単純な値だけでなく、rows も保持することができます。rows の lists はしばしばテーブルと呼ばれます。</p>
<div><pre><code>> echo [sam fred george]
───┬────────
 0 │ sam
 1 │ fred
 2 │ george
───┴────────
</code></pre></div><h3 id="blocks" tabindex="-1"> Blocks</h3>
<p>Blocks は Nu のコードブロックを表します。例えば、<code>each { echo $it }</code>というコマンドでは、<code>{ echo $it }</code>が block になります。
block はデータの行ごとに実行するコードを表すのに便利です。</p>
]]></content:encoded>
    </item>
    <item>
      <title>テーブルを扱う</title>
      <link>www.nushell.sh/ja/book/working_with_tables.html</link>
      <guid isPermaLink="false">www.nushell.sh/ja/book/working_with_tables.html</guid>
      <source url="www.nushell.sh/rss.xml">テーブルを扱う</source>
      <content:encoded><![CDATA[<h1 id="テーブルを扱う" tabindex="-1"> テーブルを扱う</h1>
<p>Nu でデータを表示する一般的な方法はテーブルを使用することです。Nu には、探しているものを見つけやすくしたり、必要なデータを絞り込んだりするのに便利なテーブルを操作するためのコマンドがたくさん用意されています。</p>
<p>まずはじめに、今回利用するテーブルを確認しましょう。</p>
<div><pre><code>> ls
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ files.rs      │ File │  4.6 KB │ 5 days ago
 1 │ lib.rs        │ File │   330 B │ 5 days ago
 2 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 3 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
 4 │ path.rs       │ File │  2.1 KB │ 5 days ago
 5 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 6 │ signature.rs  │ File │  1.2 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────
</code></pre></div><h2 id="データのソート" tabindex="-1"> データのソート</h2>
<p>ソートに利用する列名を指定して、<code>sort-by</code>コマンドを呼びだすことでテーブルをソートできます。ファイルのサイズでテーブルをソートしたいとしましょう。</p>
<div><pre><code>> ls | sort-by size
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ lib.rs        │ File │   330 B │ 5 days ago
 1 │ signature.rs  │ File │  1.2 KB │ 5 days ago
 2 │ path.rs       │ File │  2.1 KB │ 5 days ago
 3 │ files.rs      │ File │  4.6 KB │ 5 days ago
 4 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 5 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 6 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
───┴───────────────┴──────┴─────────┴────────────
</code></pre></div><p>比較さえできれば任意の列でソートが行なえます。例えば、&quot;name&quot;、&quot;accessed&quot;、または&quot;modified&quot;列でソートすることができます。</p>
<h2 id="必要なデータを選択する" tabindex="-1"> 必要なデータを選択する</h2>
<p>列や行を選択することでテーブルから必要なデータを選択できます。テーブルからいくつかの列を選択してみましょう。</p>
<div><pre><code>> ls | select name size
───┬───────────────┬─────────
 # │ name          │ size
───┼───────────────┼─────────
 0 │ files.rs      │  4.6 KB
 1 │ lib.rs        │   330 B
 2 │ lite_parse.rs │  6.3 KB
 3 │ parse.rs      │ 49.8 KB
 4 │ path.rs       │  2.1 KB
 5 │ shapes.rs     │  4.7 KB
 6 │ signature.rs  │  1.2 KB
───┴───────────────┴─────────
</code></pre></div><p>こうすることで、より必要とするデータにフォーカスしたテーブルを作ることができます。次にディレクトリからもっとも小さい 5 つのファイルを表示してみます。</p>
<div><pre><code>> ls | sort-by size | first 5
───┬──────────────┬──────┬────────┬────────────
 # │ name         │ type │ size   │ modified
───┼──────────────┼──────┼────────┼────────────
 0 │ lib.rs       │ File │  330 B │ 5 days ago
 1 │ signature.rs │ File │ 1.2 KB │ 5 days ago
 2 │ path.rs      │ File │ 2.1 KB │ 5 days ago
 3 │ files.rs     │ File │ 4.6 KB │ 5 days ago
 4 │ shapes.rs    │ File │ 4.7 KB │ 5 days ago
───┴──────────────┴──────┴────────┴────────────
</code></pre></div><p>もっとも小さいファイルを取得するためにまずサイズでソートし、それから<code>first 5</code>を利用してテーブルから最初の 5 行を返しています。</p>
<p>不要な行を<code>skip</code>することもできます。上記で返された５行のうち最初の２行をスキップしてみましょう。</p>
<div><pre><code>> ls | sort-by size | first 5 | skip 2
───┬───────────┬──────┬────────┬────────────
 # │ name      │ type │ size   │ modified
───┼───────────┼──────┼────────┼────────────
 0 │ path.rs   │ File │ 2.1 KB │ 5 days ago
 1 │ files.rs  │ File │ 4.6 KB │ 5 days ago
 2 │ shapes.rs │ File │ 4.7 KB │ 5 days ago
───┴───────────┴──────┴────────┴────────────
</code></pre></div><p>関心のある３行に絞り込みました。</p>
<p>データを選択するための他のコマンドもみてみましょう。テーブルの各行が数字をもつことを疑問に思っているかもしれません。これは単一の行を簡単に指定する方法として機能します。テーブルをファイル名でソートして、<code>nth</code>コマンドを利用して n 行目を選択してみましょう。</p>
<div><pre><code>> ls | sort-by name
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ files.rs      │ File │  4.6 KB │ 5 days ago
 1 │ lib.rs        │ File │   330 B │ 5 days ago
 2 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 3 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
 4 │ path.rs       │ File │  2.1 KB │ 5 days ago
 5 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 6 │ signature.rs  │ File │  1.2 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────

> ls | sort-by name | nth 5
──────────┬────────────
 name     │ shapes.rs
 type     │ File
 size     │ 4.7 KB
 modified │ 5 days ago
──────────┴────────────
</code></pre></div><h2 id="テーブルからデータを取得する" tabindex="-1"> テーブルからデータを取得する</h2>
<p>これまでは、テーブルを必要なものだけにトリミングする操作を行ってきました。ときには一歩進んで、列全体ではなく、セル自体の値が必要になるかもしれません。たとえば、ファイル名のリストだけを取得したいとしましょう。この場合<code>get</code>コマンドを利用することができます。</p>
<div><pre><code>> ls | get name
───┬───────────────
 0 │ files.rs
 1 │ lib.rs
 2 │ lite_parse.rs
 3 │ parse.rs
 4 │ path.rs
 5 │ shapes.rs
 6 │ signature.rs
───┴───────────────
</code></pre></div><p>これで各ファイルの名前が取得できました。</p>
<p>これはさきほどみた<code>select</code>コマンドと同じにみえるかもしれません、比較のために<code>select</code>コマンドの出力もみておきましょう。</p>
<div><pre><code>> ls | select name
───┬───────────────
 # │ name
───┼───────────────
 0 │ files.rs
 1 │ lib.rs
 2 │ lite_parse.rs
 3 │ parse.rs
 4 │ path.rs
 5 │ shapes.rs
 6 │ signature.rs
───┴───────────────
</code></pre></div><p>両者は非常に似ています！両者の違いを明確にしておきましょう。</p>
<ul>
<li><code>select</code> - 指定された列のみを含む新しいテーブルを作成します</li>
<li><code>get</code> - 指定された列内の値を返します</li>
</ul>
<p>テーブルからこれらを区別する方法の一つは、<code>value</code>列名です。これにより値のリストであることがわかります。</p>
<p><code>get</code>コマンドは、パスを受け取りテーブル内のより深いデータへアクセスすることができます。これにより.json ファイルにあるような複雑なデータを簡単に操作することができます。</p>
<h2 id="テーブルのデータを変更する" tabindex="-1"> テーブルのデータを変更する</h2>
<p>テーブルからデータを選択することに加えて、テーブルの内容を更新することもできます。新しい列を加えたり、セルの内容を編集したりできるのです。Nu では、その場で編集するのではなく、パイプラインの各コマンドは新しいテーブルを返します。</p>
<h3 id="新しい列を追加する" tabindex="-1"> 新しい列を追加する</h3>
<p><code>add</code>コマンドを使用して、新しい列をテーブルに追加できます。例をみてみましょう。</p>
<div><pre><code>> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
</code></pre></div><p>値が 2021 の&quot;next_edition&quot;列を追加してみましょう。</p>
<div><pre><code>> open rustfmt.toml | insert next_edition 2021
──────────────┬──────
 edition      │ 2018
 next_edition │ 2021
──────────────┴──────
</code></pre></div><p>元のファイルは変更されていないことに注意してください。</p>
<div><pre><code>> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
</code></pre></div><p>Nu の変更は永続的な変更ではなく、値自体に作用する関数的な変更です。これにより、結果を書き出す準備ができるまでパイプライン上で様々な種類の作業をおこなうことができます。ここでは、<code>save</code>コマンドを使用して結果を書き出すことができます。</p>
<div><pre><code>> open rustfmt.toml | insert next_edition 2021 | save rustfmt2.toml
> open rustfmt2.toml
──────────────┬──────
 edition      │ 2018
 next_edition │ 2021
──────────────┴──────
</code></pre></div><h3 id="列を更新する" tabindex="-1"> 列を更新する</h3>
<p><code>insert</code>コマンドと同様に、<code>update</code>コマンドを利用して列の内容を新しい値に変更することもできます。実際に動作を確認するために同じファイルを開いてみましょう。</p>
<div><pre><code>> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
</code></pre></div><p>今度は、サポートした次の edition を指定するよう更新しましょう。</p>
<div><pre><code>> open rustfmt.toml | update edition 2021
─────────┬──────
 edition │ 2021
─────────┴──────
</code></pre></div><h3 id="値を増やす" tabindex="-1"> 値を増やす</h3>
<p>数字やバージョンを扱う際に便利なコマンドがもうひとつあります、<code>inc</code>です。</p>
<div><pre><code>> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
> open rustfmt.toml | inc edition
─────────┬──────
 edition │ 2019
─────────┴──────
</code></pre></div><p>&quot;edition&quot;の値は数字なので、<code>inc</code>を使って更新することができます。バージョンを扱う際には<code>inc</code>がその真価を発揮します。</p>
<div><pre><code>> open Cargo.toml | get package.version
0.1.3
> open Cargo.toml | inc package.version --minor | get package.version
0.2.0
</code></pre></div><p>バージョンを扱う際には、フラグを利用して、バージョンのインクリメント方法を指定できます。</p>
<ul>
<li><strong>--major</strong> - メジャーバージョンをインクリメント (0.1.3 -&gt; 1.0.0)</li>
<li><strong>--minor</strong> - マイナーバージョンをインクリメント (0.1.3 -&gt; 0.2.0)</li>
<li><strong>--patch</strong> - パッチバージョンをインクリメント (0.1.3 -&gt; 0.1.4)</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>