{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Nushell",
  "home_page_url": "www.nushell.sh/pt-BR/",
  "feed_url": "www.nushell.sh/feed.json",
  "description": "Um novo tipo de shell.",
  "items": [
    {
      "title": "Índice",
      "url": "www.nushell.sh/pt-BR/book/",
      "id": "www.nushell.sh/pt-BR/book/",
      "content_html": "<h1 id=\"indice\" tabindex=\"-1\"> Índice</h1>\n<ul>\n<li><a href=\"/pt-BR/book/instalacao.html\">Instalação</a> - Instalando o nushell</li>\n<li><a href=\"/pt-BR/book/introducao.html\">Introdução</a> - Começando a usar o nushell</li>\n<li><a href=\"/pt-BR/book/explorando.html\">Explorando</a> - Explorando o nushell</li>\n<li><a href=\"/pt-BR/book/tipos_de_dados.html\">Tipos de dados</a> - Tipos de dados no nushell</li>\n<li><a href=\"/pt-BR/book/carregando_dados.html\">Carregando dados</a> - Carregando e usando dados</li>\n<li><a href=\"/pt-BR/book/trabalhando_com_tabelas.html\">Trabalhando com tabelas</a> - Trabalhando com as tabelas do nushell</li>\n<li><a href=\"/pt-BR/book/pipeline.html\">Pipeline</a> - Como o pipeline funciona</li>\n<li><a href=\"/pt-BR/book/metadados.html\">Metadados</a> - Uma explicação sobre o sistema de metadados do nushell</li>\n<li><a href=\"/pt-BR/book/shells_em_shells.html\">Shells</a> - Trabalhando com múltiplos locais</li>\n<li><a href=\"/pt-BR/book/escapando.html\">Escapando comandos</a> - Escapando para comandos nativos com o mesmo nome</li>\n<li><a href=\"/pt-BR/book/plugins.html\">Plugins</a> - Melhorando o nushell com mais funcionalidades usando plugins</li>\n<li><a href=\"/pt-BR/book/command_reference.html\">Command Reference</a> - A list of all Nushell's commands.</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.700Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Carregando dados",
      "url": "www.nushell.sh/pt-BR/book/carregando_dados.html",
      "id": "www.nushell.sh/pt-BR/book/carregando_dados.html",
      "content_html": "<h1 id=\"carregando-dados\" tabindex=\"-1\"> Carregando dados</h1>\n<p>Anteriormente vimos como você pode usar comandos como <code>ls</code>, <code>ps</code>, <code>date</code> e <code>sys</code> para carregar informações sobre seus arquivos, processos, data e hora e sobre o sistema em si. Cada comando retorna uma tabela de informações que podemos explorar. Há outras maneiras de se carregar uma tabela de dados com a qual trabalhar.</p>\n<h2 id=\"abrindo-arquivos\" tabindex=\"-1\"> Abrindo arquivos</h2>\n<p>Uma das funcionalidades mais poderosas do Nu para lidar com dados é o comando <code>open</code>. Ele é uma ferramenta múltipla, capaz de trabalhar com diversos formatos de dados. Para vermos o que isso significa, vamos tentar abrir um arquivo json:</p>\n<div><pre><code><span>></span> <span>open</span> editors/vscode/package.json\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n name <span>|</span> descript <span>|</span> author   <span>|</span> license <span>|</span> version <span>|</span> reposito <span>|</span> publishe <span>|</span> categori <span>|</span> keywords <span>|</span> engines  <span>|</span> activati <span>|</span> main     <span>|</span> contribu <span>|</span> scripts  <span>|</span> devDepen\n      <span>|</span> ion      <span>|</span>          <span>|</span>         <span>|</span>         <span>|</span> ry       <span>|</span> r        <span>|</span> es       <span>|</span>          <span>|</span>          <span>|</span> onEvents <span>|</span>          <span>|</span> tes      <span>|</span>          <span>|</span> dencies\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n lark <span>|</span> Lark     <span>|</span> Lark     <span>|</span> MIT     <span>|</span> <span>1.0</span>.0   <span>|</span> <span>[</span>object<span>]</span> <span>|</span> vscode   <span>|</span> <span>[</span><span>0</span>       <span>|</span> <span>[</span><span>1</span> item<span>]</span> <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span><span>1</span> item<span>]</span> <span>|</span> ./out/ex <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span>object<span>]</span>\n      <span>|</span> support  <span>|</span> develope <span>|</span>         <span>|</span>         <span>|</span>          <span>|</span>          <span>|</span> items<span>]</span>   <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span> tension  <span>|</span>          <span>|</span>          <span>|</span>\n      <span>|</span> <span>for</span> VS   <span>|</span> rs       <span>|</span>         <span>|</span>         <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>\n      <span>|</span> Code     <span>|</span>          <span>|</span>         <span>|</span>         <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>          <span>|</span>\n------+----------+----------+---------+---------+----------+----------+----------+----------+----------+----------+----------+----------+----------+----------\n</code></pre></div><p>De um jeito similar ao comando <code>ls</code>, abrir um tipo de arquivo que o Nu entende vai nos retornar algo que é mais do que apenas texto (ou um fluxo de bytes). Aqui nós abrimos um arquivo &quot;package.json&quot; de um projeto JavaScript. O Nu abre e reconhece o texto JSON e retorna uma tabela de dados.</p>\n<p>Se quisermos checar a versão do projeto que estamos olhando, podemos usar o comando <code>get</code>.</p>\n<div><pre><code><span>></span> <span>open</span> editors/vscode/package.json <span>|</span> get version\n<span>1.0</span>.0\n</code></pre></div><p>O Nu atualmente suporta carregar dados diretamente para tabelas a partir dos seguintes formatos:</p>\n<ul>\n<li>json</li>\n<li>yaml</li>\n<li>toml</li>\n<li>xml</li>\n<li>csv</li>\n<li>ini</li>\n</ul>\n<p>Mas o que acontece se você carregar um arquivo texto cujo formato não é um desses? Vamos tentar:</p>\n<div><pre><code><span>></span> <span>open</span> README.md\n</code></pre></div><p>O conteúdo do arquivo é mostrado. Se o arquivo for muito grande, obteremos uma visão rolável para examinar o arquivo e depois voltar para o terminal. Para ajudar na legibilidade, Nu faz realce de sintaxe para formatos comuns como arquivos de código fonte, markdown e outros.</p>\n<p>Por baixo dos panos, o que o Nu enxerga nesses arquivos texto é uma grande string. A seguir, vamos falar sobre como trabalhar com essas strings para obter os dados que precisamos delas.</p>\n<h2 id=\"trabalhando-com-strings\" tabindex=\"-1\"> Trabalhando com strings</h2>\n<p>Uma parte importante de se trabalhar com dados vindos de fora do Nu é que eles nem sempre vêm num formato que o Nu entende. Com frequência, esses dados são passados como uma string.</p>\n<p>Vamos imaginar que obtivemos esse arquivo de dados:</p>\n<div><pre><code><span>></span> <span>open</span> people.txt\nOctavia <span>|</span> Butler <span>|</span> Writer\nBob <span>|</span> Ross <span>|</span> Painter\nAntonio <span>|</span> Vivaldi <span>|</span> Composer\n</code></pre></div><p>Cada pedacinho de dado que queremos está separado pelo símbolo de pipe ('|') e cada pessoa está numa linha em separado. Nu não possui por padrão um formato de arquivos delimitados por pipe, então teremos que interpretá-lo nós mesmos.</p>\n<p>A primeira coisa que queremos fazer ao carregar o arquivo é trabalhar com ele linha a linha:</p>\n<div><pre><code><span>></span> <span>open</span> people.txt <span>|</span> lines\n---+------------------------------\n <span># | value</span>\n---+------------------------------\n <span>0</span> <span>|</span> Octavia <span>|</span> Butler <span>|</span> Writer\n <span>1</span> <span>|</span> Bob <span>|</span> Ross <span>|</span> Painter\n <span>2</span> <span>|</span> Antonio <span>|</span> Vivaldi <span>|</span> Composer\n---+------------------------------\n</code></pre></div><p>Podemos notar que estamos lidando com linhas porque voltamos a ver uma tabela. Nosso próximo passo é tentar dividir as linhas em algo um pouco mais útil. Para isso, vamos usar o comando <code>split column</code>. Como o nome implica, esse comando nos dá uma forma de dividir em colunas uma string delimitada. Informamos qual é o delimitador e o comando faz o resto:</p>\n<div><pre><code><span>></span> <span>open</span> people.txt <span>|</span> lines <span>|</span> <span>split</span> <span>column</span> <span>\"|\"</span>\n---+----------+-----------+-----------\n <span># | Column1  | Column2   | Column3</span>\n---+----------+-----------+-----------\n <span>0</span> <span>|</span> Octavia  <span>|</span>  Butler   <span>|</span>  Writer\n <span>1</span> <span>|</span> Bob      <span>|</span>  Ross     <span>|</span>  Painter\n <span>2</span> <span>|</span> Antonio  <span>|</span>  Vivaldi  <span>|</span>  Composer\n---+----------+-----------+-----------\n</code></pre></div><p>Está quase certo. Parece que tem um espaço extra ali. Vamos mudar nosso delimitador:</p>\n<div><pre><code><span>></span> <span>open</span> people.txt <span>|</span> lines <span>|</span> <span>split</span> <span>column</span> <span>\" | \"</span>\n---+---------+---------+----------\n <span># | Column1 | Column2 | Column3</span>\n---+---------+---------+----------\n <span>0</span> <span>|</span> Octavia <span>|</span> Butler  <span>|</span> Writer\n <span>1</span> <span>|</span> Bob     <span>|</span> Ross    <span>|</span> Painter\n <span>2</span> <span>|</span> Antonio <span>|</span> Vivaldi <span>|</span> Composer\n---+---------+---------+----------\n</code></pre></div><p>Nada mal. O comando <code>split column</code> retorna dados que podemos usar. Ele também vai além e nos dá nomes de coluna padrão:</p>\n<div><pre><code><span>></span> <span>open</span> people.txt <span>|</span> lines <span>|</span> <span>split</span> <span>column</span> <span>\" | \"</span> <span>|</span> get Column1\n---+---------\n <span># | value</span>\n---+---------\n <span>0</span> <span>|</span> Octavia\n <span>1</span> <span>|</span> Bob\n <span>2</span> <span>|</span> Antonio\n---+---------\n</code></pre></div><p>Podemos também nomear nossas colunas ao invés de usar os nomes padrão:</p>\n<div><pre><code><span>></span> <span>open</span> people.txt <span>|</span> lines <span>|</span> <span>split</span> <span>column</span> <span>\" | \"</span> first_name last_name job\n---+------------+-----------+----------\n <span># | first_name | last_name | job</span>\n---+------------+-----------+----------\n <span>0</span> <span>|</span> Octavia    <span>|</span> Butler    <span>|</span> Writer\n <span>1</span> <span>|</span> Bob        <span>|</span> Ross      <span>|</span> Painter\n <span>2</span> <span>|</span> Antonio    <span>|</span> Vivaldi   <span>|</span> Composer\n---+------------+-----------+----------\n</code></pre></div><p>Agora que nossos dados estão em uma tabela, podemos usar todos os comandos que já usávamos antes em tabelas:</p>\n<div><pre><code><span>></span> <span>open</span> people.txt <span>|</span> lines <span>|</span> <span>split</span> <span>column</span> <span>\" | \"</span> first_name last_name job <span>|</span> sort-by first_name\n---+------------+-----------+----------\n <span># | first_name | last_name | job</span>\n---+------------+-----------+----------\n <span>0</span> <span>|</span> Antonio    <span>|</span> Vivaldi   <span>|</span> Composer\n <span>1</span> <span>|</span> Bob        <span>|</span> Ross      <span>|</span> Painter\n <span>2</span> <span>|</span> Octavia    <span>|</span> Butler    <span>|</span> Writer\n---+------------+-----------+----------\n</code></pre></div><p>Há outros comandos que você pode usar para trabalhar com strings:</p>\n<ul>\n<li>str</li>\n<li>lines</li>\n<li>size</li>\n</ul>\n<p>Há também um conjunto de comandos auxiliares que podemos chamar se soubermos que os dados têm uma estrutura que o Nu deve ser capaz de entender. Por exemplo, vamos abrir um arquivo de lock do Rust:</p>\n<div><pre><code><span>></span> <span>open</span> Cargo.lock\n<span># This file is automatically @generated by Cargo.</span>\n<span># It is not intended for manual editing.</span>\n<span>[</span><span>[</span>package<span>]</span><span>]</span>\nname <span>=</span> <span>\"adhoc_derive\"</span>\nversion <span>=</span> <span>\"0.1.2\"</span>\n</code></pre></div><p>O arquivo &quot;Cargo.lock&quot; é na verdade um arquivo .toml, mas a extensão do arquivo não é .toml. Tudo bem, podemos usar o comando <code>from toml</code>:</p>\n<div><pre><code><span>></span> <span>open</span> Cargo.lock <span>|</span> from toml\n----------+-------------\n metadata <span>|</span> package\n----------+-------------\n <span>[</span>object<span>]</span> <span>|</span> <span>[</span><span>405</span> items<span>]</span>\n----------+-------------\n</code></pre></div><p>Há um comando <code>from</code> para cada formato de dados estruturados em texto que o Nu entende e pode abrir.</p>\n<h2 id=\"abrindo-no-modo-bruto\" tabindex=\"-1\"> Abrindo no modo bruto</h2>\n<p>Embora seja útil poder abrir um arquivo e trabalhar imediatamente com uma tabela dos seus dados, nem sempre é isso o que queremos fazer. Para ter acesso ao texto subjacente, o comando <code>open</code> pode receber um modificador opcional <code>--raw</code>:</p>\n<div><pre><code><span>></span> <span>open</span> Cargo.toml --raw\n<span>[</span>package<span>]</span>                                                                                        name <span>=</span> <span>\"nu\"</span>\nversion <span>=</span> <span>\"0.1.3\"</span>\nauthors <span>=</span> <span>[</span><span>\"Yehuda Katz &lt;wycats@gmail.com>\"</span>, <span>\"Jonathan Turner &lt;jonathan.d.turner@gmail.com>\"</span><span>]</span>\ndescription <span>=</span> <span>\"A shell for the GitHub era\"</span>\nlicense <span>=</span> <span>\"MIT\"</span>\n</code></pre></div><h2 id=\"abrindo-urls\" tabindex=\"-1\"> Abrindo URLs</h2>\n<p>Além de carregar dados a partir do sistema de arquivos, você também pode passar uma URL para o comando <code>open</code>. Ele trará da internet o conteúdo dessa URL e o retornará para você:</p>\n<div><pre><code><span>></span> <span>open</span> https://www.jonathanturner.org/feed.xml\n----------\n rss\n----------\n <span>[</span><span>1</span> item<span>]</span>\n----------\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.701Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Command Reference",
      "url": "www.nushell.sh/pt-BR/book/command_reference.html",
      "id": "www.nushell.sh/pt-BR/book/command_reference.html",
      "content_html": "<h1 id=\"command-reference\" tabindex=\"-1\"> Command Reference</h1>\n<table>\n  <tr>\n    <th>Command</th>\n    <th>Description</th>\n  </tr>\n  <tr v-for=\"command in commands\">\n   <td><a :href=\"command.path\"><code>{{ command.title }}</code></a></td>\n   <td style=\"white-space: pre-wrap;\">{{ command.frontmatter.usage }}</td>\n  </tr>\n</table>\n",
      "date_modified": "2022-06-02T15:48:22.701Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Escapando para o sistema",
      "url": "www.nushell.sh/pt-BR/book/escapando.html",
      "id": "www.nushell.sh/pt-BR/book/escapando.html",
      "content_html": "<h1 id=\"escapando-para-o-sistema\" tabindex=\"-1\"> Escapando para o sistema</h1>\n<p>O Nu fornece um conjunto de comandos que você pode usar entre diferentes SOs e contar com essa consistência é útil. Às vezes, porém, você quer executar comando que tem o mesmo nome que um dos comandos do Nu. Para executar os comandos locais <code>ls</code> ou <code>date</code>, por exemplo, use o comando circunflexo (^).</p>\n<p>Comando Nu:</p>\n<div><pre><code><span>></span> <span>ls</span>\n</code></pre></div><p>Escapando para o comando local:</p>\n<div><pre><code><span>></span> ^ls\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.701Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Explorando seu sistema",
      "url": "www.nushell.sh/pt-BR/book/explorando.html",
      "id": "www.nushell.sh/pt-BR/book/explorando.html",
      "content_html": "<h1 id=\"explorando-seu-sistema\" tabindex=\"-1\"> Explorando seu sistema</h1>\n<p>Shells mais antigos permitem que você navegue pelo sistema de arquivos e execute comandos. Shells modernos como o Nu permitem que você faça o mesmo. Vamos dar uma olhada em alguns dos comandos comuns que você vai usar quando estiver interagindo com seu sistema.</p>\n<h2 id=\"visualizando-o-conteudo-de-directorios\" tabindex=\"-1\"> Visualizando o conteúdo de directórios</h2>\n<div><pre><code><span>></span> <span>ls</span>\n</code></pre></div><p>Como vimos em outros capítulos, <code>ls</code> é um comando para visualizar o conteúdo de um caminho. Nu retorna o conteúdo como uma tabela que podemos usar adiante.</p>\n<p>O comando <code>ls</code> também recebe um parâmetro opcional para mudar o que você gostaria de ver. Por exemplo, podemos listar os arquivos cujo nome termina em &quot;.txt&quot;.</p>\n<div><pre><code><span>></span> <span>ls</span> *.txt\n---+--------------+------+----------+---------+--------------+--------------\n <span># | name         | type | readonly | size    | accessed     | modified</span>\n---+--------------+------+----------+---------+--------------+--------------\n <span>0</span> <span>|</span> history.txt  <span>|</span> File <span>|</span>          <span>|</span> <span>1.3</span> KB  <span>|</span> <span>2</span> months ago <span>|</span> a day ago\n <span>1</span> <span>|</span> readonly.txt <span>|</span> File <span>|</span> <span>readonly</span> <span>|</span> <span>&lt;</span>empty<span>></span> <span>|</span> <span>2</span> months ago <span>|</span> <span>2</span> months ago\n---+--------------+------+----------+---------+--------------+--------------\n</code></pre></div><p>O asterisco (*) usado no parâmetro opcional acima &quot;*.txt&quot; é chamado de coringa. Ele faz uma correspondência com qualquer coisa. Você pode ler o coringa &quot;*.txt&quot; como &quot;aceite qualquer nome de arquivo, desde que termine com '.txt'&quot;.</p>\n<p>Nu também usa coringas modernos, que permitem acesso a diretórios mais profundos.</p>\n<div><pre><code><span>></span> <span>ls</span> **/*.rs\n-----+-----------------------------------------------------+------+----------+----------+----------------+----------------\n <span>#   | name                                                | type | readonly | size     | accessed       | modified</span>\n-----+-----------------------------------------------------+------+----------+----------+----------------+----------------\n <span>0</span>   <span>|</span> src/cli.rs                                          <span>|</span> File <span>|</span>          <span>|</span> <span>19.1</span> KB  <span>|</span> <span>15</span> hours ago   <span>|</span> <span>15</span> hours ago\n <span>1</span>   <span>|</span> src/commands/args.rs                                <span>|</span> File <span>|</span>          <span>|</span> <span>244</span> B    <span>|</span> <span>2</span> months ago   <span>|</span> <span>2</span> months ago\n <span>2</span>   <span>|</span> src/commands/autoview.rs                            <span>|</span> File <span>|</span>          <span>|</span> <span>2.5</span> KB   <span>|</span> <span>15</span> hours ago   <span>|</span> <span>15</span> hours ago\n <span>3</span>   <span>|</span> src/commands/cd.rs                                  <span>|</span> File <span>|</span>          <span>|</span> <span>277</span> B    <span>|</span> a week ago     <span>|</span> a week ago\n <span>4</span>   <span>|</span> src/commands/classified.rs                          <span>|</span> File <span>|</span>          <span>|</span> <span>13.5</span> KB  <span>|</span> <span>15</span> hours ago   <span>|</span> <span>15</span> hours ago\n <span>5</span>   <span>|</span> src/commands/clip.rs                                <span>|</span> File <span>|</span>          <span>|</span> <span>2.0</span> KB   <span>|</span> <span>2</span> days ago     <span>|</span> <span>2</span> days ago\n</code></pre></div><p>Aqui estamos procurando qualquer arquivo cujo nome termine com &quot;.rs&quot; e os dois asteriscos dizem ainda &quot;em qualquer diretório começando a partir daqui&quot;.</p>\n<h2 id=\"mudando-o-diretorio-atual\" tabindex=\"-1\"> Mudando o diretório atual</h2>\n<div><pre><code><span>></span> <span>cd</span> new_directory\n</code></pre></div><p>Para mudar do diretório atual para um outro, usamos o comando <code>cd</code>. Assim como em outros shells, podemos usar o nome do diretório ou, se quisermos ir para um diretório acima, podemos usar o atalho <code>..</code>.</p>\n<h2 id=\"comandos-de-sistema-de-arquivo\" tabindex=\"-1\"> Comandos de sistema de arquivo</h2>\n<p>Nu também fornece alguns comandos básicos de sistemas de arquivos que funcionam entre plataformas diferentes.</p>\n<p>Podemos mover um item de um lugar para outro usando o comando <code>mv</code>.</p>\n<div><pre><code><span>></span> <span>mv</span> item location\n</code></pre></div><p>Podemos copiar um item de um local para outro:</p>\n<div><pre><code><span>></span> <span>cp</span> item location\n</code></pre></div><p>Podemos remover um item:</p>\n<div><pre><code><span>></span> <span>rm</span> item\n</code></pre></div><p>Os três comandos também podem usar os coringas que vimos anteriormente com <code>ls</code>.</p>\n<p>Por fim, podemos criar um novo diretório usando o comando <code>mkdir</code>:</p>\n<div><pre><code><span>></span> <span>mkdir</span> new_directory\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.701Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Instalando Nu",
      "url": "www.nushell.sh/pt-BR/book/instalacao.html",
      "id": "www.nushell.sh/pt-BR/book/instalacao.html",
      "content_html": "<h1 id=\"instalando-nu\" tabindex=\"-1\"> Instalando Nu</h1>\n<p>Atualmente, as melhores maneiras de instalar o Nu são a partir do <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a>, fazer o download dos binários da nossa <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">página de releases</a>, fazer o build a partir dos fontes ou baixar um container pronto com o Docker.</p>\n<h2 id=\"binarios\" tabindex=\"-1\"> Binários</h2>\n<p>Você pode baixar o Nu da <a href=\"https://github.com/nushell/nushell/releases\" target=\"_blank\" rel=\"noopener noreferrer\">página de releases</a>. Alternativamente, se você usa o <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Homebrew</a> para macOS, pode instalar o binário executando o comando <code>brew install nushell</code>.</p>\n<h2 id=\"preparando\" tabindex=\"-1\"> Preparando</h2>\n<p>Antes de instalar o Nu, precisamos nos certificar de que nosso sistema tem os requisitos necessários. Atualmente, isso significa ter certeza de que temos tanto o conjunto de ferramentas do Rust como as dependências locais instaladas.</p>\n<h3 id=\"instalando-o-rust\" tabindex=\"-1\"> Instalando o Rust</h3>\n<p>Se ainda não tivermos o Rust instalado no sistema, a melhor maneira de instalar é via <a href=\"https://rustup.rs/\" target=\"_blank\" rel=\"noopener noreferrer\">rustup</a>. Rustup é uma maneira de gerenciar instalações, inclusive de versões diferentes de Rust.</p>\n<p>O Nu atualmente requer a versão <strong>nightly</strong> do Rust. Quando você abrir o &quot;rustup&quot; pela primeira vez, ele vai perguntar qual versão do Rust você quer instalar:</p>\n<div><pre><code>Current installation options:\n\n   default <span>host</span> triple: x86_64-unknown-linux-gnu\n     default toolchain: stable\n  modify <span>PATH</span> variable: <span>yes</span>\n\n<span>1</span><span>)</span> Proceed with installation <span>(</span>default<span>)</span>\n<span>2</span><span>)</span> Customize installation\n<span>3</span><span>)</span> Cancel installation\n</code></pre></div><p>Selecione a opção #2 para customizar a instalação.</p>\n<div><pre><code>Default <span>host</span> triple?\n</code></pre></div><p>Aperte enter aqui para selecionar o default.</p>\n<div><pre><code>Default toolchain? <span>(</span>stable/beta/nightly/none<span>)</span>\n</code></pre></div><p>Certifique-se de digitar &quot;nightly&quot; aqui e pressionar enter. Isso vai levar à configuração seguinte:</p>\n<div><pre><code>Modify <span>PATH</span> variable? <span>(</span>y/n<span>)</span>\n</code></pre></div><p>Você pode opcionalmente atualizar o seu <em>path</em>. Normalmente é uma boa ideia, pois torna os passos seguintes mais fáceis.</p>\n<div><pre><code>Current installation options:\n\n   default <span>host</span> triple: x86_64-unknown-linux-gnu\n     default toolchain: nightly\n  modify <span>PATH</span> variable: <span>yes</span>\n\n<span>1</span><span>)</span> Proceed with installation <span>(</span>default<span>)</span>\n<span>2</span><span>)</span> Customize installation\n<span>3</span><span>)</span> Cancel installation\n</code></pre></div><p>Você pode ver que o toolchain agora mudou para a versão nightly. Se isso parece um pouco arriscado, não se preocupe. O compilador do Rust passa por uma bateria completa de testes. O compilador nightly é praticamente tão confiável quanto a versão estável.</p>\n<p>Quando estiver pronto, pressione 1 e enter. Depois desse ponto, podemos seguir as instruções que o &quot;rustup&quot; nos der e teremos um compilador Rust funcionando no nosso sistema.</p>\n<p>Se você preferir não instalar o Rust via &quot;rustup&quot;, você pode também instalar por outros métodos (por exemplo, a partir de um pacote em uma distribuição Linux). Apenas se certifique de instalar uma versão nightly recente.</p>\n<h2 id=\"dependencias\" tabindex=\"-1\"> Dependências</h2>\n<h3 id=\"debian-ubuntu\" tabindex=\"-1\"> Debian/Ubuntu</h3>\n<p>Você vai precisar instalar os pacotes &quot;pkg-config&quot; e &quot;libssl-dev&quot;:</p>\n<div><pre><code><span>apt</span> <span>install</span> pkg-config libssl-dev\n</code></pre></div><p>Usuários Linux que quiserem usar as funcionalidades opcionais <code>rawkey</code> ou <code>clipboard</code> precisarão instalar os pacotes &quot;libx11-dev&quot; and &quot;libxcb-composite0-dev&quot;:</p>\n<div><pre><code><span>apt</span> <span>install</span> libxcb-composite0-dev libx11-dev\n</code></pre></div><h3 id=\"macos\" tabindex=\"-1\"> macOS</h3>\n<p>Ao usar o <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener noreferrer\">Homebrew</a>, você precisará instalar o &quot;openssl&quot; e o &quot;cmake&quot; usando:</p>\n<div><pre><code>brew <span>install</span> openssl cmake\n</code></pre></div><h2 id=\"instalando-a-partir-do-crates-io\" tabindex=\"-1\"> Instalando a partir do <a href=\"https://crates.io\" target=\"_blank\" rel=\"noopener noreferrer\">crates.io</a></h2>\n<p>Quando tivermos todas as dependências de que o Nu precisa, podemos instalá-lo usando o comando <code>cargo</code>, que vem junto com o compilador Rust.</p>\n<div><pre><code><span>></span> cargo <span>install</span> nu\n</code></pre></div><p>Pronto! A ferramenta cargo fará o download do Nu e das dependências do fonte, o build e a instalação no caminho bin do cargo, de forma que possamos rodá-lo.</p>\n<p>Se quiser instalar todas as funcionalidades, inclusive algumas opcionais divertidas, você pode usar:</p>\n<div><pre><code><span>></span> cargo <span>install</span> nu --features<span>=</span>stable\n</code></pre></div><p>Para esse comando funcionar, certifique-se de ter todas as dependências (mostradas acima) instaladas no seu sistema.</p>\n<p>Uma vez instalado, podemos rodar o Nu usando o comando <code>nu</code>:</p>\n<div><pre><code>$ nu\n/home/jonathan/Source<span>></span>\n</code></pre></div><h2 id=\"fazendo-o-build-a-partir-dos-fontes\" tabindex=\"-1\"> Fazendo o Build a partir dos fontes</h2>\n<p>Também podemos fazer o build do código fonte diretamente do GitHub. Isso nos dá acesso imediato às últimas funcionalidades e correções do Nu.</p>\n<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git\n</code></pre></div><p>O Git vai clonar o repositório principal do nushell e daí podemos fazer o build e rodar o Nu:</p>\n<div><pre><code><span>></span> <span>cd</span> nushell\nnushell<span>></span> cargo build --workspace --features<span>=</span>stable <span>&amp;&amp;</span> cargo run --features<span>=</span>stable\n</code></pre></div><p>Você também pode fazer o build e rodar o Nu em modo release:</p>\n<div><pre><code>nushell<span>></span> cargo build --release --workspace --features<span>=</span>stable <span>&amp;&amp;</span> cargo run --release --features<span>=</span>stable\n</code></pre></div><p>Pessoas mais acostumadas com Rust podem se perguntar por que fazemos tanto o &quot;build&quot; como o &quot;run&quot; se o &quot;run&quot; já faz o build por padrão. Isso serve para contornar uma falha da nova opção <code>default-run</code> no Cargo e assegurar que será feito o build de todos os plugins, embora possa não ser necessário no futuro.</p>\n<h2 id=\"configurando-como-login-shell\" tabindex=\"-1\"> Configurando como login shell</h2>\n<p><strong>!!! Nushell ainda está em desenvovlimento e pode não estar estável para uso diário. !!!</strong></p>\n<p>Você pode definir o seu login shell usando o comando <a href=\"https://linux.die.net/man/1/chsh\" target=\"_blank\" rel=\"noopener noreferrer\"><code>chsh</code></a>.</p>\n<p>Algumas distribuições Linux possuem uma lista de shells válidos em <code>/etc/shells</code> e não permitirão modificar o shell até que o Nu esteja nessa lista branca. Você pode ver um erro similar ao mostrado abaixo se não tiver atualizado seu arquivo <code>shells</code>.</p>\n<div><pre><code>chsh: /home/username/.cargo/bin/nu is an invalid shell\n</code></pre></div><p>Você pode adicionar o Nu à lista de shell permitidos acrescentando o binário do Nu ao arquivo <code>shells</code>. O caminho a ser adicionado pode ser encontrado com o comando <code>which nu</code> e geralmente é <code>$HOME/.cargo/bin/nu</code>.</p>\n",
      "date_modified": "2022-06-02T15:48:22.702Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Introdução",
      "url": "www.nushell.sh/pt-BR/book/introducao.html",
      "id": "www.nushell.sh/pt-BR/book/introducao.html",
      "content_html": "<h1 id=\"introducao\" tabindex=\"-1\"> Introdução</h1>\n<p>Olá! Seja bem vindo ao projeto Nushell. O objetivo desse projeto é trazer a filosofia de shells do Unix, onde pipes conectam comandos simples, para o estilo moderno de desenvolvimento.</p>\n<p>Nu usa dicas de vários terrenos familiares: shells tradicionais como bash, shells avançados como PowerShell, programação funcional, programação de sistemas, e outros. Porém, mais do que tentar ser &quot;pau pra toda obra&quot;, Nu foca sua energia em fazer poucas coisas muito bem:</p>\n<ul>\n<li>Criar um shell multiplataforma flexível para o programador moderno da era GitHub</li>\n<li>Permitir que você combine aplicações de linha de comando com um shell que entende a estrutura dos seus dados</li>\n<li>Ter o mesmo nível de polimento de UX (experência do usuário) fornecido pelas aplicações CLI modernas</li>\n</ul>\n<p>O jeito mais fácil de ver o que o Nu pode fazer é começar com alguns exemplos, então vamos nessa.</p>\n<p>A primeira coisa que você vai perceber quando rodar um comando como <code>ls</code> é que ao invés de um bloco de texto, você recebe de volta uma tabela estruturada.</p>\n<div><pre><code><span>></span> <span>ls</span>\n----+------------------+-----------+----------+----------+----------------+----------------\n <span>#  | name             | type      | readonly | size     | accessed       | modified</span>\n----+------------------+-----------+----------+----------+----------------+----------------\n <span>0</span>  <span>|</span> .azure           <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB   <span>|</span> <span>2</span> months ago   <span>|</span> a week ago\n <span>1</span>  <span>|</span> IMG_1291.jpg     <span>|</span> File      <span>|</span>          <span>|</span> <span>115.5</span> KB <span>|</span> a month ago    <span>|</span> <span>4</span> months ago\n <span>2</span>  <span>|</span> Cargo.toml       <span>|</span> File      <span>|</span>          <span>|</span> <span>3.1</span> KB   <span>|</span> <span>17</span> minutes ago <span>|</span> <span>17</span> minutes ago\n <span>3</span>  <span>|</span> LICENSE          <span>|</span> File      <span>|</span>          <span>|</span> <span>1.1</span> KB   <span>|</span> <span>2</span> months ago   <span>|</span> <span>2</span> months ago\n <span>4</span>  <span>|</span> readonly.txt     <span>|</span> File      <span>|</span> <span>readonly</span> <span>|</span> <span>&lt;</span>empty<span>></span>  <span>|</span> a month ago    <span>|</span> a month ago\n <span>5</span>  <span>|</span> target           <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB   <span>|</span> <span>2</span> days ago     <span>|</span> <span>15</span> minutes ago\n<span>..</span>.\n</code></pre></div><p>Essa tabela faz mais do que somente mostrar o diretório de um jeito diferente. Assim como uma planilha, ela nos permite trabalhar com os dados interativamente.</p>\n<p>A primeira coisa que vamos fazer é ordenar a tabela por nome. Para isso, vamos direcionar a saída do <code>ls</code> para um comando capaz de ordenar tabelas com base no conteúdo de uma coluna.</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by name\n----+------------------+-----------+----------+----------+----------------+----------------\n <span>#  | name             | type      | readonly | size     | accessed       | modified</span>\n----+------------------+-----------+----------+----------+----------------+----------------\n <span>0</span>  <span>|</span> .azure           <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB   <span>|</span> <span>2</span> months ago   <span>|</span> a week ago\n <span>1</span>  <span>|</span> .cargo           <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB   <span>|</span> <span>2</span> months ago   <span>|</span> <span>2</span> months ago\n <span>2</span>  <span>|</span> .editorconfig    <span>|</span> File      <span>|</span>          <span>|</span> <span>148</span> B    <span>|</span> <span>2</span> months ago   <span>|</span> <span>2</span> months ago\n <span>3</span>  <span>|</span> .git             <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB   <span>|</span> <span>2</span> months ago   <span>|</span> <span>20</span> minutes ago\n <span>4</span>  <span>|</span> .gitignore       <span>|</span> File      <span>|</span>          <span>|</span> <span>58</span> B     <span>|</span> a week ago     <span>|</span> a week ago\n <span>5</span>  <span>|</span> .vscode          <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB   <span>|</span> a month ago    <span>|</span> a month ago\n<span>..</span>.\n</code></pre></div><p>Você pode ver que, para fazer isso funcionar, não passamos parâmetros de linha de comando para o <code>ls</code>. Ao invés disso, usamos o comando <code>sort-by</code>, fornecido pelo Nu, para ordenar a saída do comando <code>ls</code>.</p>\n<p>O Nu fornece muitos comandos que trabalham com tabelas. Por exemplo, podemos filtrar o conteúdo da tabela do <code>ls</code> para que ela mostre apenas os arquivos com mais de 4 kilobytes:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 4kb\n----+----------------+------+----------+----------+----------------+----------------\n <span>#  | name           | type | readonly | size     | accessed       | modified</span>\n----+----------------+------+----------+----------+----------------+----------------\n <span>0</span>  <span>|</span> IMG_1291.jpg   <span>|</span> File <span>|</span>          <span>|</span> <span>115.5</span> KB <span>|</span> a month ago    <span>|</span> <span>4</span> months ago\n <span>1</span>  <span>|</span> README.md      <span>|</span> File <span>|</span>          <span>|</span> <span>11.1</span> KB  <span>|</span> <span>2</span> days ago     <span>|</span> <span>2</span> days ago\n <span>2</span>  <span>|</span> IMG_1291.png   <span>|</span> File <span>|</span>          <span>|</span> <span>589.0</span> KB <span>|</span> a month ago    <span>|</span> a month ago\n <span>3</span>  <span>|</span> IMG_1381.jpg   <span>|</span> File <span>|</span>          <span>|</span> <span>81.0</span> KB  <span>|</span> a month ago    <span>|</span> <span>4</span> months ago\n <span>4</span>  <span>|</span> butterfly.jpeg <span>|</span> File <span>|</span>          <span>|</span> <span>4.2</span> KB   <span>|</span> a month ago    <span>|</span> a month ago\n <span>5</span>  <span>|</span> Cargo.lock     <span>|</span> File <span>|</span>          <span>|</span> <span>199.6</span> KB <span>|</span> <span>22</span> minutes ago <span>|</span> <span>22</span> minutes ago\n</code></pre></div><p>Assim como na filosofia Unix, fazer os comandos conversarem uns com os outros nos permite combiná-los de muitas maneiras diferentes. Vamos ver outro comando:</p>\n<div><pre><code><span>></span> <span>ps</span>\n-----+-------+----------+------+--------------------------------------------------------------------------------\n <span>#   | pid   | status   | cpu  | name</span>\n-----+-------+----------+------+--------------------------------------------------------------------------------\n <span>0</span>   <span>|</span> <span>1003</span>  <span>|</span> Unknown  <span>|</span> <span>0.00</span> <span>|</span>\n <span>1</span>   <span>|</span> <span>1515</span>  <span>|</span> Sleeping <span>|</span> <span>0.00</span> <span>|</span> /usr/lib/gnome-settings-daemon/gsd-screensaver-proxy\n <span>2</span>   <span>|</span> <span>2128</span>  <span>|</span> Sleeping <span>|</span> <span>0.00</span> <span>|</span> /usr/lib/gnome-settings-daemon/gsd-screensaver-proxy\n <span>3</span>   <span>|</span> <span>2285</span>  <span>|</span> Unknown  <span>|</span> <span>0.00</span> <span>|</span>\n <span>4</span>   <span>|</span> <span>8872</span>  <span>|</span> Sleeping <span>|</span> <span>0.00</span> <span>|</span> /usr/lib/gvfs/gvfsd-dnssd--spawner:1.23/org/gtk/gvfs/exec_spaw/4\n <span>5</span>   <span>|</span> <span>1594</span>  <span>|</span> Sleeping <span>|</span> <span>0.00</span> <span>|</span> /usr/lib/ibus/ibus-engine-simple\n</code></pre></div><p>Você deve conhecer o comando <code>ps</code> se já usou Linux. Com ele, vemos uma lista com todos os processos que o sistema está rodando atualmente, seus estados e seus nomes. Também podemos ver a carga de CPU para cada processo.</p>\n<p>E se quiséssemos mostrar somente os processos que estão usando a CPU de fato? Exatamente como fizemos com o comando <code>ls</code> anteriormente, podemos também manipular a tabela que o comando <code>ps</code> nos retorna:</p>\n<div><pre><code><span>></span> <span>ps</span> <span>|</span> where cpu <span>></span> <span>10</span>\n---+-------+----------+-------+-----------------------------\n <span># | pid   | status   | cpu   | name</span>\n---+-------+----------+-------+-----------------------------\n <span>0</span> <span>|</span> <span>1992</span>  <span>|</span> Sleeping <span>|</span> <span>44.52</span> <span>|</span> /usr/bin/gnome-shell\n <span>1</span> <span>|</span> <span>1069</span>  <span>|</span> Sleeping <span>|</span> <span>16.15</span> <span>|</span>\n <span>2</span> <span>|</span> <span>24116</span> <span>|</span> Sleeping <span>|</span> <span>13.70</span> <span>|</span> /opt/google/chrome/chrome\n <span>3</span> <span>|</span> <span>21976</span> <span>|</span> Sleeping <span>|</span> <span>12.67</span> <span>|</span> /usr/share/discord/Discord\n</code></pre></div><p>Até agora vimos como usar <code>ls</code> e <code>ps</code> para listar arquivos e processos. O Nu também oferece outros comandos que podem criar tabelas com informações úteis. A seguir vamos explorar <code>date</code> e <code>sys</code>.</p>\n<p>Ao executar <code>date</code> obtemos informações sobre a data e hora correntes:</p>\n<div><pre><code><span>></span> <span>date</span>\n------+-------+-----+------+--------+--------+----------\n year <span>|</span> month <span>|</span> day <span>|</span> hour <span>|</span> minute <span>|</span> second <span>|</span> timezone\n------+-------+-----+------+--------+--------+----------\n <span>2019</span> <span>|</span> <span>8</span>     <span>|</span> <span>17</span>  <span>|</span> <span>19</span>   <span>|</span> <span>20</span>     <span>|</span> <span>50</span>     <span>|</span> +12:00\n------+-------+-----+------+--------+--------+----------\n</code></pre></div><p>E ao executar <code>sys</code> obtemos informações sobre o sistema em que o Nu está rodando:</p>\n<div><pre><code><span>></span> sys\n----------+----------+-----------+----------+-----------+-----------\n <span>host</span>     <span>|</span> cpu      <span>|</span> disks     <span>|</span> mem      <span>|</span> temp      <span>|</span> net\n----------+----------+-----------+----------+-----------+-----------\n <span>[</span>object<span>]</span> <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span><span>3</span> items<span>]</span> <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span><span>3</span> items<span>]</span> <span>|</span> <span>[</span><span>3</span> items<span>]</span>\n----------+----------+-----------+----------+-----------+-----------\n</code></pre></div><p>Essa tabela é um pouco diferente das que vimos antes. O comando <code>sys</code> retorna uma tabela que contém tabelas estruturadas em suas células, ao invés de valores simples. Para dar uma olhada nesses dados, precisamos selecionar a coluna que queremos ver:</p>\n<div><pre><code><span>></span> sys <span>|</span> get <span>host</span>\n-------+------------------+----------+--------+----------+----------\n name  <span>|</span> release          <span>|</span> <span>hostname</span> <span>|</span> arch   <span>|</span> <span>uptime</span>   <span>|</span> <span>users</span>\n-------+------------------+----------+--------+----------+----------\n Linux <span>|</span> <span>5.0</span>.0-21-generic <span>|</span> pop-os   <span>|</span> x86_64 <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span><span>1</span> item<span>]</span>\n-------+------------------+----------+--------+----------+----------\n</code></pre></div><p>O comando <code>get</code> permite que tenhamos acesso ao conteúdo de uma coluna da tabela. Aqui, estamos olhando para dentro da coluna <code>host</code>, que contém informações a respeito da máquina host em que o Nu está rodando, como nome do SO (sistema operacional), o nome de host, a CPU e outros dados mais. Vamos ver os nomes dos usuários do sistema:</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.users\njonathan\n</code></pre></div><p>Nesse momento só tem um único usuário no sistema, chamado &quot;jonathan&quot;. Note que nós podemos passar um caminho e não apenas o nome de uma coluna. O Nu vai seguir esse caminho até o dado correspondente na tabela.</p>\n<p>Talvez você tenha notado mais alguma coisa de diferente. Ao invés de uma tabela, recebemos apenas um elemento simples: a string &quot;jonathan&quot;. O Nu trabalha tanto com tabelas de dados como com strings, que são uma parte importante da interação com comandos externos ao Nu.</p>\n<p>Vejamos como as strings funcionam fora do Nu. Vamos usar nosso exemplo anterior e executar o comando externo <code>echo</code>, presente na maioria dos SOs:</p>\n<div><pre><code><span>></span> sys <span>|</span> get host.users <span>|</span> <span>echo</span> <span>$it</span>\njonathan\n</code></pre></div><p>Se isso lhe parece bastante similar ao que tínhamos anteriormente, você tem um olho afiado! É similar, mas com uma diferença importante: chamamos <code>echo</code> com o valor retornado antes. Isso permite que passemos dados para o <code>echo</code> fora do Nu (ou para qualquer outro comando de fora do Nu, como <code>git</code>, por exemplo).</p>\n<p><em>Nota: você pode obter um texto de ajuda para quaisquer comandos embutidos do Nu usando o comando <code>help</code></em>:</p>\n<div><pre><code><span>></span> <span>help</span> config\nConfiguration management.\nUsage:\n  <span>></span> config <span>&lt;</span>subcommand<span>></span> <span>{</span>flags<span>}</span>\n\nSubcommands:\n  config get -\n  config <span>set</span> -\n  config set_into -\n  config <span>clear</span> -\n  config load -\n  config remove -\n  config path -\n\nFlags:\n  -h, --help: Display this <span>help</span> message\n</code></pre></div>",
      "date_modified": "2022-06-02T15:48:22.702Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Metadados",
      "url": "www.nushell.sh/pt-BR/book/metadados.html",
      "id": "www.nushell.sh/pt-BR/book/metadados.html",
      "content_html": "<h1 id=\"metadados\" tabindex=\"-1\"> Metadados</h1>\n<p>Usando o Nu vocë pode se deparar com momentos em que sente como se houvesse algo a mais acontecendo nos bastidores. Por exemplo, digamos que vocë vai tentar abrir um arquivo mas se esquece que ele é suportado pelo Nu e tenta convertê-lo novamente:</p>\n<div><pre><code><span>></span> <span>open</span> Cargo.toml <span>|</span> from toml\nerror: Expected a string from pipeline\n- shell:1:18\n<span>1</span> <span>|</span> <span>open</span> Cargo.toml <span>|</span> from toml\n  <span>|</span>                   ^^^^^^^^^ requires string input\n- shell:1:5\n<span>1</span> <span>|</span> <span>open</span> Cargo.toml <span>|</span> from toml\n  <span>|</span>      ---------- object originates from here\n</code></pre></div><p>A mensagem de erro nos diz não só que o que passamos para o <code>from toml</code> não era uma string, mas também de onde o valor veio originalmente. Como o Nu sabe isso?</p>\n<p>Valores que fluem pelo pipeline do Nu normalmente trazem consigo um conjunto adicional de informações, ou metadados, conhecidos como tags, semnelhantes às etiquetas penduradas nos produtos de uma loja. Essas tags não afetam os dados, mas proporcionam ao Nu uma forma de aprimorar a experiência de se trabalhar com esses dados.</p>\n<p>Vamos executar o comando <code>open</code> de novo, mas, dessa vez, vamos olhar as tags que ele retorna:</p>\n<div><pre><code><span>></span> <span>open</span> Cargo.toml <span>|</span> tags\n----------+------------------------------------------\n span     <span>|</span> origin\n----------+------------------------------------------\n <span>[</span>object<span>]</span> <span>|</span> /home/jonathan/Source/nushell/Cargo.toml\n----------+------------------------------------------\n</code></pre></div><p>Atualmente, rastreamos dois pedaços de metadados dos valores no pipeline. Você pode observar que temos a origem, que nos dá a localização de onde os dados foram carregados, o que pode ajudar o Nu a entender melhor como apresentá-los.</p>\n<p>Há também um coluna intervalo (span). Vamos ver mais de perto:</p>\n<div><pre><code><span>></span> <span>open</span> Cargo.toml <span>|</span> tags <span>|</span> get span\n-------+-----\n start <span>|</span> end\n-------+-----\n <span>5</span>     <span>|</span> <span>15</span>\n-------+-----\n</code></pre></div><p>O início (start) e fim (end) do intervalo aqui se referem a onde o sublinhado ficará na linha da mensagem de erro. Se você contar até depois do 5 e então até 15, verá que esse intervalo coincide com o nome do arquivo &quot;Cargo.toml&quot;. É assim que o erro que vimos antes sabe onde sublinhar a mensagem.</p>\n",
      "date_modified": "2022-06-02T15:48:22.703Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "O pipeline",
      "url": "www.nushell.sh/pt-BR/book/pipeline.html",
      "id": "www.nushell.sh/pt-BR/book/pipeline.html",
      "content_html": "<h1 id=\"o-pipeline\" tabindex=\"-1\"> O pipeline</h1>\n<p>Um dos principais designs do Nu é o pipeline, uma ideia de design que tem suas raízes décadas atrás, na filosofia original por trás do Unix. Assim como Nu se extende a partir do tipo de dado string do Unix, também extende a ideia do pipeline para incluir mais do que apenas texto.</p>\n<h2 id=\"basico\" tabindex=\"-1\"> Básico</h2>\n<p>Um pipeline é construído com três partes: a entrada, o filtro e a saída.</p>\n<div><pre><code><span>></span> <span>open</span> <span>\"Cargo.toml\"</span> <span>|</span> inc package.version <span>|</span> save <span>\"Cargo_new.toml\"</span>\n</code></pre></div><p>O primeiro comando, <code>open &quot;Cargo.toml&quot;</code>, é uma entrada (às vezes também chamado de &quot;fonte&quot; ou &quot;produtor&quot;). Ele cria ou carrega dados com os quais alimenta o pipeline. É a partir da entrada que os pipelines conseguem dados para trabalhar. Comandos como <code>ls</code> também são entradas, já que pegam dados do sistema de arquivos e os enviam através dos pipelines para que possam ser usados adiante.</p>\n<p>O segundo comando, <code>inc package.version</code>, é um filtro. Filtros recebem dados e normalmente fazem alguma coisa com eles. Podem mudá-los (como o comando <code>inc</code> no nosso exemplo), ou podem executar outra operação, como registro de log, conforme os valores passam.</p>\n<p>O último comando, <code>save &quot;Cargo_new.toml&quot;</code>, é uma saída (às vezes chamado de &quot;pia&quot; ou &quot;ralo&quot;). Uma saída recebe dados do pipeline e executa alguma operação final sobre eles. No nosso exemplo, salvamos o que chega pelo pipeline em um arquivo como passo final. Outros tipos de comandos de saída podem exibir os dados para o usuário.</p>\n<h2 id=\"trabalhando-com-comandos-externos\" tabindex=\"-1\"> Trabalhando com comandos externos</h2>\n<p>Os comandos do Nu se comunicam entre si usando tipos de dados fornecidos pelo próprio Nu (veja <a href=\"/pt-BR/book/tipos_de_dados.html\">tipos de dados</a>), mas e os comandos de fora do Nu? Vejamos alguns exemplos de como trabalhar com comandos externos:</p>\n<p><code>comando_interno | comando_externo</code></p>\n<p>Dados fluem do comando_interno para o comando_externo. Espera-se que esses dados sejam strings, para que possam ser enviados para a entrada padrão (<code>stdin</code>) do comando_externo.</p>\n<p><code>comando_externo | comando_interno</code></p>\n<p>Dados vindo de um comando externo para o Nu são agrupados em uma string única e, então, passados para o comando_interno. Comandos como <code>lines</code> ajudam a trazer dados de comandos externos de modo a facilitar sua utilização.</p>\n<p><code>comando_externo_1 | comando_externo_2</code></p>\n<p>Nu trabalha com dados canalizados entre dois comandos externos da mesma maneira que em outros shells, como Bash. A saída padrão (<code>stdout</code>) do comando_externo_1 é conectada à entrada padrão (<code>stdin</code>) do comando_externo_2, permitindo que os dados fluam naturalmente entre os dois comandos.</p>\n<h2 id=\"nos-bastidores\" tabindex=\"-1\"> Nos bastidores</h2>\n<p>Você pode ter se perguntado como vemos uma tabela se o <code>ls</code> é uma entrada e não uma saída. Nu adiciona automaticamente por nós uma saída usando outro comando chamado <code>autoview</code>, que é adicionado a qualquer pipeline que não tenha uma saída que nos permita ver o resultado.</p>\n<p>Com efeito, o comando:</p>\n<div><pre><code><span>></span> <span>ls</span>\n</code></pre></div><p>E o pipeline:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> autoview\n</code></pre></div><p>São a mesma coisa.</p>\n",
      "date_modified": "2022-06-02T15:48:22.703Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Plugins",
      "url": "www.nushell.sh/pt-BR/book/plugins.html",
      "id": "www.nushell.sh/pt-BR/book/plugins.html",
      "content_html": "<h1 id=\"plugins\" tabindex=\"-1\"> Plugins</h1>\n<p>A funcionalidade do Nu pode ser extendida usando plugins. Os plugins podem desenpenhar muitas das mesmas operações que os comandos embutidos do Nu, com o benefício adicional de que eles podem ser incluídos separadamente do Nu em si.</p>\n<p>Para adicionar um plugin, simplesmente implemente-o e coloque o binário no seu PATH. Os nomes dos arquivos de plugins do Nu começam com <code>nu_plugin_</code> para que o Nu possa encontrá-los em meio aos outros binários no seu PATH.</p>\n<p><strong>Nota:</strong> no futuro, plugins podem ter um local específico em precisem ser colocados a fim de que o Nu possa encontrá-los.</p>\n<p>Quando o Nu inicia, ele faz uma busca no sistema e carrega os plugins que encontra.</p>\n<p>O protocolo que os plugins do Nu usam estão sujeitos a mudar enquanto o Nu estiver em pleno desenvolvimento. O melhor lugar para aprender mais sobre o protocolo e como criar seus próprios plugins é lendo o código fonte para os <a href=\"https://github.com/nushell/nushell/tree/master/src/plugins\" target=\"_blank\" rel=\"noopener noreferrer\">plugins no repositório do Nu</a>. Você pode também se dirigir ao <a href=\"https://github.com/nushell/contributor-book/blob/master/en/plugins.md\" target=\"_blank\" rel=\"noopener noreferrer\">capítulo de plugins no livro do colaborador</a>.</p>\n",
      "date_modified": "2022-06-02T15:48:22.703Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Shells em shells",
      "url": "www.nushell.sh/pt-BR/book/shells_em_shells.html",
      "id": "www.nushell.sh/pt-BR/book/shells_em_shells.html",
      "content_html": "<h1 id=\"shells-em-shells\" tabindex=\"-1\"> Shells em shells</h1>\n<h2 id=\"trabalhando-em-multiplos-diretorios\" tabindex=\"-1\"> Trabalhando em múltiplos diretórios</h2>\n<p>Embora seja comum trabalhar em um único diretório, pode ser útil trabalhar em múltiplos locais ao mesmo tempo. Para isso, Nu oferece o conceito de &quot;shells&quot;. Como o nome implica, eles são uma maneira de executar múltiplos shells em um, permitindo que você salte rapidamente entre diretórios e muito mais.</p>\n<p>Para começar, vamos entrar num diretório:</p>\n<div><pre><code>/home/jonathan/Source/nushell<span>(</span>master<span>)</span><span>></span> enter <span>..</span>/lark\n/home/jonathan/Source/lark<span>(</span>master<span>)</span><span>></span> <span>ls</span>\n----+----------------+-----------+----------+---------+---------------+---------------\n <span>#  | name           | type      | readonly | size    | accessed      | modified</span>\n----+----------------+-----------+----------+---------+---------------+---------------\n <span>0</span>  <span>|</span> Cargo.toml     <span>|</span> File      <span>|</span>          <span>|</span> <span>2.2</span> KB  <span>|</span> <span>6</span> months ago  <span>|</span> <span>6</span> months ago\n <span>1</span>  <span>|</span> target         <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB  <span>|</span> <span>10</span> months ago <span>|</span> <span>6</span> months ago\n <span>2</span>  <span>|</span> notes          <span>|</span> Directory <span>|</span>          <span>|</span> <span>4.1</span> KB  <span>|</span> <span>10</span> months ago <span>|</span> <span>6</span> months ago\n</code></pre></div><p>Entrar é semlhante a mudar de diretório (como vimos com o comando <code>cd</code>), permitindo que você salte para o diretório dentro do qual vai trabalhar. Ao invés de mudar de diretório, nós agora estamos em dois diretórios. Para ver isso mais claramente, podemos usar o comando <code>shells</code> para listar os diretórios ativos agora:</p>\n<div><pre><code>/home/jonathan/Source/lark<span>(</span>master<span>)</span><span>></span> shells\n---+---+------------+-------------------------------\n <span># |   | name       | path</span>\n---+---+------------+-------------------------------\n <span>0</span> <span>|</span>   <span>|</span> filesystem <span>|</span> /home/jonathan/Source/nushell\n <span>1</span> <span>|</span> X <span>|</span> filesystem <span>|</span> /home/jonathan/Source/lark\n---+---+------------+-------------------------------\n</code></pre></div><p>O comando <code>shells</code> nos mostra que há dois diretórios ativos agora: nosso diretório original &quot;nushell&quot; e agora esse novo diretório &quot;lark&quot;.</p>\n<p>Podemos saltar entre esses shells com os atalhos <code>n</code> e <code>p</code>, abrevisções para &quot;next&quot; (próximo) e &quot;previous&quot; (anterior):</p>\n<div><pre><code>/home/jonathan/Source/lark(master)> n\n/home/jonathan/Source/nushell(master)> p\n/home/jonathan/Source/lark(master)>\n</code></pre></div><p>Podemos ver a alteração de diretórios, mas sempre somos capazes de voltar para um diretório anterior em que estávamos trabalhando. Isso nos permite trabalhar em múltiplos diretórios na mesma sessão.</p>\n<h2 id=\"saindo-do-shell\" tabindex=\"-1\"> Saindo do shell</h2>\n<p>Você pode sair de um shell em que tenha entrado (usando <code>enter</code>) através do comando <code>exit</code>. Se esse for o último shell aberto, Nu será encerrado.</p>\n<p>Você sempre pode emcerrar o Nu, mesmo que múltiplos shells estejam ativos, passando o modificador <code>--now</code> para o comando <code>exit</code>. Assim: <code>exit --now</code>.</p>\n<h2 id=\"indo-alem-de-diretorios\" tabindex=\"-1\"> Indo além de diretórios</h2>\n<p>O Nu também pode criar shells a partir de outras coisas além de caminhos do sistema de arquivos. Digamos, por exemplo, que você está trabalhando com uma grande massa de dadose não quer perder seu lugar dentro dela.</p>\n<p>Para ver como isso funciona, vamos fazer o seguinte exercício. Atualmente, listamos os <a href=\"/pt-BR/book/plugins.html\">plugins</a> que desenvolvemos para o Nu no arquivo &quot;Cargo.toml&quot;. Digamos que tenhamos acabado de criar um novo plugin no diretório src/plugins chamado &quot;doc.rs&quot; e queremos saber se ele também está listado, de forma que possa ser compilado e instalado corretamente.</p>\n<p>Vamos entrar no arquivo &quot;Cargo.toml&quot; do código fonte do Nu:</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell<span>(</span>master<span>)</span><span>></span> enter Cargo.toml\n/<span>></span> <span>ls</span>\n------------+--------------+------------------+----------+----------\n bin        <span>|</span> dependencies <span>|</span> dev-dependencies <span>|</span> lib      <span>|</span> package\n------------+--------------+------------------+----------+----------\n <span>[</span><span>11</span> items<span>]</span> <span>|</span> <span>[</span>object<span>]</span>     <span>|</span> <span>[</span>object<span>]</span>         <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span>object<span>]</span>\n------------+--------------+------------------+----------+----------\n</code></pre></div><p>Até o momento, apenas entramos no arquivo (usando o comando <code>enter</code>) e podemos ver o que há dentro dele pela tabela que o <code>ls</code> nos retorna. Se você prestar bastante atenção, dessa vez entramos num arquivo cujo formato o Nu entende (.toml). O Nu também projeta o conteúdo do arquivo em algo semelhante a um sistema de arquivos para que possamos explorá-lo como se fosse um sistema de arquivos regular.</p>\n<p>Antes de continuarmos, vamos checar os shells ativos:</p>\n<div><pre><code>/<span>></span> shells\n---+---+-------------------------------------------------+------------------------------------\n <span># |   | name                                            | path</span>\n---+---+-------------------------------------------------+------------------------------------\n <span>0</span> <span>|</span>   <span>|</span> filesystem                                      <span>|</span> /Users/andresrobalino/Code/nushell\n <span>1</span> <span>|</span> X <span>|</span> <span>{</span>/Users/andresrobalino/Code/nushell/Cargo.toml<span>}</span> <span>|</span> /\n---+---+-------------------------------------------------+------------------------------------\n\n</code></pre></div><p>Podemos observar que temos dois shells ativos e que estamos agora dentro do arquivo &quot;Cargo.toml&quot; com um caminho raíz padrão &quot;/&quot;. Vamos ver seu contéudo novamente:</p>\n<div><pre><code>/<span>></span> <span>ls</span>\n------------+--------------+------------------+----------+----------\n bin        <span>|</span> dependencies <span>|</span> dev-dependencies <span>|</span> lib      <span>|</span> package\n------------+--------------+------------------+----------+----------\n <span>[</span><span>11</span> items<span>]</span> <span>|</span> <span>[</span>object<span>]</span>     <span>|</span> <span>[</span>object<span>]</span>         <span>|</span> <span>[</span>object<span>]</span> <span>|</span> <span>[</span>object<span>]</span>\n------------+--------------+------------------+----------+----------\n</code></pre></div><p>O que estamos procurando pode estar dentro da coluna &quot;bin&quot;, então vamos entrar lá:</p>\n<div><pre><code><span>></span> <span>cd</span> bin\n/bin<span>></span> <span>ls</span>\n----+----------------------+---------------------------\n <span>#  | name                 | path</span>\n----+----------------------+---------------------------\n <span>0</span>  <span>|</span> nu_plugin_inc        <span>|</span> src/plugins/inc.rs\n <span>1</span>  <span>|</span> nu_plugin_sum        <span>|</span> src/plugins/sum.rs\n <span>2</span>  <span>|</span> nu_plugin_add        <span>|</span> src/plugins/add.rs\n <span>3</span>  <span>|</span> nu_plugin_edit       <span>|</span> src/plugins/edit.rs\n <span>4</span>  <span>|</span> nu_plugin_str        <span>|</span> src/plugins/str.rs\n <span>5</span>  <span>|</span> nu_plugin_skip       <span>|</span> src/plugins/skip.rs\n <span>6</span>  <span>|</span> nu_plugin_sys        <span>|</span> src/plugins/sys.rs\n <span>7</span>  <span>|</span> nu_plugin_tree       <span>|</span> src/plugins/tree.rs\n <span>8</span>  <span>|</span> nu_plugin_binaryview <span>|</span> src/plugins/binaryview.rs\n <span>9</span>  <span>|</span> nu_plugin_textview   <span>|</span> src/plugins/textview.rs\n <span>10</span> <span>|</span> nu                   <span>|</span> src/main.rs\n----+----------------------+---------------------------\n</code></pre></div><p>Daqui, sempre podemos voltar para o diretório em que estávamos trabalhando antes usando p (de prévio, anterior).</p>\n<div><pre><code>/bin<span>></span> p\n</code></pre></div><p>Vamos verificar os shells de novo:</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell<span>(</span>master<span>)</span><span>></span> shells\n---+---+-------------------------------------------------+------------------------------------\n <span># |   | name                                            | path</span>\n---+---+-------------------------------------------------+------------------------------------\n <span>0</span> <span>|</span> X <span>|</span> filesystem                                      <span>|</span> /Users/andresrobalino/Code/nushell\n <span>1</span> <span>|</span>   <span>|</span> <span>{</span>/Users/andresrobalino/Code/nushell/Cargo.toml<span>}</span> <span>|</span> /bin\n---+---+-------------------------------------------------+------------------------------------\n\n</code></pre></div><p>Estamos de volta ao diretório onde estávamos trabalhando antes de entrar no arquivo &quot;Cargo.toml&quot;. Agora vamos mudar para o diretório onde então os códigos fonte dos plugins e rastreá-los:</p>\n<div><pre><code>/Users/andresrobalino/Code/nushell<span>(</span>master<span>)</span><span>></span> <span>cd</span> src/plugins/\n/Users/andresrobalino/Code/nushell/src/plugins<span>(</span>master<span>)</span><span>></span> <span>ls</span>\n----+---------------+------+----------+---------+------------+------------\n <span>#  | name          | type | readonly | size    | accessed   | modified</span>\n----+---------------+------+----------+---------+------------+------------\n <span>0</span>  <span>|</span> doc.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> a week ago <span>|</span> a week ago\n <span>1</span>  <span>|</span> sum.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> a week ago <span>|</span> a week ago\n <span>2</span>  <span>|</span> inc.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>11.8</span> KB <span>|</span> a week ago <span>|</span> a week ago\n <span>3</span>  <span>|</span> sys.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>9.2</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>4</span>  <span>|</span> edit.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> a week ago <span>|</span> a week ago\n <span>5</span>  <span>|</span> str.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>21.4</span> KB <span>|</span> <span>5</span> days ago <span>|</span> <span>5</span> days ago\n <span>6</span>  <span>|</span> secret.rs     <span>|</span> File <span>|</span>          <span>|</span> <span>1.8</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>7</span>  <span>|</span> skip.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>1.7</span> KB  <span>|</span> a week ago <span>|</span> a week ago\n <span>8</span>  <span>|</span> binaryview.rs <span>|</span> File <span>|</span>          <span>|</span> <span>13.0</span> KB <span>|</span> a week ago <span>|</span> a week ago\n <span>9</span>  <span>|</span> tree.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> a week ago <span>|</span> a week ago\n <span>10</span> <span>|</span> add.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> a week ago <span>|</span> a week ago\n <span>11</span> <span>|</span> textview.rs   <span>|</span> File <span>|</span>          <span>|</span> <span>9.4</span> KB  <span>|</span> <span>5</span> days ago <span>|</span> <span>5</span> days ago\n----+---------------+------+----------+---------+------------+------------\n</code></pre></div><p>Podemos agora comparar os dois para ver se há algum plugin faltando ou a mais que precisemos adicionao ao nosso arquivo (claramente precisamos adicionar o plugin <code>doc.rs</code> que criamos ao arquivo &quot;Cargo.toml&quot;!).</p>\n",
      "date_modified": "2022-06-02T15:48:22.703Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Tipos de dados",
      "url": "www.nushell.sh/pt-BR/book/tipos_de_dados.html",
      "id": "www.nushell.sh/pt-BR/book/tipos_de_dados.html",
      "content_html": "<h1 id=\"tipos-de-dados\" tabindex=\"-1\"> Tipos de dados</h1>\n<p>Tradicionalmente, comandos de shell do Unix comunicavam-se entre si através de strings de texto. Um comando gerava texto como saída através da saída padrão (normalmente abreviada como 'stdout') e o outro comando lia o texto pela entrada padrão (ou 'stdin'). Desse modo, os dois comandos podiam se comunicar.</p>\n<p>Podemos pensar nesse tipo de comunicação como baseada em texto ou baseada em strings.</p>\n<p>Nu adota essa abordagem para seus comandos e a amplia para incluir outros tipos de dados. Atualmente, Nu suporta dois tipos de dados: simples e estruturados.</p>\n<h2 id=\"dados-simples\" tabindex=\"-1\"> Dados simples</h2>\n<p>Como muitas linguagens de programação, Nu modela dados usando um conjunto de tipos de dados simples e estruturados. Tipos de dados simples incluem inteiros, decimais, strings, booleanos, datas e caminhos. Inclui também um tipo especial para tamanhos de arquivos.</p>\n<h3 id=\"inteiros\" tabindex=\"-1\"> Inteiros</h3>\n<p>Números inteiros. Exemplos incluem 1, 5 e 100.</p>\n<h3 id=\"decimais\" tabindex=\"-1\"> Decimais</h3>\n<p>Decimais são números com um componente fracionário. Exemplos incluem 1.5, 2.0 e 15.333.</p>\n<h3 id=\"strings\" tabindex=\"-1\"> Strings</h3>\n<p>Strings são a maneira fundamental de se representar texto. Aparecem entre aspas duplas. Exemplos incluem &quot;Fred&quot;, &quot;myname.txt&quot; e &quot;Lynchburg, VA&quot;.</p>\n<p>Strings no Nu são compatíveis com Unicode por padrão, então pode-se usar texto UTF-8 com facilidade.</p>\n<h3 id=\"booleanos\" tabindex=\"-1\"> Booleanos</h3>\n<p>Booleanos representam os valores verdadeiro ou falso. Ao invés de se escrever seus valores diretamente, são frequentemente o resultado de uma comparação.</p>\n<h3 id=\"datas\" tabindex=\"-1\"> Datas</h3>\n<p>Datas e horários são mantidos juntos no tipo de dado Data. Valores de Data usados pelo sistema são compatíceis com fusos horários e usam o fuso UTC por padrão.</p>\n<h3 id=\"caminhos\" tabindex=\"-1\"> Caminhos</h3>\n<p>Caminhos são uma forma independente de plataforma de se representar o caminho de um arquivo num dado sistema operacional. Exemplos incluem /usr/bin e C:\\Users\\file.txt.</p>\n<h3 id=\"bytes\" tabindex=\"-1\"> Bytes</h3>\n<p>Tamanhos de arquivos são mantidos num tipo especial de inteiros chamado bytes. Exemplos incluem 100, 15kb e 100mb.</p>\n<h2 id=\"dados-estruturados\" tabindex=\"-1\"> Dados estruturados</h2>\n<p>Dados estruturados são criados a partir de dados simples. Por exemplo, em vez de um inteiro simples, dados estruturados nos dão uma maneira de representar múltiplos inteiros no mesmo valor. Aqui está uma lista dos tipos de daods estruturados suportados atualmente: objetos, dados binários, listas e blocos.</p>\n<h3 id=\"objetos\" tabindex=\"-1\"> Objetos</h3>\n<p>O tipo de dados Objeto representa o que você veria em uma linha de dados em uma tabela. Ele tem diferentes elementos de dados e a cada elemento é dado um nome de coluna.</p>\n<h3 id=\"dados-binarios\" tabindex=\"-1\"> Dados binários</h3>\n<p>Dados binários, como os dados de um arquivo de imagem, são um agrupamento cru de bytes.</p>\n<h3 id=\"listas\" tabindex=\"-1\"> Listas</h3>\n<p>Listas podem guardar mais de um valor. Isso faz com que sejam um bom container para linhas de dados em uma tabela.</p>\n<h3 id=\"blocos\" tabindex=\"-1\"> Blocos</h3>\n<p>Blocos representam a bloco de código no Nu. Por exemplo, no comando <code>where { $it.size &gt; 10kb }</code> o bloco é a porção contida entre chaves, <code>{ $it.size &gt; 10kb }</code>. Blocos são uma maneira útil de representar código que pode ser executado em linha de dados.</p>\n",
      "date_modified": "2022-06-02T15:48:22.704Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Trabalhando com tabelas",
      "url": "www.nushell.sh/pt-BR/book/trabalhando_com_tabelas.html",
      "id": "www.nushell.sh/pt-BR/book/trabalhando_com_tabelas.html",
      "content_html": "<h1 id=\"trabalhando-com-tabelas\" tabindex=\"-1\"> Trabalhando com tabelas</h1>\n<p>Uma forma comum de ver os dados no Nu é por meio de uma tabela. O Nu traz um conjunto de comandos para se trabalhar com tabelas, facilitar a localização do que você procura e restringir os dados apenas ao que você precisa.</p>\n<p>Para começar, vamos usar a seguinte tabela:</p>\n<div><pre><code><span>></span> <span>ls</span>\n---+---------------+------+----------+---------+------------+------------\n <span># | name          | type | readonly | size    | accessed   | modified</span>\n---+---------------+------+----------+---------+------------+------------\n <span>0</span> <span>|</span> add.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>1</span> <span>|</span> sum.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>2</span> <span>|</span> inc.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>11.8</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>3</span> <span>|</span> str.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>21.4</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>4</span> <span>|</span> skip.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>1.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>5</span> <span>|</span> textview.rs   <span>|</span> File <span>|</span>          <span>|</span> <span>9.4</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>6</span> <span>|</span> binaryview.rs <span>|</span> File <span>|</span>          <span>|</span> <span>13.0</span> KB <span>|</span> a day ago  <span>|</span> a day ago\n <span>7</span> <span>|</span> edit.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>8</span> <span>|</span> tree.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>9</span> <span>|</span> sys.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>9.2</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n---+---------------+------+----------+---------+------------+------------\n</code></pre></div><h2 id=\"ordenando-os-dados\" tabindex=\"-1\"> Ordenando os dados</h2>\n<p>Podemos ordenar uma tabela chamando o comando <code>sort-by</code> e informando quais colunas queremos usar na ordenação. Digamos que queremos ordenar nossa tabela pelo tamanho do arquivo:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size\n---+---------------+------+----------+---------+------------+------------\n <span># | name          | type | readonly | size    | accessed   | modified</span>\n---+---------------+------+----------+---------+------------+------------\n <span>0</span> <span>|</span> skip.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>1.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>1</span> <span>|</span> add.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>2</span> <span>|</span> edit.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>3</span> <span>|</span> sum.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>4</span> <span>|</span> tree.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>5</span> <span>|</span> sys.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>9.2</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>6</span> <span>|</span> textview.rs   <span>|</span> File <span>|</span>          <span>|</span> <span>9.4</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>7</span> <span>|</span> inc.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>11.8</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>8</span> <span>|</span> binaryview.rs <span>|</span> File <span>|</span>          <span>|</span> <span>13.0</span> KB <span>|</span> a day ago  <span>|</span> a day ago\n <span>9</span> <span>|</span> str.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>21.4</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n---+---------------+------+----------+---------+------------+------------\n</code></pre></div><p>Podemos ordenar uma tabela por qualquer coluna que possa ser comparada. Por exemplo, poderíamos também ter ordenado a tabela acima usando as colunas &quot;name&quot;, &quot;accessed&quot; ou &quot;modified&quot;.</p>\n<h2 id=\"selecionando-os-dados-que-deseja\" tabindex=\"-1\"> Selecionando os dados que deseja</h2>\n<p>Podemos selecionar dados de uma tabela escolhendo colunas ou linhas específicas. Vamos escolher algumas colunas da nossa tabela:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> <span>select</span> name size\n---+---------------+---------\n <span># | name          | size</span>\n---+---------------+---------\n <span>0</span> <span>|</span> add.rs        <span>|</span> <span>2.7</span> KB\n <span>1</span> <span>|</span> sum.rs        <span>|</span> <span>3.0</span> KB\n <span>2</span> <span>|</span> inc.rs        <span>|</span> <span>11.8</span> KB\n <span>3</span> <span>|</span> str.rs        <span>|</span> <span>21.4</span> KB\n <span>4</span> <span>|</span> skip.rs       <span>|</span> <span>1.7</span> KB\n <span>5</span> <span>|</span> textview.rs   <span>|</span> <span>9.4</span> KB\n <span>6</span> <span>|</span> binaryview.rs <span>|</span> <span>13.0</span> KB\n <span>7</span> <span>|</span> edit.rs       <span>|</span> <span>2.7</span> KB\n <span>8</span> <span>|</span> tree.rs       <span>|</span> <span>3.0</span> KB\n <span>9</span> <span>|</span> sys.rs        <span>|</span> <span>9.2</span> KB\n---+---------------+---------\n</code></pre></div><p>Isso ajuda a criar uma tabela mais focada no que precisamos. A seguir, digamos que queremos ver apenas os 5 menores arquivos do diretório:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> first <span>5</span>\n---+---------+------+----------+--------+------------+------------\n <span># | name    | type | readonly | size   | accessed   | modified</span>\n---+---------+------+----------+--------+------------+------------\n <span>0</span> <span>|</span> skip.rs <span>|</span> File <span>|</span>          <span>|</span> <span>1.7</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>1</span> <span>|</span> add.rs  <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>2</span> <span>|</span> edit.rs <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>3</span> <span>|</span> sum.rs  <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>4</span> <span>|</span> tree.rs <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n---+---------+------+----------+--------+------------+------------\n</code></pre></div><p>Note que primeiro ordenamos a tabela por tamanho e depois usamos o <code>first 5</code> para retornar as primeiras 5 linhas da tabela.</p>\n<p>Você também pode usar <code>skip</code> para pular as linhas que não quiser. Vamos pular as duas primeiras das 5 linhas que retornamos acima:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> first <span>5</span> <span>|</span> skip <span>2</span>\n---+---------+------+----------+--------+------------+------------\n <span># | name    | type | readonly | size   | accessed   | modified</span>\n---+---------+------+----------+--------+------------+------------\n <span>0</span> <span>|</span> edit.rs <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>1</span> <span>|</span> sum.rs  <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>2</span> <span>|</span> tree.rs <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n---+---------+------+----------+--------+------------+------------\n</code></pre></div><p>Restringimos os dados às 3 linhas que nos interessam.</p>\n<p>Vamos examinar alguns outros comandos para selecionar dados. Você pode ter se perguntado por que as linhas da tabela são numeradas. Isso serve como uma maneira prática de acessar uma linha específica. Vamos ordenar nossa tabela pelo nome do arquivo e então escolher uma das linhas com o comando <code>nth</code>, usando o número da linha:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by name\n---+---------------+------+----------+---------+------------+------------\n <span># | name          | type | readonly | size    | accessed   | modified</span>\n---+---------------+------+----------+---------+------------+------------\n <span>0</span> <span>|</span> add.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>1</span> <span>|</span> binaryview.rs <span>|</span> File <span>|</span>          <span>|</span> <span>13.0</span> KB <span>|</span> a day ago  <span>|</span> a day ago\n <span>2</span> <span>|</span> edit.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>2.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>3</span> <span>|</span> inc.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>11.8</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>4</span> <span>|</span> skip.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>1.7</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>5</span> <span>|</span> str.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>21.4</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>6</span> <span>|</span> sum.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>7</span> <span>|</span> sys.rs        <span>|</span> File <span>|</span>          <span>|</span> <span>9.2</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>8</span> <span>|</span> textview.rs   <span>|</span> File <span>|</span>          <span>|</span> <span>9.4</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n <span>9</span> <span>|</span> tree.rs       <span>|</span> File <span>|</span>          <span>|</span> <span>3.0</span> KB  <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n---+---------------+------+----------+---------+------------+------------\n\n<span>></span> <span>ls</span> <span>|</span> sort-by name <span>|</span> nth <span>5</span>\n--------+------+----------+---------+------------+------------\n name   <span>|</span> <span>type</span> <span>|</span> <span>readonly</span> <span>|</span> size    <span>|</span> accessed   <span>|</span> modified\n--------+------+----------+---------+------------+------------\n str.rs <span>|</span> File <span>|</span>          <span>|</span> <span>21.4</span> KB <span>|</span> <span>2</span> days ago <span>|</span> <span>2</span> days ago\n--------+------+----------+---------+------------+------------\n</code></pre></div><h2 id=\"obtendo-dados-de-uma-tabela\" tabindex=\"-1\"> Obtendo dados de uma tabela</h2>\n<p>Até agora, trabalhamos as tabelas reduzindo-as para somente o que precisamos. Às vezes queremos ir um passo além e só ver os valores das células e não de uma coluna toda. Digamos, por exemplo, que queremos somente uma lista com os nomes do arquivos. Para isso, usamos o comando <code>get</code>:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> get name\n---+---------------\n <span># | value</span>\n---+---------------\n <span>0</span> <span>|</span> add.rs\n <span>1</span> <span>|</span> sum.rs\n <span>2</span> <span>|</span> inc.rs\n <span>3</span> <span>|</span> str.rs\n <span>4</span> <span>|</span> skip.rs\n <span>5</span> <span>|</span> textview.rs\n <span>6</span> <span>|</span> binaryview.rs\n <span>7</span> <span>|</span> edit.rs\n <span>8</span> <span>|</span> tree.rs\n <span>9</span> <span>|</span> sys.rs\n---+---------------\n</code></pre></div><p>Agora temos os valores para cada um dos nomes de arquivo.</p>\n<p>Parece muito com o comando <code>select</code> que vimos antes, então vamos colocá-lo aqui de novo para compararmos os dois:</p>\n<div><pre><code><span>></span> <span>ls</span> <span>|</span> <span>select</span> name\n---+---------------\n <span># | name</span>\n---+---------------\n <span>0</span> <span>|</span> add.rs\n <span>1</span> <span>|</span> sum.rs\n <span>2</span> <span>|</span> inc.rs\n <span>3</span> <span>|</span> str.rs\n <span>4</span> <span>|</span> skip.rs\n <span>5</span> <span>|</span> textview.rs\n <span>6</span> <span>|</span> binaryview.rs\n <span>7</span> <span>|</span> edit.rs\n <span>8</span> <span>|</span> tree.rs\n <span>9</span> <span>|</span> sys.rs\n---+---------------\n</code></pre></div><p>São muito parecidos! Vamos tentar explicar a diferença entre esses dois comandos para esclarecer:</p>\n<ul>\n<li><code>select</code> - cria uam nova tabela que inclui apenas as colunas especificadas</li>\n<li><code>get</code> - retorna os valores dentro da coluna especificada</li>\n</ul>\n<p>A única maneira de diferenciá-los olhando para a tabela é o nome característico da coluna <code>value</code>, que nos permite saber que se trata de uma lista de valores com a qual podemos trabalhar.</p>\n<p>O comando <code>get</code> pode ir um passo além e receber um caminho para os dados mais profundos na tabela. Isso simplifica o trabalho com dados mais complexos, como as estruturas que você pode encontrar num arquivo .json.</p>\n<h2 id=\"modificando-dados-em-uma-tabela\" tabindex=\"-1\"> Modificando dados em uma tabela</h2>\n<p>Além de selecionar dados de uma tabela, podemos também alterar o que a tabela traz. Podemos querer adicionar novas colunas ou editar o conteúdo de uma célula. No Nu, em vez de editar localmente, cada comando nesta seção retornará uma nova tabela no pipeline.</p>\n<h3 id=\"adicionando-uma-nova-coluna\" tabindex=\"-1\"> Adicionando uma nova coluna</h3>\n<p>Podemos usar o comando <code>add</code> para adicionar uma nova coluna na tabela. Vejamos um exemplo:</p>\n<div><pre><code><span>></span> <span>open</span> rustfmt.toml\n---------\n edition\n---------\n <span>2018</span>\n---------\n</code></pre></div><p>Vamos adicionar uma coluna chamada &quot;next_edition&quot; com o valor 2021:</p>\n<div><pre><code><span>></span> <span>open</span> rustfmt.toml <span>|</span> <span>add</span> next_edition <span>2021</span>\n---------+--------------\n edition <span>|</span> next_edition\n---------+--------------\n <span>2018</span>    <span>|</span> <span>2021</span>\n---------+--------------\n</code></pre></div><p>Note que, se abrirmos o arquivo original, seu conteúdo permanece o mesmo:</p>\n<div><pre><code><span>></span> <span>open</span> rustfmt.toml\n---------\n edition\n---------\n <span>2018</span>\n---------\n</code></pre></div><p>Alterações no Nu são alterações funcionais, isto é, atuam sobre os valores em si ao invés de tentar causar uma alteração permanente, o que nos permite executar muitos tipos diferentes de ações no nosso pipeline até que estejamos prontos para escrever o resultado com quaisquer mudanças, se assim quisermos. Aqui poderíamos salvar o resultado usando o comando <code>save</code>:</p>\n<div><pre><code><span>></span> <span>open</span> rustfmt.toml <span>|</span> <span>add</span> next_edition <span>2021</span> <span>|</span> save rustfmt2.toml\n<span>></span> <span>open</span> rustfmt2.toml\n---------+--------------\n edition <span>|</span> next_edition\n---------+--------------\n <span>2018</span>    <span>|</span> <span>2021</span>\n---------+--------------\n</code></pre></div><h3 id=\"editando-uma-coluna\" tabindex=\"-1\"> Editando uma coluna</h3>\n<p>Semelhante ao comando <code>add</code>, podemos usar o comando <code>edit</code> para alterar o conteúdo de uma coluna para um novo valor. Para ver isso funcionando, vamos abrir o mesmo arquivo:</p>\n<div><pre><code><span>open</span> rustfmt.toml\n---------\n edition\n---------\n <span>2018</span>\n---------\n</code></pre></div><p>E agora vamos alterar a coluna <code>edition</code> para mostrar a próxima edição à qual esperamos dar suporte:</p>\n<div><pre><code><span>></span> <span>open</span> rustfmt.toml <span>|</span> edit edition <span>2021</span>\n---------\n edition\n---------\n <span>2021</span>\n---------\n</code></pre></div><h3 id=\"incrementando-valores\" tabindex=\"-1\"> Incrementando valores</h3>\n<p>Existe mais um comando do Nu que nos ajudará a trabalhar com números e versões: <code>inc</code>.</p>\n<div><pre><code><span>></span> <span>open</span> rustfmt.toml\n---------\n edition\n---------\n <span>2018</span>\n---------\n<span>></span> <span>open</span> rustfmt.toml <span>|</span> inc edition\n---------\n edition\n---------\n <span>2019</span>\n---------\n</code></pre></div><p>Como o valor em &quot;edition&quot; é um número, podemos usar <code>inc</code> para alterá-lo. Onde <code>inc</code> realmente se destaca é trabalhando com versões:</p>\n<div><pre><code><span>></span> <span>open</span> Cargo.toml <span>|</span> get package.version\n<span>0.1</span>.3\n<span>></span> <span>open</span> Cargo.toml <span>|</span> inc package.version --minor <span>|</span> get package.version\n<span>0.2</span>.0\n</code></pre></div><p>Quando estamos trabalhando com versões, podemos usar um dos modificadores a seguir para informar como incrementar a versão:</p>\n<ul>\n<li><strong>--major</strong> - incrementa a versão major (0.1.3 -&gt; 1.0.0)</li>\n<li><strong>--minor</strong> - incrementa a versão minor (0.1.3 -&gt; 0.2.0)</li>\n<li><strong>--patch</strong> - incrementa a versão patch (0.1.3 -&gt; 0.1.4)</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.704Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Índice",
      "url": "www.nushell.sh/pt-BR/contributor-book/",
      "id": "www.nushell.sh/pt-BR/contributor-book/",
      "content_html": "<h1 id=\"indice\" tabindex=\"-1\"> Índice</h1>\n<ul>\n<li><a href=\"/pt-BR/contributor-book/introdu%C3%A7%C3%A3o.html\">Introdução</a> - Uma introdução ao livro do contribuidor</li>\n<li><a href=\"/pt-BR/contributor-book/filosofia.html\">Filosofia</a> - Filosofia central</li>\n<li><a href=\"/pt-BR/contributor-book/valores.html\">Valores</a> - Os valores (tipos de dados)</li>\n<li><a href=\"/pt-BR/contributor-book/comandos.html\">Comandos</a> - Como os comandos funcionam</li>\n<li><a href=\"/pt-BR/contributor-book/streams.html\">Streams</a> - Como streams funcionam</li>\n<li><a href=\"/pt-BR/contributor-book/metadados.html\">Metadados</a> - O sistema de metadados</li>\n<li><a href=\"/pt-BR/contributor-book/plugins.html\">Plugins</a> - Como escrever plugins</li>\n<li><a href=\"/pt-BR/contributor-book/shells.html\">Shells</a> - Como o sistema shell funciona</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.704Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Comandos",
      "url": "www.nushell.sh/pt-BR/contributor-book/comandos.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/comandos.html",
      "content_html": "<h1 id=\"comandos\" tabindex=\"-1\"> Comandos</h1>\n<p>Comandos são os blocos de construção para pipelines em Nu. Eles fazem a ação do pipeline, seja criando dados, mudando dados que fluem de entradas para saídas, ou visualizar dados assim que estes saem do pipeline. Existem dois tipos de comandos: comandos internos, que são comandos feitos para executar dentro do Nu, e comandos externos, que são externos ao Nu e se comunicam com o padrão Unix <code>stdin</code>/<code>stdout</code>.</p>\n<h2 id=\"comandos-internos\" tabindex=\"-1\"> Comandos internos</h2>\n<p>Todos os comandos dentro do Nu, incluindo plugins, são comandos internos. Comandos internos se comunicam usando streams dos tipos <a href=\"https://github.com/nushell/nushell/blob/d30c40b40ebfbb411a503ad7c7bceae8029c6689/crates/nu-source/src/meta.rs#L91\" target=\"_blank\" rel=\"noopener noreferrer\"><code>Tagged&lt;Value&gt;</code></a> e <a href=\"https://github.com/nushell/nushell/blob/main/crates/nu-errors/src/lib.rs#L179\" target=\"_blank\" rel=\"noopener noreferrer\">ShellError</a></p>\n<h3 id=\"signature\" tabindex=\"-1\"> Signature</h3>\n<p>Comandos usam uma checagem de tipo simples para garantir que os argumentos passados possam ser lidados corretamente. Para permitir isso, cada comando oferece uma Signature que informa o Nu:</p>\n<ul>\n<li>O nome do comando</li>\n<li>Os argumentos posicionauis (eg, em <code>start x y</code> o <code>x</code> e o <code>y</code>são argumentos posicionais)</li>\n<li>Se o comando recebe um número irrestrito de argumentos posicionais adicionais (eg, <code>start a1 a2 a3 ... a99 a100</code>)</li>\n<li>Os argumentos nomeados (eg, <code>start --now</code>)</li>\n<li>Se o comando é um filtro ou a saída</li>\n</ul>\n<p>Com essa informação, um pipeline pode verificar problemas potenciais antes de ser executado.</p>\n<h2 id=\"comandos-externos\" tabindex=\"-1\"> Comandos externos</h2>\n<p>Um comando externo é qualquer comando que não é parte dos comandos imbutidos no Nu ou em seus plugins. Se um comando desconhecido pelo Nu é chamado, o sistema subjacente vai ser chamado com os argumentos fornecidos em uma tentativa de invocar esse comando como um programa externo.</p>\n<h2 id=\"comunicacao-entre-comandos-externos-e-internos\" tabindex=\"-1\"> Comunicação entre comandos externos e internos</h2>\n<h3 id=\"interno-para-interno\" tabindex=\"-1\"> Interno para interno</h3>\n<p>Comandos internos se comunicam usando o valor completo da stream que o Nu fornece, que incluí todos os tipos de arquivos embutidos. Isso incluí a comunicação entre comandos internos e plugins (em ambas as direções).</p>\n<h3 id=\"interno-para-externo\" tabindex=\"-1\"> Interno para externo</h3>\n<p>Comandos internos que enviam texto para comandos externos precisam ter texto (strings) preparados antes do tempo. Se um objeto é enviado diretamente para um comando externo, isso é considerado um erro já que não é possível inferir de que maneira os dados estruturados devem ser representados para o comando externo. É esperado que o usuário. O usuário deve limitar-se a uma célula de dados simples ou usar um dos conversores de tipo de arquivo (como <code>to-json</code>) para converter a tabela em uma representação de string.\nO comando externo é aberto para que seu <code>stdin</code> seja redirecionado, para que os dados possam ser enviados a ele.</p>\n<h3 id=\"externo-para-interno\" tabindex=\"-1\"> Externo para interno</h3>\n<p>Comandos internos enviam uma série de strings pelo seu <code>stdout</code>. Essas strings são lidas no pipeline e são disponibilizadas para o comando interno seguinte no pipeline, ou expostas para o usuário se o comando externo for o último passo do pipeline.</p>\n<h3 id=\"externo-para-externo\" tabindex=\"-1\"> Externo para externo</h3>\n<p>Comandos externos se comunicam através do <code>stdin</code>/<code>stdout</code>. Quando o Nu detectar essa situação, vai redirecionar o <code>stdout</code> do primeiro comando para o <code>stdin</code> do comando externo seguinte. Dessa forma, o comportamento esperado do pipeline do shell entre comandos externos é mantido.</p>\n",
      "date_modified": "2022-06-02T15:48:22.705Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Filosofia",
      "url": "www.nushell.sh/pt-BR/contributor-book/filosofia.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/filosofia.html",
      "content_html": "<h1 id=\"filosofia\" tabindex=\"-1\"> Filosofia</h1>\n<h2 id=\"principais-valores\" tabindex=\"-1\"> Principais Valores</h2>\n<p>O principal valor do Nu é que trabalhar em um shell deve ser divertido. Para apoiar isso, nós acreditamos que:</p>\n<ul>\n<li>Um shell moderno deve ser projetado para ter usabilidade e ergonomia. <strong>Acima de tudo, Nu deve ser divertido de usar.</strong></li>\n<li>Deve oferecer mensagens de erro informativas quando um comando não executar corretamente. Isso é criticamente importante. Um shell divertido fornece <strong>erros claros e acionáveis.</strong></li>\n<li>Deve ser feito visando o uso casual, visto que essa é a forma mais utilziada de um shell, até mesmo por usuários experientes. Construir um shell que é <strong>divertido para o uso casual torna um shell divertido para todo mundo</strong>.</li>\n<li>Nu oferece experimentação e <strong>ideias desenvolvidas de experimentos para programas</strong>. A habilidade de evoluir ideias em uma linha, scripts, e então para programas é um papel fundamental feito por um shell. Para oferecer isso, Nu parte do princípio de comandos compostos que funcionam em um conjunto de tipos de dados compartilhados.</li>\n</ul>\n<h2 id=\"nao-objetivos\" tabindex=\"-1\"> Não objetivos</h2>\n<ul>\n<li><em>Performance ótima</em>. Apesar de nos preocuparmos com performance, o foco em performance deve ser no serviço de fazer o Nu mais utilizável e prazeroso de se utilizar. Melhor performance em micro-benchmarks não é um objetivo.</li>\n<li><em>Rigor</em>. Nós queremos ajudar usuários a escrever bons scripts, mas devemos focar em ajudá-los a escrever scripts corretos com bons erros e boa documentação.</li>\n<li><em>Conformidade com POSIX</em>. Nu otimiza intencionalmente para uma experiência agradável em comparação com a forma como os programas de linha de comando funcionam de uma forma compatível com POSIX. É importante ser capaz de interoperar entre comandos Nu e comandos externos, mas manter uma compatibilidade estrita não é um objetivo</li>\n<li><em>Aderência de paradigma</em>. Nu observa o espaço de flexibilidade dos shells, e quando possível busca ideias de programação funcional, programação de sistemas, POO, e mais. Seguir qualquer paradigma de forma rígida não é um dos objetivos do projeto Nu.</li>\n</ul>\n<h2 id=\"design-basico\" tabindex=\"-1\"> Design Básico</h2>\n<p>O princípio do design de Nu é o modelo de dados. Em grande parte, os comandos seguem em serviço para facilitar a criação de dados, o trabalho com dados e a exibição de dados. Uma das peças visíveis desse trabalho é o pipeline, que se baseia fortemente nas ideias originais do Unix de conectar programas juntos em comandos complexos. Nu usa essa filosofia do Unix e a extende de apenas strings para mais tipos de dados que são comuns em linguagens de programação modernas.</p>\n",
      "date_modified": "2022-06-02T15:48:22.705Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Introdução",
      "url": "www.nushell.sh/pt-BR/contributor-book/introdu%C3%A7%C3%A3o.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/introdu%C3%A7%C3%A3o.html",
      "content_html": "<h1 id=\"introducao\" tabindex=\"-1\"> Introdução</h1>\n<p>Olá e bem-vindo ao livro de contribuição do Nushell. Nushell, ou Nu como é normalmente chamado, é um shell moderno escrito em Rust. Você pode aprender mais sobre o Nu e como usá-lo no <a href=\"https://www.nushell.sh/book/\" target=\"_blank\" rel=\"noopener noreferrer\">Nu book</a>, Nesse livro, vamos mostrar como contribuir para o projeto Nu, como o código do Nu é orgnizado, e os principais conceitos atrás do seu design.</p>\n<p>Para contribuir com o Nu é necessário ter uma experiência básica de programação, e é útil também ter alguma experiência com Rust. Dito isso, têmos pessoas contribuindo para o Nu sem antes ter escrito nenhuma linha de Rust antes de escrever sua submissão. Se você está interessado em contribuir, existe uma comunidade crescente de pessoas que gostariam de ajudá-lo a suceder.</p>\n<p>Esse livro contém três áreas separadas:</p>\n<ol>\n<li>A filosofia de design do Nu</li>\n<li>A implementação do Nu</li>\n<li>Boas práticas de codificação para o Nu</li>\n</ol>\n",
      "date_modified": "2022-06-02T15:48:22.705Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Metadados",
      "url": "www.nushell.sh/pt-BR/contributor-book/metadados.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/metadados.html",
      "content_html": "<h1 id=\"metadados\" tabindex=\"-1\"> Metadados</h1>\n<p>Todos os valores que fluem para/de um comando no Nu são marcados com metadados. Você verá isso no código-fonte normalmente como um <code>Tagged&lt;Value&gt;</code>.</p>\n<p>Apesar de os metadados que são monitorados ainda estão em fase inicial, esperamos expandir isso conforme o Nu amadurecer.\nAtualmente, existem dois tipos de metadados monitorados em cada valor:</p>\n<h2 id=\"anchor\" tabindex=\"-1\"> Anchor</h2>\n<p>Anchor representa a localização de origem de um valor. Se o valor foi carregado de um arquivo, vai ser o nome do arquivo. Se foi carregado de uma URL, vai ser a URL, e assim por diante.</p>\n<h2 id=\"span\" tabindex=\"-1\"> Span</h2>\n<p>Um Span são as localizações de início e fim do valor que foi criado ou referenciado na linha de comando. Eles são normalmente vistos como o underline abaixo de uma mensagem de erro.</p>\n<p>Enquanto spans de linguagens de programação tradicionalmente carregam também o arquivo de origem do span, aqui assumimos que um span While spans from programming languages traditionally also carry the file the span came from, aqui assumimos que o span sempre abrange um valor referenciado na linha de comando, em vez de em um arquivo de origem. Quando o Nu for capaz de executar seus próprios arquivos fonte, isso provavelmente vai precisar ser revisado.</p>\n",
      "date_modified": "2022-06-02T15:48:22.705Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Plugins",
      "url": "www.nushell.sh/pt-BR/contributor-book/plugins.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/plugins.html",
      "content_html": "<h1 id=\"plugins\" tabindex=\"-1\"> Plugins</h1>\n<h2 id=\"protocolo\" tabindex=\"-1\"> Protocolo</h2>\n<p>Plugins usam JSON-RPC sobre stdin/stdout (de maneira parecida aos plugins do VSCode). O protocolo é dividido em dois estágios.</p>\n<p>O primeiro estágio do protocolo lida com a descoberta inicial do plugin. Um plugin é iniciado e então solicitado para responder com a sua configuração. Muito semelhante aos comandos, plugins possuem uma assinatura que usam para responder ao Nu. Assim que o Nu possuir essa assinatura, ele saberá invocar o plugin futuramente.</p>\n<p>O segundo estágio é a realização do verdadeiro trabalho. Aqui é enviado tanto uma stream de dados para o plugin agir em cada elemento como um filtro, ou então todos elementos de uma vez para o plugin agir em um processamento final como uma saída.</p>\n<h2 id=\"descoberta\" tabindex=\"-1\"> Descoberta</h2>\n<p>Nu descobre plugins ao checar todos os diretórios disponíveis no PATH atual.\nEm cada diretório, Nu busca por arquivos executáveis que combinam com o padrão <code>nu_plugin_*</code>, onde <code>*</code> é no mínimo um caracter alfanumérico.\nNo Windows, isso é um padrão similar à <code>nu_plugin_*.exe</code> ou <code>nu_plugin_*.bat</code>.</p>\n<p>Assim que um arquivo que combine com o padrão for descoberto, Nu vai invocar o arquivo e passar ao primeiro comando JSON-RPC: config.\nConfig responde com a assinatura do plugin, que é idêntico a assinatura usada por comandos.</p>\n<p>Nu continua essa busca até ter percorrido todos os diretórios no caminho.</p>\n<p>Após ter percorrido o caminho, dois outros diretórios serão verificados o diretório alvo/debug e o diretório alvo/release. Um ou outro diretório vai ser buscado, dependendo seo Nu foi compilado no módo de depuração ou de release, respectivamente. Isso permite testar rapidamente os plugins durante o desenvolvimento.</p>\n<h2 id=\"criando-um-plugin-em-rust\" tabindex=\"-1\"> Criando um plugin (em Rust)</h2>\n<p>Nessa seção, vamos mostrar como criar um plugin para o Nu usando Rust.</p>\n<p>Vamos criar nosso projeto. Para esse exemplo, vamos criar um simples comando <code>len</code> que retorna o tamanho da string que recebe.</p>\n<p>Primeiramente, vamos criar nosso plugin:</p>\n<div><pre><code>> cargo new nu_plugin_len\n> cd nu_plugin_len\n</code></pre></div><p>Então, vamos adicionar <code>nu</code> na lista de dependências do diretório Cargo.toml. No final do novo arquivo Cargo.toml, adicione essa nova dependência para o crate <code>nu</code>:</p>\n<div><pre><code>[dependencies]\nnu-plugin = \"~0\"\nnu-protocol = \"~0\"\nnu-source = \"~0\"\nnu-errors = \"~0\"\n</code></pre></div><p>Com isso, podemos abrir src/main.rs e criar nosso plugin.</p>\n<div><pre><code><span>use</span> <span>nu_errors<span>::</span></span><span>ShellError</span><span>;</span>\n<span>use</span> <span>nu_plugin<span>::</span></span><span>{</span>serve_plugin<span>,</span> <span>Plugin</span><span>}</span><span>;</span>\n<span>use</span> <span>nu_protocol<span>::</span></span><span>{</span>\n    <span>CallInfo</span><span>,</span> <span>Primitive</span><span>,</span> <span>ReturnSuccess</span><span>,</span> <span>ReturnValue</span><span>,</span> <span>Signature</span><span>,</span> <span>UntaggedValue</span><span>,</span> <span>Value</span><span>,</span>\n<span>}</span><span>;</span>\n\n<span>struct</span> <span>Len</span><span>;</span>\n\n<span>impl</span> <span>Len</span> <span>{</span>\n    <span>fn</span> <span>new</span><span>(</span><span>)</span> <span>-></span> <span>Len</span> <span>{</span>\n        <span>Len</span>\n    <span>}</span>\n\n    <span>fn</span> <span>len</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> value<span>:</span> <span>Value</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Value</span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>match</span> <span>&amp;</span>value<span>.</span>value <span>{</span>\n            <span>UntaggedValue</span><span>::</span><span>Primitive</span><span>(</span><span>Primitive</span><span>::</span><span>String</span><span>(</span>s<span>)</span><span>)</span> <span>=></span> <span>Ok</span><span>(</span><span>Value</span> <span>{</span>\n                value<span>:</span> <span>UntaggedValue</span><span>::</span><span>int</span><span>(</span>s<span>.</span><span>len</span><span>(</span><span>)</span> <span>as</span> <span>i64</span><span>)</span><span>,</span>\n                tag<span>:</span> value<span>.</span>tag<span>,</span>\n            <span>}</span><span>)</span><span>,</span>\n            _ <span>=></span> <span>Err</span><span>(</span><span>ShellError</span><span>::</span><span>labeled_error</span><span>(</span>\n                <span>\"Unrecorgnized type in stream\"</span><span>,</span>\n                <span>\"'len' given non-string info by this\"</span><span>,</span>\n                value<span>.</span>tag<span>.</span>span<span>,</span>\n            <span>)</span><span>)</span><span>,</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>impl</span> <span>Plugin</span> <span>for</span> <span>Len</span> <span>{</span>\n    <span>fn</span> <span>config</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Signature</span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>Signature</span><span>::</span><span>build</span><span>(</span><span>\"len\"</span><span>)</span><span>.</span><span>desc</span><span>(</span><span>\"My custom len plugin\"</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>)</span><span>)</span>\n    <span>}</span>\n\n    <span>fn</span> <span>begin_filter</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> _<span>:</span> <span>CallInfo</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ReturnValue</span><span>></span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>vec!</span><span>[</span><span>]</span><span>)</span>\n    <span>}</span>\n\n    <span>fn</span> <span>filter</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> input<span>:</span> <span>Value</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ReturnValue</span><span>></span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>vec!</span><span>[</span><span>ReturnSuccess</span><span>::</span><span>value</span><span>(</span><span>self</span><span>.</span><span>len</span><span>(</span>input<span>)</span><span>?</span><span>)</span><span>]</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n\n<span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>serve_plugin</span><span>(</span><span>&amp;</span><span>mut</span> <span>Len</span><span>::</span><span>new</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p>Existe bastante código até aqui, então vamos verificar cada trecho separadamente.</p>\n<p>Primeiramente, vamos olhar o main:</p>\n<div><pre><code><span>fn</span> <span>main</span><span>(</span><span>)</span> <span>{</span>\n    <span>serve_plugin</span><span>(</span><span>&amp;</span><span>mut</span> <span>Len</span><span>::</span><span>new</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre></div><p>No main, simplesmente chamamos uma única função <code>serve_plugin</code>. Isso vai fazer o trabalho de chamar o plugin, lidando com a serialização/desserialização do JSON, e enviando valores e erros de volta para o Nu. Para iniciá-lo, passamos algo que implementa a trait <code>Plugin</code>.</p>\n<p>Em seguida, acima do main, está a implementação da trait <code>Plugin</code> para o nosso plugin em particular. Aqui, vamos implementar a trait Plugin para o nosso tipo, Len, que veremos em breve. Vamos ver como implementamos essa trait:</p>\n<div><pre><code><span>impl</span> <span>Plugin</span> <span>for</span> <span>Len</span> <span>{</span>\n    <span>fn</span> <span>config</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Signature</span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>Signature</span><span>::</span><span>build</span><span>(</span><span>\"len\"</span><span>)</span><span>.</span><span>desc</span><span>(</span><span>\"My custom len plugin\"</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>)</span><span>)</span>\n    <span>}</span>\n\n    <span>fn</span> <span>begin_filter</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> _<span>:</span> <span>CallInfo</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ReturnValue</span><span>></span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>vec!</span><span>[</span><span>]</span><span>)</span>\n    <span>}</span>\n\n    <span>fn</span> <span>filter</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> input<span>:</span> <span>Value</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ReturnValue</span><span>></span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>vec!</span><span>[</span><span>ReturnSuccess</span><span>::</span><span>value</span><span>(</span><span>self</span><span>.</span><span>len</span><span>(</span>input<span>)</span><span>?</span><span>)</span><span>]</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>As duas partes mais importantes dessa implementação são a parte de <code>config</code>, que é executada pelo Nu quando se inicia pela primeira vez. Isso informa ao Nu as informações básicas sobre o plugin: nome, parâmetros recebidos, descrição e qual o tipo do plugin.\nAqui, informamos ao Nu que o nome é &quot;len&quot;, damos uma básica descrição de <code>ajuda</code> para mostrar e que somos um plugin de filtro (ao invés de um plugin de saída).</p>\n<p>Em seguida, na implementação do <code>filter</code>, descrevemos como as informações são processadas com o fluxo de dados neste plugin. Aqui, recebemos um valor (um <code>Value</code>) de cada vez.\nTambém retornamos ou um Vec de valores ou um erro.\nRetornar um vec ao invés de um único valor nos permite remover valores, ou adicionar outros, além de trabalhar com o único valor recebido.</p>\n<p>Já que o <code>begin_filter</code> não faz nada, podemos remove-lo. Isso simplificaria o código acima:</p>\n<div><pre><code><span>impl</span> <span>Plugin</span> <span>for</span> <span>Len</span> <span>{</span>\n    <span>fn</span> <span>config</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Signature</span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>Signature</span><span>::</span><span>build</span><span>(</span><span>\"len\"</span><span>)</span><span>.</span><span>desc</span><span>(</span><span>\"My custom len plugin\"</span><span>)</span><span>.</span><span>filter</span><span>(</span><span>)</span><span>)</span>\n    <span>}</span>\n\n    <span>fn</span> <span>filter</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> input<span>:</span> <span>Value</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ReturnValue</span><span>></span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>Ok</span><span>(</span><span>vec!</span><span>[</span><span>ReturnSuccess</span><span>::</span><span>value</span><span>(</span><span>self</span><span>.</span><span>len</span><span>(</span>input<span>)</span><span>?</span><span>)</span><span>]</span><span>)</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>Se esse é o caso, por que temos um <code>begin_filter</code>? Vamos ver a assinatura do <code>begin_filter</code> mais próximo:</p>\n<div><pre><code><span>fn</span> <span>begin_filter</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> _<span>:</span> <span>CallInfo</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Vec</span><span>&lt;</span><span>ReturnValue</span><span>></span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n    <span>Ok</span><span>(</span><span>vec!</span><span>[</span><span>]</span><span>)</span>\n<span>}</span>\n</code></pre></div><p>Nosso comando <code>Len</code> não requer nenhum parâmetro, mas caso precisasse esse seria o local para obtê-los. A partir daqui, podemos configurar nosso filtro, e então usar isso com cada passo do comando <code>filter</code> sobre a entrada.</p>\n<p>Vamos verificar o próprio <code>Len</code> para ver o que ele está fazendo:</p>\n<div><pre><code><span>struct</span> <span>Len</span><span>;</span>\n\n<span>impl</span> <span>Len</span> <span>{</span>\n    <span>fn</span> <span>new</span><span>(</span><span>)</span> <span>-></span> <span>Len</span> <span>{</span>\n        <span>Len</span>\n    <span>}</span>\n\n    <span>fn</span> <span>len</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> value<span>:</span> <span>Value</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Value</span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>match</span> <span>&amp;</span>value<span>.</span>value <span>{</span>\n            <span>UntaggedValue</span><span>::</span><span>Primitive</span><span>(</span><span>Primitive</span><span>::</span><span>String</span><span>(</span>s<span>)</span><span>)</span> <span>=></span> <span>Ok</span><span>(</span><span>Value</span> <span>{</span>\n                value<span>:</span> <span>UntaggedValue</span><span>::</span><span>int</span><span>(</span>s<span>.</span><span>len</span><span>(</span><span>)</span> <span>as</span> <span>i64</span><span>)</span><span>,</span>\n                tag<span>:</span> value<span>.</span>tag<span>,</span>\n            <span>}</span><span>)</span><span>,</span>\n            _ <span>=></span> <span>Err</span><span>(</span><span>ShellError</span><span>::</span><span>labeled_error</span><span>(</span>\n                <span>\"Unrecorgnized type in stream\"</span><span>,</span>\n                <span>\"'len' given non-string info by this\"</span><span>,</span>\n                value<span>.</span>tag<span>.</span>span<span>,</span>\n            <span>)</span><span>)</span><span>,</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>Criamos um <code>Len</code> muito simples, de fato, que não tem nenhuma estrutura. Ao invés disso é apenas um placeholder que vai permitir a implementação do plugin.</p>\n<p>Daqui, criamos dois métodos:</p>\n<div><pre><code><span>impl</span> <span>Len</span> <span>{</span>\n    <span>fn</span> <span>new</span><span>(</span><span>)</span> <span>-></span> <span>Len</span> <span>{</span>\n        <span>Len</span>\n    <span>}</span>\n    <span>// ...</span>\n<span>}</span>\n</code></pre></div><p>O primeiro método é opcional: é apenas uma maneira conveniente de criar um novo valor do tipo <code>Len</code>. O verdadeiro trabalho é realizado no segundo método:</p>\n<div><pre><code><span>impl</span> <span>Len</span> <span>{</span>\n    <span>// ...</span>\n\n    <span>fn</span> <span>len</span><span>(</span><span>&amp;</span><span>mut</span> <span>self</span><span>,</span> value<span>:</span> <span>Value</span><span>)</span> <span>-></span> <span>Result</span><span>&lt;</span><span>Value</span><span>,</span> <span>ShellError</span><span>></span> <span>{</span>\n        <span>match</span> <span>&amp;</span>value<span>.</span>value <span>{</span>\n            <span>UntaggedValue</span><span>::</span><span>Primitive</span><span>(</span><span>Primitive</span><span>::</span><span>String</span><span>(</span>s<span>)</span><span>)</span> <span>=></span> <span>Ok</span><span>(</span><span>Value</span> <span>{</span>\n                value<span>:</span> <span>UntaggedValue</span><span>::</span><span>int</span><span>(</span>s<span>.</span><span>len</span><span>(</span><span>)</span> <span>as</span> <span>i64</span><span>)</span><span>,</span>\n                tag<span>:</span> value<span>.</span>tag<span>,</span>\n            <span>}</span><span>)</span><span>,</span>\n            _ <span>=></span> <span>Err</span><span>(</span><span>ShellError</span><span>::</span><span>labeled_error</span><span>(</span>\n                <span>\"Unrecorgnized type in stream\"</span><span>,</span>\n                <span>\"'len' given non-string info by this\"</span><span>,</span>\n                value<span>.</span>tag<span>.</span>span<span>,</span>\n            <span>)</span><span>)</span><span>,</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre></div><p>Esse método age sobre cada elemento no pipeline que é recebido pelo nosso plugin. Para o nosso plugin, nos preocupamos apenas com strings para poder retornar o seu tamanho.</p>\n<p>Usamos o pattern matching de Rust para verificar o tipo do Value recebido, e entã poderando com ele caso seja uma string. O valor é um <code>Tagged&lt;Value&gt;</code>, então ele armazena com ele de onde o valor surgiu. Se o valor não é um string, retornamos um erro e deixamos o usuário saber de onde veio o valor que está causando o problema. (Note que se quisessemos colocar um erro abaixo do nome do nome do comando, asta basta usar o <code>name_span</code> do CallInfo informado no <code>begin_filter</code>)</p>\n<p>Por último, vamos ver o começo do arquivo:</p>\n<div><pre><code><span>use</span> <span>nu_errors<span>::</span></span><span>ShellError</span><span>;</span>\n<span>use</span> <span>nu_plugin<span>::</span></span><span>{</span>serve_plugin<span>,</span> <span>Plugin</span><span>}</span><span>;</span>\n<span>use</span> <span>nu_protocol<span>::</span></span><span>{</span>\n    <span>CallInfo</span><span>,</span> <span>Primitive</span><span>,</span> <span>ReturnSuccess</span><span>,</span> <span>ReturnValue</span><span>,</span> <span>Signature</span><span>,</span> <span>UntaggedValue</span><span>,</span> <span>Value</span><span>,</span>\n<span>}</span><span>;</span>\n</code></pre></div><p>Aqui importamos tudo o que precisamos -- tipos e funções -- para ser possível criar nosso plugin.</p>\n<p>Assim que acabarmos nosso plugin só precisamos instalá-lo para usá-lo.</p>\n<div><pre><code>> cargo install --path .\n</code></pre></div><p>Assim que o <code>nu</code> iniciar, vai descobrir o plugin e registrá-lo como um comando.\nSe você já estiver executando o <code>nu</code> durante o processo de instalação do seu plugin, tenha certeza de que você reiniciou o <code>nu</code> para que possa carregar e registrar seu plugin.</p>\n<div><pre><code>> nu\n> echo hello | len\n5\n> help len\nThis is my custom len plugin\n\nUsage:\n  > len {flags}\n\nflags:\n  -h, --help: Display this help message\n</code></pre></div><h2 id=\"criando-um-plugin-em-python\" tabindex=\"-1\"> Criando um plugin (em Python)</h2>\n<p>Podemos também criar plugins em outras linguagens de programação. Nessa seção, vamos escrever o mesmo plugin <code>len</code> em Python.</p>\n<p>Primeiramente, vamos verificar o plugin completo:</p>\n<div><pre><code><span>#!/usr/bin/python3</span>\n<span>import</span> json\n<span>import</span> fileinput\n<span>import</span> sys\n\n\n<span>def</span> <span>print_good_response</span><span>(</span>response<span>)</span><span>:</span>\n    json_response <span>=</span> <span>{</span><span>\"jsonrpc\"</span><span>:</span> <span>\"2.0\"</span><span>,</span> <span>\"method\"</span><span>:</span> <span>\"response\"</span><span>,</span> <span>\"params\"</span><span>:</span> <span>{</span><span>\"Ok\"</span><span>:</span> response<span>}</span><span>}</span>\n    <span>print</span><span>(</span>json<span>.</span>dumps<span>(</span>json_response<span>)</span><span>)</span>\n    sys<span>.</span>stdout<span>.</span>flush<span>(</span><span>)</span>\n\n\n<span>def</span> <span>get_length</span><span>(</span>string_value<span>)</span><span>:</span>\n    string_len <span>=</span> <span>len</span><span>(</span>string_value<span>[</span><span>\"item\"</span><span>]</span><span>[</span><span>\"Primitive\"</span><span>]</span><span>[</span><span>\"String\"</span><span>]</span><span>)</span>\n    int_item <span>=</span> <span>{</span><span>\"Primitive\"</span><span>:</span> <span>{</span><span>\"Int\"</span><span>:</span> string_len<span>}</span><span>}</span>\n    int_value <span>=</span> string_value\n    int_value<span>[</span><span>\"item\"</span><span>]</span> <span>=</span> int_item\n    <span>return</span> int_value\n\n\n<span>for</span> line <span>in</span> fileinput<span>.</span><span>input</span><span>(</span><span>)</span><span>:</span>\n    x <span>=</span> json<span>.</span>loads<span>(</span>line<span>)</span>\n    method <span>=</span> x<span>.</span>get<span>(</span><span>\"method\"</span><span>,</span> <span>None</span><span>)</span>\n    <span>if</span> method <span>==</span> <span>\"config\"</span><span>:</span>\n        config <span>=</span> <span>{</span><span>\"name\"</span><span>:</span> <span>\"len\"</span><span>,</span> <span>\"usage\"</span><span>:</span> <span>\"Return the length of a string\"</span><span>,</span> <span>\"positional\"</span><span>:</span> <span>[</span><span>]</span><span>,</span> <span>\"named\"</span><span>:</span> <span>{</span><span>}</span><span>,</span> <span>\"is_filter\"</span><span>:</span> <span>True</span><span>}</span>\n        print_good_response<span>(</span>config<span>)</span>\n        <span>break</span>\n    <span>elif</span> method <span>==</span> <span>\"begin_filter\"</span><span>:</span>\n        print_good_response<span>(</span><span>[</span><span>]</span><span>)</span>\n    <span>elif</span> method <span>==</span> <span>\"filter\"</span><span>:</span>\n        int_item <span>=</span> get_length<span>(</span>x<span>[</span><span>\"params\"</span><span>]</span><span>)</span>\n        print_good_response<span>(</span><span>[</span><span>{</span><span>\"Ok\"</span><span>:</span> <span>{</span><span>\"Value\"</span><span>:</span> int_item<span>}</span><span>}</span><span>]</span><span>)</span>\n    <span>elif</span> method <span>==</span> <span>\"end_filter\"</span><span>:</span>\n        print_good_response<span>(</span><span>[</span><span>]</span><span>)</span>\n        <span>break</span>\n    <span>else</span><span>:</span>\n        <span>break</span>\n</code></pre></div><p>Nota: existem maneiras de tornar Python mais robusto, mas aqui deixamos de maneira simples para ajudar com explicações.</p>\n<p>Vamos verificar como o plugin funciona, de baixa para cima:</p>\n<div><pre><code><span>for</span> line <span>in</span> fileinput<span>.</span><span>input</span><span>(</span><span>)</span><span>:</span>\n    x <span>=</span> json<span>.</span>loads<span>(</span>line<span>)</span>\n    method <span>=</span> x<span>.</span>get<span>(</span><span>\"method\"</span><span>,</span> <span>None</span><span>)</span>\n    <span>if</span> method <span>==</span> <span>\"config\"</span><span>:</span>\n        config <span>=</span> <span>{</span><span>\"name\"</span><span>:</span> <span>\"len\"</span><span>,</span> <span>\"usage\"</span><span>:</span> <span>\"Return the length of a string\"</span><span>,</span> <span>\"positional\"</span><span>:</span> <span>[</span><span>]</span><span>,</span> <span>\"named\"</span><span>:</span> <span>{</span><span>}</span><span>,</span> <span>\"is_filter\"</span><span>:</span> <span>True</span><span>}</span>\n        print_good_response<span>(</span>config<span>)</span>\n        <span>break</span>\n    <span>elif</span> method <span>==</span> <span>\"begin_filter\"</span><span>:</span>\n        print_good_response<span>(</span><span>[</span><span>]</span><span>)</span>\n    <span>elif</span> method <span>==</span> <span>\"filter\"</span><span>:</span>\n        int_item <span>=</span> get_length<span>(</span>x<span>[</span><span>\"params\"</span><span>]</span><span>)</span>\n        print_good_response<span>(</span><span>[</span><span>{</span><span>\"Ok\"</span><span>:</span> <span>{</span><span>\"Value\"</span><span>:</span> int_item<span>}</span><span>}</span><span>]</span><span>)</span>\n    <span>elif</span> method <span>==</span> <span>\"end_filter\"</span><span>:</span>\n        print_good_response<span>(</span><span>[</span><span>]</span><span>)</span>\n        <span>break</span>\n    <span>else</span><span>:</span>\n        <span>break</span>\n</code></pre></div><p>Para esse plugin, temos que servir a função básica: responder ao request da configuração do plugin a realizar o filtro. Esse código age como o loop principal, respondendo as mensagens do Nu realizando algum trabalho e então retornando uma resposta. Cada mensagem JSON é enviada para o plugin em uma única linha, então é necessário apenas ler a linha e realizar a interpretação do JSON contido.</p>\n<p>A partir disso, vemos qual método é invocado. Para esse plugin, existem quatro métodos que nos preocupamos: config, begin_filter, filter, e end_filter. Quando recebemos um request do tipo 'config', respondemos com a assinatura desse plugin, que é um pedaço de informação dizendo ao Nu como o comando deve ser chamado. Assim que for enviado, saímos do loop para que o plugin possa encerrar e ser invocado novamente quando o filtro iniciar.</p>\n<p>Os outros três métodos -- begin_filter, filter, e end_filter -- trabalham todos juntos para filtrar os dados recebidos. Como esse plugin vai trabalhar separadamente com cada pedaço de dado, transformando strings nos seus respectivos tamanhos, fazemos a maior parte do nosso trabalho no método <code>filter</code>. O método 'end_filter' é usado para encerrar o plugin, então usamos ele para sair do loop.</p>\n<div><pre><code><span>def</span> <span>get_length</span><span>(</span>string_value<span>)</span><span>:</span>\n    string_len <span>=</span> <span>len</span><span>(</span>string_value<span>[</span><span>\"item\"</span><span>]</span><span>[</span><span>\"Primitive\"</span><span>]</span><span>[</span><span>\"String\"</span><span>]</span><span>)</span>\n    int_item <span>=</span> <span>{</span><span>\"Primitive\"</span><span>:</span> <span>{</span><span>\"Int\"</span><span>:</span> string_len<span>}</span><span>}</span>\n    int_value <span>=</span> string_value\n    int_value<span>[</span><span>\"item\"</span><span>]</span> <span>=</span> int_item\n    <span>return</span> int_value\n</code></pre></div><p>A filtragem é realizada pela função <code>get_length</code>. Aqui, assumimos que estamos recebendo strings (podemos fazer esse método mais robusto futuramente e retornar um erro caso o parâmetro não seja uma string), e então extraímos a string recebida. A partir disso, medimos o tamanho da string e criamos um novo <code>Int</code> para esse tamanho.</p>\n<p>Finalmente, usamos o mesmo item recebido e o substituimos o payload com esse novo Int. Fazemos isso para reutilizar os metadados que passamos junto com a string recebida, apesar de isso ser um passo opcional. Poderíamos ter optado por criar novos metadados e passá-los como resposta.</p>\n<div><pre><code><span>def</span> <span>print_good_response</span><span>(</span>response<span>)</span><span>:</span>\n    json_response <span>=</span> <span>{</span><span>\"jsonrpc\"</span><span>:</span> <span>\"2.0\"</span><span>,</span> <span>\"method\"</span><span>:</span> <span>\"response\"</span><span>,</span> <span>\"params\"</span><span>:</span> <span>{</span><span>\"Ok\"</span><span>:</span> response<span>}</span><span>}</span>\n    <span>print</span><span>(</span>json<span>.</span>dumps<span>(</span>json_response<span>)</span><span>)</span>\n    sys<span>.</span>stdout<span>.</span>flush<span>(</span><span>)</span>\n</code></pre></div><p>Cada resposta do plugin para o Nu é também uma mensagem em JSON que é enviada em uma única linha. Convertemos essa resposta para JSON e enviamos com essa função auxiliar.</p>\n<div><pre><code><span>import</span> json\n<span>import</span> fileinput\n<span>import</span> sys\n</code></pre></div><p>Tudo isso requer alguns imports para suceder, então vamos ter certeza de incluí-los.</p>\n<div><pre><code><span>#!/usr/bin/python3</span>\n</code></pre></div><p>Finalmente, para facilitar a execução de Python, torne esse arquivo executável (usando algo como <code>chmod +x nu_plugin_len</code>) e adicione o caminho para o nosso python no topo. Esse truque funciona para plataformas baseadas em Unix, mas para Windows vamos precisar criar um .exe ou .bat que vai invocar o python para nós.</p>\n<p>Utilizamos Python 3 pois Python 2 não vai mais ser mantido após 2020. Entretanto, scripts funcionam em ambas as versões.\nApenas mude a primeira linha da seguinte forma:</p>\n<div><pre><code><span>#!/usr/bin/python</span>\n</code></pre></div><p>e você já pode utilizar.</p>\n<h2 id=\"criando-um-plugin-em-c\" tabindex=\"-1\"> Criando um plugin (em C#)</h2>\n<p>Você pode aprender mais sobre criar um plugin de Nu com C# aqui:</p>\n<ul>\n<li>.Net Core nu-plugin-lib: (https://github.com/myty/nu-plugin-lib)</li>\n</ul>\n",
      "date_modified": "2022-06-02T15:48:22.706Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Shells",
      "url": "www.nushell.sh/pt-BR/contributor-book/shells.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/shells.html",
      "content_html": "<h1 id=\"shells\" tabindex=\"-1\"> Shells</h1>\n<p>Talvez um conceito único de Nu seja o de <code>shells</code>, apesar de a ideia de trabalhar em diversos lugares ao mesmo tempo em um shell é bem comum (via pushd/popd, telas, e mais). O que talvez torne o Nu um pouco diferente é que o seu conceito de <code>shells</code> é de ambas plataformas e funciona tanto no sistema de arquivos quanto dentro de valores.</p>\n<p><strong>Nota:</strong> O conceito de um Value Shell é um de muitos fatores de design abertos e está sujeito a mudanças no futuro.</p>\n<p>Um <strong>Shell</strong> é uma interface semelhante a um sistema de arquivos que descreve um conjunto de operações de arquivos e como operá-los, incluindo: <code>cd</code>, <code>ls</code>, <code>mkdir</code>, <code>rm</code>, <code>cp</code>, e <code>mv</code>. Nem todos os tipos de shells suportam todas as operações de arquivos, mas as operações de arquivos servem para tentar descrever o que um shell deveria fazer.</p>\n<p>Os dois tipos de shell atualmente disponíveis são FilesystemShell and ValueShell, mas outros tipos de shells já foram discutidos.</p>\n<h2 id=\"filesystem-shell\" tabindex=\"-1\"> Filesystem Shell</h2>\n<p>O filesystem shell é um shell que trabalha diretamente com o sistema de arquivos e um arquivo correspondente. Por padrão, Nu inicia com um único filesystem shell no diretório atual.</p>\n<div><pre><code>> shells\n━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━\n   │ name       │ path\n───┼────────────┼────────────────\n X │ filesystem │ /home/jonathan\n━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━\n</code></pre></div><p>Podemos adicionar mais um filesystem shell para essa lista usando o comando <code>enter</code>. Isso vai adicionar uma nova combinação shell+path para o nosso buffer circular de shells.</p>\n<div><pre><code>> enter Source\n/home/jonathan/Source> shells\n━━━┯━━━┯━━━━━━━━━━━━┯━━━━━━━━━━━━━━━━━━━━━━━\n # │   │ name       │ path\n───┼───┼────────────┼───────────────────────\n 0 │   │ filesystem │ /home/jonathan\n 1 │ X │ filesystem │ /home/jonathan/Source\n━━━┷━━━┷━━━━━━━━━━━━┷━━━━━━━━━━━━━━━━━━━━━━━\n</code></pre></div><p>Dessa forma, você pode intercalar entre diretórios de trabalho. Note que atualmente o Nu não permite intercalar entre aplicações em execução, apenas diretórios de trabalho.</p>\n<p><strong>Limitações</strong></p>\n<p>Existem algumas limitações no filesystem shell no seu estado atual de desenvolvimento. Uma das limitações é que não é simples adicionar múltiplos caminhos no buffer circular de uma só vez (por exemplo: <code>enter $it</code>), já que cada adição ao buffer circular vai mudar o diretório atual. Essa limitação não é inerente ao design do buffer circular e em um design futuro seria desejável separar <code>enter</code> da mudança de diretório atual.</p>\n<h2 id=\"value-shell\" tabindex=\"-1\"> Value Shell</h2>\n<p>O Value Shell da a habilidade de explorar um valor estruturado internamente ao carregar um arquivo e tratando seu conteúdo como se fosse um sistema de arquivos. Isso permite explorar os seus dados como um dos shells no buffer circular.</p>\n<p>A implementação atual do Value Shell é limitada ao sub-conjunto de operações de leitura de operações de arquivo, isto é: <code>cd</code> e <code>ls</code>. Em designs futuros seria interessante expandir isso, mas existem perguntas abertas sobre alterar um arquivo aberto com <code>enter</code> e como o resto do ambiente observa essas mudanças (o que acontece se você usar enter no arquivo sendo usado pelo <code>config</code>?)</p>\n<p>Em um Value Shell, o comando <code>cd</code>muda o caminho sendo observado como o &quot;diretório atual&quot; no objeto, mas na verdade é o caminho de campo. Isso significa que o caminho &quot;/abc/def&quot; é o caminho &quot;abc.def&quot; fora do Value Shell.</p>\n",
      "date_modified": "2022-06-02T15:48:22.706Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Streams",
      "url": "www.nushell.sh/pt-BR/contributor-book/streams.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/streams.html",
      "content_html": "<h1 id=\"streams\" tabindex=\"-1\"> Streams</h1>\n<p>Streams assíncronas formam a base de como a informação trafega de um lado do pipeline para o outro. Isso permite que o Nu trabalhe com comandos internos, comandos externos e plugins de uma forma relativamente contínua.</p>\n<p>Existem dois tipos fundamentais de streams no Nu: InputStream e OutputStream</p>\n<h2 id=\"inputstream\" tabindex=\"-1\"> InputStream</h2>\n<p>Vamos ver o tipo InputStream mais próximo:</p>\n<div><pre><code><span>BoxStream</span><span>&lt;</span><span>'static</span><span>,</span> <span>Tagged</span><span>&lt;</span><span>Value</span><span>>></span>\n</code></pre></div><p>É uma stream assíncrona que vai enviar um <code>Tagged&lt;Value&gt;</code> no comando. Para mais informações sobre tagging, veja no capítulo de <a href=\"/pt-BR/contributor-book/metadados.html\">metadados</a>.</p>\n<h2 id=\"outputstream\" tabindex=\"-1\"> OutputStream</h2>\n<p>Similar ao InputStream a cima, um OutputStream vai retornar valores de um comando:</p>\n<div><pre><code><span>BoxStream</span><span>&lt;</span><span>'static</span><span>,</span> <span>ReturnValue</span><span>></span>\n</code></pre></div><p>Onde um ReturnValue é:</p>\n<div><pre><code><span>pub</span> <span>type</span> <span>ReturnValue</span> <span>=</span> <span>Result</span><span>&lt;</span><span>ReturnSuccess</span><span>,</span> <span>ShellError</span><span>></span><span>;</span>\n</code></pre></div><p>E um ReturnSuccess é:</p>\n<div><pre><code><span>pub</span> <span>enum</span> <span>ReturnSuccess</span> <span>{</span>\n    <span>Value</span><span>(</span><span>Tagged</span><span>&lt;</span><span>Value</span><span>></span><span>)</span><span>,</span>\n    <span>Action</span><span>(</span><span>CommandAction</span><span>)</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Por que o OutputStream é diferente do InputStream? Isso ocorre devido as diferentes necessidades de cada ponta (entrada e saída) da stream. No momento em que os dados estiverem disponíveis no comando, já foi realizada a verificação de possíveis erros, então é esperado que seja uma stream pura de dados.</p>\n<p>Por outro lado, OutputStreams devem ser capazes de retornar dois outros tipos de dado além dos valores: erros e ações.</p>\n<h3 id=\"errors\" tabindex=\"-1\"> Errors</h3>\n<p>Erros que forem passados para a stream vão ser detectados como valores que são copiados de uma stream para a outra. Assim que o erro for detectado, a stream vai ser parada e o erro informado.</p>\n<h3 id=\"actions\" tabindex=\"-1\"> Actions</h3>\n<p>Uma ação se difere de um valor, pois enquanto um valor é um pedaço de dado que será visto pelo próximo comando no pipeline, uma ação é algo destinado apenas para o ambiente de execução interno do Nu. Ações mudam o estado do shell, por exemplo, ao mudar o diretório corrente, mudando o shell atual, atualizando tabelas, e assim por diante.</p>\n",
      "date_modified": "2022-06-02T15:48:22.706Z",
      "authors": [],
      "tags": []
    },
    {
      "title": "Valores",
      "url": "www.nushell.sh/pt-BR/contributor-book/valores.html",
      "id": "www.nushell.sh/pt-BR/contributor-book/valores.html",
      "content_html": "<h1 id=\"valores\" tabindex=\"-1\"> Valores</h1>\n<p>Um Valor é a estrutura básica de dados no Nu.</p>\n<div><pre><code><span>pub</span> <span>struct</span> <span>Value</span> <span>{</span>\n    <span>pub</span> value<span>:</span> <span>UntaggedValue</span><span>,</span>\n    <span>pub</span> tag<span>:</span> <span>Tag</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Onde o campo <code>value</code> é qualquer tipo de valor <code>UntaggedValue</code> e o campo <code>tag</code> armazena um <a href=\"/pt-BR/contributor-book/metadados.html\">metadado</a> associado com o valor.</p>\n<p>Um <code>UntaggedValue</code> representa um dos seguintes tipos de valor:</p>\n<div><pre><code><span>pub</span> <span>enum</span> <span>UntaggedValue</span> <span>{</span>\n    <span>Primitive</span><span>(</span><span>Primitive</span><span>)</span><span>,</span>\n    <span>Row</span><span>(</span><span>Dictionary</span><span>)</span><span>,</span>\n    <span>Table</span><span>(</span><span>Vec</span><span>&lt;</span><span>Value</span><span>></span><span>)</span><span>,</span>\n\n    <span>Error</span><span>(</span><span>ShellError</span><span>)</span><span>,</span>\n\n    <span>Block</span><span>(</span><span>Evaluate</span><span>)</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Onde <code>Primitive</code> é:</p>\n<div><pre><code><span>pub</span> <span>enum</span> <span>Primitive</span> <span>{</span>\n    <span>Nothing</span><span>,</span>\n    <span>Int</span><span>(</span><span>BigInt</span><span>)</span><span>,</span>\n    <span>Decimal</span><span>(</span><span>BigDecimal</span><span>)</span><span>,</span>\n    <span>Bytes</span><span>(</span><span>u64</span><span>)</span><span>,</span>\n    <span>String</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>Line</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>ColumnPath</span><span>(</span><span>ColumnPath</span><span>)</span><span>,</span>\n    <span>Pattern</span><span>(</span><span>String</span><span>)</span><span>,</span>\n    <span>Boolean</span><span>(</span><span>bool</span><span>)</span><span>,</span>\n    <span>Date</span><span>(</span><span>DateTime</span><span>&lt;</span><span>Utc</span><span>></span><span>)</span><span>,</span>\n    <span>Duration</span><span>(</span><span>u64</span><span>)</span><span>,</span>\n    <span>Range</span><span>(</span><span>Box</span><span>&lt;</span><span>Range</span><span>></span><span>)</span><span>,</span>\n    <span>Path</span><span>(</span><span>PathBuf</span><span>)</span><span>,</span>\n    <span>Binary</span><span>(</span><span>Vec</span><span>&lt;</span><span>u8</span><span>></span><span>)</span><span>,</span>\n\n    <span>// Stream markers (used as bookend markers rather than actual values)</span>\n    <span>BeginningOfStream</span><span>,</span>\n    <span>EndOfStream</span><span>,</span>\n<span>}</span>\n</code></pre></div><p>Vamos ver em ordem reversa para ver como Primitives é construido até um Value completo:</p>\n<h2 id=\"primitive\" tabindex=\"-1\"> Primitive</h2>\n<p>Um tipo de dado <code>Primitive</code> é um tipo fundamental no Nu. Apesar disso ter similaridades com tipos de dados de linguagens de programação, existem algumas diferenças devido as capacidades de shell do Nu.</p>\n<p>Nu vêm com dois &quot;grandes&quot; tipos de números: <code>BigInt</code> para inteiros e <code>BigDecimal</code> para números decimais. Isso permite que o Nu realize futuramente operações matemáticas e mantenha precisão por mais tempo.</p>\n<p>Outros tipos de dados que talvez sejam um pouco diferentes do normal:</p>\n<ul>\n<li><code>Nothing</code> = Um valor vazio</li>\n<li><code>Bytes(u64)</code> = tamanho do arquivo em número de bytes</li>\n<li><code>Line(String)</code> = Um valor do tipo string com um carriage return (ou cr/lf) no final</li>\n<li><code>ColumnPath(ColumnPath)</code> = Um caminho para percorrer até chegar a um valor em uma tabela</li>\n<li><code>Pattern(string)</code> = um padrão glob (como <code>nu*</code> em <code>ls nu*</code>)</li>\n<li><code>Duration(u64)</code> = Uma contagem no valor de segundos (como <code>1hr</code> em <code>ls | where modified &lt; 1hr</code> )</li>\n<li><code>Range(Box&lt;Range&gt;)</code> = Um intervalo de valores (como <code>0..2</code> em <code>ls | range 0..2</code>)</li>\n<li><code>Path(PathBuf)</code> = um caminho de arquivo</li>\n<li><code>Binary(Vec&lt;u8&gt;)</code> = um array de bytes</li>\n<li><code>BeginningOfStream</code> = um marcador para indicar o início de uma stream</li>\n<li><code>EndOfStream</code> = um marcador para indicar o fim de uma stream</li>\n</ul>\n<h2 id=\"untaggedvalue\" tabindex=\"-1\"> UntaggedValue</h2>\n<p>Além dos tipos primitivos, Nu sporta agregação de tipos de dados. Coletivamente, esses valores agregados são chamados de <code>UntaggedValue</code>s.</p>\n<p>Atualmente, Nu suporta 5 tipos de <code>UntaggedValue</code>: <code>Row</code>, <code>Table</code>, <code>Block</code>, <code>Primitive</code>, e <code>Error</code>.</p>\n<h3 id=\"tables-e-rows\" tabindex=\"-1\"> Tables e Rows</h3>\n<p>Nu usa um conjunto de termos que são mais próximos de planilhas. Ao invés de ter listas de objetos, Nu tem uma tabela, que contém linhas. Cada linha contém o nome das colunas e os seus respectivos valores.</p>\n<h3 id=\"blocks\" tabindex=\"-1\"> Blocks</h3>\n<p>Blocks representam código que está pronto para ser executado pelo avaliador. Um exemplo disso é a condição na expressão <code>where {$it &gt; 10}</code>.</p>\n<h3 id=\"errors\" tabindex=\"-1\"> Errors</h3>\n<p>Representa erros que podem ocorrer quando o pipeline é executado.</p>\n",
      "date_modified": "2022-06-02T15:48:22.707Z",
      "authors": [],
      "tags": []
    }
  ]
}