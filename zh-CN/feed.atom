<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>www.nushell.sh/zh-CN/</id>
  <title>Nushell</title>
  <subtitle>一种新型的Shell</subtitle>
  <updated>2022-06-04T13:17:54.418Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="www.nushell.sh/feed.atom"/>
  <link rel="alternate" href="www.nushell.sh/zh-CN/"/>
  <entry>
    <title type="html">配置第三方提示</title>
    <id>www.nushell.sh/zh-CN/book/3rdpartyprompts.html</id>
    <link href="www.nushell.sh/zh-CN/book/3rdpartyprompts.html"/>
    <updated>2022-06-04T13:17:54.503Z</updated>
    <content type="html"><![CDATA[<h1 id="配置第三方提示" tabindex="-1"> 配置第三方提示</h1>
<h2 id="nerdfonts" tabindex="-1"> Nerdfonts</h2>
<p>Nerdfonts 并不是必需的，但它们能使呈现效果更好。</p>
<p><a href="https://www.nerdfonts.com" target="_blank" rel="noopener noreferrer">网站</a></p>
<p><a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener noreferrer">仓库</a></p>
<h2 id="oh-my-posh" tabindex="-1"> oh-my-posh</h2>
<p><a href="https://ohmyposh.dev/" target="_blank" rel="noopener noreferrer">网站</a></p>
<p><a href="https://github.com/JanDeDobbeleer/oh-my-posh" target="_blank" rel="noopener noreferrer">仓库</a></p>
<p>如果你喜欢 <a href="https://ohmyposh.dev/" target="_blank" rel="noopener noreferrer">oh-my-posh</a>，可以通过以下几个步骤在 Nushell 里使用 oh-my-posh，它与 Nushell 一起配合得很好。在 Nushell 里设置 oh-my-posh 的步骤：</p>
<ol>
<li>安装 Oh My Posh 并按照 <a href="https://ohmyposh.dev/docs/linux#installation" target="_blank" rel="noopener noreferrer">指南</a>下载 oh-my-posh 的主题。</li>
<li>下载并安装一个 <a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener noreferrer">Nerdfonts 字体</a>。</li>
<li>在<code>~/.config/nushell/config.nu</code>（或由<code>$nu.config-path</code>输出的路径）中设置<code>PROMPT_COMMAND</code>，将<code>M365Princess.mp.json</code>改为你喜欢的任何 <a href="https://ohmyposh.dev/docs/themes" target="_blank" rel="noopener noreferrer">主题</a>。</li>
</ol>
<div><pre><code><span>></span> let-env PROMPT_COMMAND <span>=</span> <span>{</span> oh-my-posh --config ~/.poshthemes/M365Princess.omp.json <span>}</span>
</code></pre></div><p>MacOS 用户配置步骤：</p>
<ol>
<li>你可以通过<code>brew</code>安装<code>oh-my-posh</code>，可以参考这里的 <a href="https://ohmyposh.dev/docs/macos" target="_blank" rel="noopener noreferrer">指南</a>；</li>
<li>下载并安装一个 <a href="https://github.com/ryanoasis/nerd-fonts" target="_blank" rel="noopener noreferrer">Nerdfonts 字体</a>；</li>
<li>在<code>$nu.config-path</code>输出的文件中设置<code>PROMPT_COMMAND</code>，可以参考下面的代码片段：</li>
</ol>
<div><pre><code><span>let</span> posh-dir <span>=</span> <span>(</span>brew --prefix oh-my-posh <span>|</span> str trim<span>)</span>
<span>let</span> posh-theme <span>=</span> <span>$'($posh-dir)/share/oh-my-posh/themes/'</span>
<span># Change the theme names to: zash/space/robbyrussel/powerline/powerlevel10k_lean/</span>
<span># material/half-life/lambda Or double lines theme: amro/pure/spaceship, etc.</span>
<span># For more [Themes demo](https://ohmyposh.dev/docs/themes)</span>
let-env PROMPT_COMMAND <span>=</span> <span>{</span> oh-my-posh prompt print primary --config <span>$'($posh-theme)/zash.omp.json'</span> <span>}</span>
<span># Optional</span>
let-env PROMPT_INDICATOR <span>=</span> $<span>"(ansi y)$> (ansi reset)"</span>
</code></pre></div><h2 id="starship" tabindex="-1"> Starship</h2>
<p><a href="https://starship.rs/" target="_blank" rel="noopener noreferrer">网站</a></p>
<p><a href="https://github.com/starship/starship" target="_blank" rel="noopener noreferrer">仓库</a></p>
<ol>
<li>参照上面的链接，安装 Starship；</li>
<li>根据你的喜好，安装 nerdfonts；</li>
<li>使用下面的配置示例，请确保设置<code>STARSHIP_SHELL</code>环境变量；</li>
</ol>
<p>下面是一个关于 Starship 的配置示例：</p>
<div><pre><code>let-env STARSHIP_SHELL <span>=</span> <span>"nu"</span>

def create_left_prompt <span>[</span><span>]</span> <span>{</span>
    starship prompt --cmd-duration <span>$env</span>.CMD_DURATION_MS <span>$'--status=($env.LAST_EXIT_CODE)'</span>
<span>}</span>

<span># Use nushell functions to define your right and left prompt</span>
let-env PROMPT_COMMAND <span>=</span> <span>{</span> create_left_prompt <span>}</span>
let-env PROMPT_COMMAND_RIGHT <span>=</span> <span>""</span>

<span># The prompt indicators are environmental variables that represent</span>
<span># the state of the prompt</span>
let-env PROMPT_INDICATOR <span>=</span> <span>""</span>
let-env PROMPT_INDICATOR_VI_INSERT <span>=</span> <span>": "</span>
let-env PROMPT_INDICATOR_VI_NORMAL <span>=</span> <span>"〉"</span>
let-env PROMPT_MULTILINE_INDICATOR <span>=</span> <span>"::: "</span>
</code></pre></div><p>然后重启 Nushell：</p>
<div><pre><code>nushell on 📙 main is 📦 v0.60.0 via 🦀 v1.59.0
❯
</code></pre></div><p>你可以在 <a href="https://github.com/starship/starship#step-2-setup-your-shell-to-use-starship" target="_blank" rel="noopener noreferrer">官方 Starship 配置文档</a>中了解更多关于配置 Starship 的信息。</p>
<p>另一种启用 Starship 的方法在 <a href="https://starship.rs/#nushell" target="_blank" rel="noopener noreferrer">Starship 快速安装</a>说明中有描述。</p>
<h2 id="purs" tabindex="-1"> Purs</h2>
<p><a href="https://github.com/xcambar/purs" target="_blank" rel="noopener noreferrer">仓库</a></p>
]]></content>
  </entry>
  <entry>
    <title type="html">介绍</title>
    <id>www.nushell.sh/zh-CN/book/</id>
    <link href="www.nushell.sh/zh-CN/book/"/>
    <updated>2022-06-04T13:17:54.504Z</updated>
    <content type="html"><![CDATA[<h1 id="介绍" tabindex="-1"> 介绍</h1>
<p>你好，欢迎来到 Nushell 项目。这个项目的目标是继承 Unix Shell 中用管道把简单的命令连接在一起的理念，并将其带到更具现代风格的开发中。</p>
<p>Nu 汲取了很多常见领域的灵感：传统 Shell 比如 Bash、基于对象的 Shell 比如 PowerShell、逐步类型化的语言比如 TypeScript、函数式编程、系统编程，等等。但是，Nu 并不试图成为万金油，而是把精力集中在做好这几件事上:</p>
<ul>
<li>作为一个具有现代感的灵活的跨平台 Shell；</li>
<li>作为一种现代的编程语言，解决与数据有关的问题；</li>
<li>给予清晰的错误信息和干净的 IDE 支持；</li>
</ul>
<p>了解 Nu 能做什么的最简单的方法是从一些例子开始，所以让我们深入了解一下。</p>
<p>当你运行<a href="/book/commands/ls.html"><code>ls</code></a>这样的命令时，你会注意到的第一件事是，你得到的不是一个文本块，而是一个结构化的表格：</p>
<div><pre><code><span>></span> <span>ls</span>
╭────┬───────────────────────┬──────┬───────────┬─────────────╮
│ <span>#  │         name          │ type │   size    │  modified   │</span>
├────┼───────────────────────┼──────┼───────────┼─────────────┤
│  <span>0</span> │ <span>404</span>.html              │ <span>file</span> │     <span>429</span> B │ <span>3</span> days ago  │
│  <span>1</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>8</span> mins ago  │
│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>3</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │
│  <span>4</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>5</span> │ README.md             │ <span>file</span> │     <span>213</span> B │ <span>3</span> days ago  │
<span>..</span>.
</code></pre></div><p>该表不仅仅是以不同的方式显示目录，就像电子表格中的表一样，它还允许我们以更加互动的方式来处理数据。</p>
<p>我们要做的第一件事是按大小对我们的表进行排序。要做到这一点，我们将从<a href="/book/commands/ls.html"><code>ls</code></a>中获取输出，并将其输入到一个可以根据列的内容对表进行排序的命令中：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> sort-by size <span>|</span> reverse
╭────┬───────────────────────┬──────┬───────────┬─────────────╮
│ <span>#  │         name          │ type │   size    │  modified   │</span>
├────┼───────────────────────┼──────┼───────────┼─────────────┤
│  <span>0</span> │ Gemfile.lock          │ <span>file</span> │   <span>6.9</span> KiB │ <span>3</span> days ago  │
│  <span>1</span> │ SUMMARY.md            │ <span>file</span> │   <span>3.7</span> KiB │ <span>3</span> days ago  │
│  <span>2</span> │ Gemfile               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>3</span> │ LICENSE               │ <span>file</span> │   <span>1.1</span> KiB │ <span>3</span> days ago  │
│  <span>4</span> │ CONTRIBUTING.md       │ <span>file</span> │     <span>955</span> B │ <span>9</span> mins ago  │
│  <span>5</span> │ books.md              │ <span>file</span> │     <span>687</span> B │ <span>3</span> days ago  │
<span>..</span>.
</code></pre></div><p>你可以看到，为了达到这个目的，我们没有向<a href="/book/commands/ls.html"><code>ls</code></a>传递命令行参数。取而代之的是，我们使用了 Nu 提供的<code>sort-by</code>命令来对<a href="/book/commands/ls.html"><code>ls</code></a>命令的输出进行排序。为了在顶部看到最大的文件，我们还使用了<a href="/book/commands/reverse.html"><code>reverse</code></a>命令。</p>
<p>Nu 提供了许多可以对表进行操作的命令，例如，我们可以过滤<a href="/book/commands/ls.html"><code>ls</code></a>表的内容，使其只显示超过 1 千字节的文件。</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 1kb
╭───┬───────────────────┬──────┬─────────┬────────────╮
│ <span># │       name        │ type │  size   │  modified  │</span>
├───┼───────────────────┼──────┼─────────┼────────────┤
│ <span>0</span> │ Gemfile           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │
│ <span>1</span> │ Gemfile.lock      │ <span>file</span> │ <span>6.9</span> KiB │ <span>3</span> days ago │
│ <span>2</span> │ LICENSE           │ <span>file</span> │ <span>1.1</span> KiB │ <span>3</span> days ago │
│ <span>3</span> │ SUMMARY.md        │ <span>file</span> │ <span>3.7</span> KiB │ <span>3</span> days ago │
╰───┴───────────────────┴──────┴─────────┴────────────╯
</code></pre></div><p>就像在 Unix 哲学中一样，能够让命令相互对话给我们提供了在许多不同的组合中对命令进行混搭的方法。我们来看看一个不同的命令：</p>
<div><pre><code><span>></span> <span>ps</span>
╭─────┬──────┬──────────────────────┬─────────┬───────┬───────────┬──────────╮
│  <span>#  │ pid  │         name         │ status  │  cpu  │    mem    │ virtual  │</span>
├─────┼──────┼──────────────────────┼─────────┼───────┼───────────┼──────────┤
│   <span>0</span> │ <span>7570</span> │ nu                   │ Running │  <span>1.96</span> │  <span>23.2</span> MiB │ <span>32.8</span> GiB │
│   <span>1</span> │ <span>3533</span> │ remindd              │ Sleep   │  <span>0.00</span> │ <span>103.6</span> MiB │ <span>32.3</span> GiB │
│   <span>2</span> │ <span>3495</span> │ TVCacheExtension     │ Sleep   │  <span>0.00</span> │  <span>11.9</span> MiB │ <span>32.2</span> GiB │
│   <span>3</span> │ <span>3490</span> │ MusicCacheExtension  │ Sleep   │  <span>0.00</span> │  <span>12.9</span> MiB │ <span>32.2</span> GiB │
<span>..</span>.
</code></pre></div><p>如果你使用过 Linux，你可能对<a href="/book/commands/ps.html"><code>ps</code></a>命令很熟悉。通过它，我们可以得到一个当前系统正在运行的所有进程的列表，它们的状态是什么，以及它们的名字是什么，我们还可以看到这些进程的 CPU 负载。</p>
<p>如果我们想显示那些正在活跃使用 CPU 的进程呢？就像我们之前对<a href="/book/commands/ls.html"><code>ls</code></a>命令所做的那样，我们也可以利用<a href="/book/commands/ps.html"><code>ps</code></a>命令返回给我们的表格来做到：</p>
<div><pre><code><span>></span> <span>ps</span> <span>|</span> where cpu <span>></span> <span>5</span>
╭───┬──────┬────────────────┬─────────┬────────┬───────────┬──────────╮
│ <span># │ pid  │      name      │ status  │  cpu   │    mem    │ virtual  │</span>
├───┼──────┼────────────────┼─────────┼────────┼───────────┼──────────┤
│ <span>0</span> │ <span>1583</span> │ Terminal       │ Running │  <span>20.69</span> │ <span>127.8</span> MiB │ <span>33.0</span> GiB │
│ <span>1</span> │  <span>579</span> │ photoanalysisd │ Running │ <span>139.50</span> │  <span>99.9</span> MiB │ <span>32.3</span> GiB │
╰───┴──────┴────────────────┴─────────┴────────┴───────────┴──────────╯
</code></pre></div><p>到目前为止，我们一直在使用<a href="/book/commands/ls.html"><code>ls</code></a>和<a href="/book/commands/ps.html"><code>ps</code></a>来列出文件和进程。Nu 还提供了其他可以创建有用信息表格的命令。接下来，让我们试一下<a href="/book/commands/date.html"><code>date</code></a>和<a href="/book/commands/sys.html"><code>sys</code></a>。</p>
<p>运行<code>date now</code>输出关于当前日期和时间的信息：</p>
<div><pre><code><span>></span> <span>date</span> now
<span>2022</span>-03-07 <span>14</span>:14:51.684619600 -08:00
</code></pre></div><p>为了将获得的日期以表格形式展示，我们可以把它输入到 <code>date to-table</code>中：</p>
<div><pre><code><span>></span> <span>date</span> now <span>|</span> <span>date</span> to-table
╭───┬──────┬───────┬─────┬──────┬────────┬────────┬──────────╮
│ <span># │ year │ month │ day │ hour │ minute │ second │ timezone │</span>
├───┼──────┼───────┼─────┼──────┼────────┼────────┼──────────┤
│ <span>0</span> │ <span>2022</span> │     <span>3</span> │   <span>7</span> │   <span>14</span> │     <span>45</span> │      <span>3</span> │ -08:00   │
╰───┴──────┴───────┴─────┴──────┴────────┴────────┴──────────╯
</code></pre></div><p>运行<a href="/book/commands/sys.html"><code>sys</code></a>可以得到 Nu 所运行的系统的信息：</p>
<div><pre><code><span>></span> sys
╭───────┬───────────────────╮
│ <span>host</span>  │ <span>{</span>record <span>6</span> fields<span>}</span> │
│ cpu   │ <span>[</span>table <span>4</span> rows<span>]</span>    │
│ disks │ <span>[</span>table <span>3</span> rows<span>]</span>    │
│ mem   │ <span>{</span>record <span>4</span> fields<span>}</span> │
│ temp  │ <span>[</span>table <span>1</span> row<span>]</span>     │
│ net   │ <span>[</span>table <span>4</span> rows<span>]</span>    │
╰───────┴───────────────────╯
</code></pre></div><p>这与我们之前看到的表格有些不同。<a href="/book/commands/sys.html"><code>sys</code></a>命令输出了一个在单元格中包含结构化表格而非简单值的表格。要查看这些数据，我们需要 <em><code>get</code></em> 待查看的列：</p>
<div><pre><code><span>></span> sys <span>|</span> get <span>host</span>
╭────────────────┬────────────────────────╮
│ name           │ Debian GNU/Linux       │
│ os version     │ <span>11</span>                     │
│ kernel version │ <span>5.10</span>.92-v8+            │
│ <span>hostname</span>       │ lifeless               │
│ <span>uptime</span>         │ 19day 21hr 34min 45sec │
│ sessions       │ <span>[</span>table <span>1</span> row<span>]</span>          │
╰────────────────┴────────────────────────╯
</code></pre></div><p><a href="/book/commands/get.html"><code>get</code></a>命令让我们深入表的某一列内容中。在这里，我们要查看的是 &quot;host&quot; 列，它包含了 Nu 正在运行的主机的信息：操作系统名称、主机名、CPU，以及更多。让我们来获取系统上的用户名：</p>
<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name
╭───┬────╮
│ <span>0</span> │ jt │
╰───┴────╯
</code></pre></div><p>现在，系统中只有一个名为 &quot;jt&quot; 的用户。你会注意到，我们可以传递一个列路径（<code>host.sessions.name</code>部分），而不仅仅是简单的列名称。Nu 会接受列路径并输出表中相应的数据。</p>
<p>你可能已经注意到其他一些不同之处：我们没有一个数据表，而只有一个元素：即字符串 &quot;jt&quot;。Nu 既能处理数据表，也能处理字符串。字符串是使用 Nu 外部命令的一个重要部分。</p>
<p>让我们看看字符串在 Nu 外部命令里面是如何工作的。我们以之前的例子为例，运行外部的<code>echo</code>命令（<code>^</code>告诉 Nu 不要使用内置的<a href="/book/commands/echo.html"><code>echo</code></a>命令）：</p>
<div><pre><code><span>></span> sys <span>|</span> get host.sessions.name <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> ^echo <span>$it</span> <span>}</span>
jt
</code></pre></div><p>敏锐的读者可能会发现这看起来和我们之前的非常相似！确实如此，但有一个重要的区别：我们用前面的值调用了<code>^echo</code>。这允许我们把数据从 Nu 中传到外部命令<code>echo</code>（或者 Nu 之外的任何命令，比如<code>git</code>）。</p>
<h3 id="获取帮助" tabindex="-1"> 获取帮助</h3>
<p>任何 Nu 的内置命令的帮助文本都可以通过<a href="/book/commands/help.html"><code>help</code></a>命令来找到。要查看所有命令，请运行<code>help commands</code>。你也可以通过执行<code>help -f &lt;topic&gt;</code>来搜索一个主题：</p>
<div><pre><code><span>></span> <span>help</span> path
Explore and manipulate paths.

There are three ways to represent a path:

* As a path literal, e.g., <span>'/home/viking/spam.txt'</span>
* As a structured path: a table with <span>'parent'</span>, <span>'stem'</span>, and <span>'extension'</span> <span>(</span>and
* <span>'prefix'</span> on Windows<span>)</span> columns. This <span>format</span> is produced by the <span>'path parse'</span>
  subcommand.
* As an inner list of path parts, e.g., <span>'[[ / home viking spam.txt ]]'</span><span>.</span>
  Splitting into parts is <span>done</span> by the <span><span>`</span>path <span>split</span><span>`</span></span> command.

All subcommands accept all three variants as an input. Furthermore, the <span>'path
join'</span> subcommand can be used to <span>join</span> the structured path or path parts back into
the path literal.

Usage:
  <span>></span> path

Subcommands:
  path <span>basename</span> - Get the final component of a path
  path <span>dirname</span> - Get the parent directory of a path
  path exists - Check whether a path exists
  path <span>expand</span> - Try to <span>expand</span> a path to its absolute form
  path <span>join</span> - Join a structured path or a list of path parts.
  path parse - Convert a path into structured data.
  path relative-to - Get a path as relative to another path.
  path <span>split</span> - Split a path into parts by a separator.
  path <span>type</span> - Get the <span>type</span> of the object a path refers to <span>(</span>e.g., file, dir, symlink<span>)</span>

Flags:
  -h, --help
      Display this <span>help</span> message
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">别名</title>
    <id>www.nushell.sh/zh-CN/book/aliases.html</id>
    <link href="www.nushell.sh/zh-CN/book/aliases.html"/>
    <updated>2022-06-04T13:17:54.504Z</updated>
    <content type="html"><![CDATA[<h1 id="别名" tabindex="-1"> 别名</h1>
<p>Nushell 中的别名提供了一种简单的文本替换方式，这允许你为一个较长的命令创建一个简写名称，包括其默认参数。</p>
<p>例如，让我们创建一个名为 <code>ll</code> 的别名，它将展开为 <code>ls -l</code>。</p>
<div><pre><code><span>></span> <span>alias</span> ll <span>=</span> <span>ls</span> -l
</code></pre></div><p>我们可以通过别名来调用它：</p>
<div><pre><code><span>></span> ll
</code></pre></div><p>一旦我们这样做了，就如同我们输入了 <code>ls -l</code> 一样。这也允许我们传入标志或位置参数。例如，我们现在也可以这样写：</p>
<div><pre><code>> ll -a
</code></pre></div><p>可得到与输入了<code>ls -l -a</code>一样的结果。</p>
<h2 id="编写带有管道的别名" tabindex="-1"> 编写带有管道的别名</h2>
<p>如果你想在别名中添加管道，你必须用小括号把它括起来，小括号是一对圆括号<code>()</code>，用来标记你的一组带有管道命令：</p>
<div><pre><code><span>alias</span> lsname <span>=</span> <span>(</span>ls <span>|</span> get name<span>)</span>
</code></pre></div><p>下面是一个带有多个管道的别名：</p>
<div><pre><code><span>alias</span> lt <span>=</span> <span>(</span>ls <span>|</span> sort-by modified -r <span>|</span> sort-by <span>type</span><span>)</span>
</code></pre></div><h2 id="持久化" tabindex="-1"> 持久化</h2>
<p>为了使你的别名持久化，它必须被添加到你的 <em>config.nu</em> 文件中。
关于如何持久化别名，以便在你启动 Nushell 时它们是可用的，请参考 <a href="/zh-CN/book/configuration.html">配置</a> 部分。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">Nu 的配色和主题</title>
    <id>www.nushell.sh/zh-CN/book/coloring_and_theming.html</id>
    <link href="www.nushell.sh/zh-CN/book/coloring_and_theming.html"/>
    <updated>2022-06-04T13:17:54.505Z</updated>
    <content type="html"><![CDATA[<h1 id="nu-的配色和主题" tabindex="-1"> Nu 的配色和主题</h1>
<p>Nushell 界面的许多部分都可以定制它们的颜色，所有这些都可以在<code>config.nu</code>配置文件中设置。如果你在配置文件中看到 hash/hashtag/pound 符号 <code>#</code>，这意味着它后面的文字被注释掉了。</p>
<ol>
<li>表的边框</li>
<li>原始值</li>
<li>形状（这是命令行的语法）</li>
<li>提示</li>
<li>LS_COLORS</li>
</ol>
<h2 id="表格边框" tabindex="-1"> 表格边框</h2>
<hr>
<p>表的边框由<code>config.nu</code>中的<code>table_mode</code>设置来控制。下面是一个例子：</p>
<div><pre><code><span>></span> <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    table_mode: rounded
<span>}</span>
</code></pre></div><p>下面是目前<code>table_mode</code>的可能选项：</p>
<ul>
<li><code>rounded</code> # 当然了，这个是最好的 😃</li>
<li><code>basic</code></li>
<li><code>compact</code></li>
<li><code>compact_double</code></li>
<li><code>light</code></li>
<li><code>thin</code></li>
<li><code>with_love</code></li>
<li><code>reinforced</code></li>
<li><code>heavy</code></li>
<li><code>none</code></li>
<li><code>other</code></li>
</ul>
<h3 id="颜色符号" tabindex="-1"> 颜色符号</h3>
<hr>
<ul>
<li><code>r</code> - 标准颜色红色的缩写</li>
<li><code>rb</code> - 标准颜色红色的缩写，带有粗体属性</li>
<li><code>red</code> - 标准颜色红色</li>
<li><code>red_bold</code> - 带有粗体属性的标准颜色红色</li>
<li><code>&quot;#ff0000&quot;</code> - &quot;#hex&quot; 格式的颜色：前景色为红色（需要引号）</li>
<li><code>{ fg: &quot;#ff0000&quot; bg: &quot;#0000ff&quot; attr: b }</code> - 完整 &quot;#hex&quot; 格式：前景为红色，背景为蓝色的 &quot;#hex&quot; 格式，属性为粗体缩写。</li>
</ul>
<h3 id="属性" tabindex="-1"> 属性</h3>
<hr>
<table>
<thead>
<tr>
<th>编码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>l</td>
<td>闪烁</td>
</tr>
<tr>
<td>b</td>
<td>加粗</td>
</tr>
<tr>
<td>d</td>
<td>暗淡</td>
</tr>
<tr>
<td>h</td>
<td>隐藏</td>
</tr>
<tr>
<td>i</td>
<td>斜体</td>
</tr>
<tr>
<td>r</td>
<td>反转</td>
</tr>
<tr>
<td>s</td>
<td>删除</td>
</tr>
<tr>
<td>u</td>
<td>下划线</td>
</tr>
<tr>
<td>n</td>
<td>无</td>
</tr>
<tr>
<td></td>
<td>默认为无</td>
</tr>
</tbody>
</table>
<h3 id="标准颜色-和缩写" tabindex="-1"> &quot;标准颜色&quot;和缩写</h3>
<table>
<thead>
<tr>
<th>代码</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>g</td>
<td>green</td>
</tr>
<tr>
<td>gb</td>
<td>green_bold</td>
</tr>
<tr>
<td>gu</td>
<td>green_underline</td>
</tr>
<tr>
<td>gi</td>
<td>green_italic</td>
</tr>
<tr>
<td>gd</td>
<td>green_dimmed</td>
</tr>
<tr>
<td>gr</td>
<td>green_reverse</td>
</tr>
<tr>
<td>gbl</td>
<td>green_blink</td>
</tr>
<tr>
<td>gst</td>
<td>green_strike</td>
</tr>
<tr>
<td>lg</td>
<td>light_green</td>
</tr>
<tr>
<td>lgb</td>
<td>light_green_bold</td>
</tr>
<tr>
<td>lgu</td>
<td>light_green_underline</td>
</tr>
<tr>
<td>lgi</td>
<td>light_green_italic</td>
</tr>
<tr>
<td>lgd</td>
<td>light_green_dimmed</td>
</tr>
<tr>
<td>lgr</td>
<td>light_green_reverse</td>
</tr>
<tr>
<td>lgbl</td>
<td>light_green_blink</td>
</tr>
<tr>
<td>lgst</td>
<td>light_green_strike</td>
</tr>
<tr>
<td>r</td>
<td>red</td>
</tr>
<tr>
<td>rb</td>
<td>red_bold</td>
</tr>
<tr>
<td>ru</td>
<td>red_underline</td>
</tr>
<tr>
<td>ri</td>
<td>red_italic</td>
</tr>
<tr>
<td>rd</td>
<td>red_dimmed</td>
</tr>
<tr>
<td>rr</td>
<td>red_reverse</td>
</tr>
<tr>
<td>rbl</td>
<td>red_blink</td>
</tr>
<tr>
<td>rst</td>
<td>red_strike</td>
</tr>
<tr>
<td>lr</td>
<td>light_red</td>
</tr>
<tr>
<td>lrb</td>
<td>light_red_bold</td>
</tr>
<tr>
<td>lru</td>
<td>light_red_underline</td>
</tr>
<tr>
<td>lri</td>
<td>light_red_italic</td>
</tr>
<tr>
<td>lrd</td>
<td>light_red_dimmed</td>
</tr>
<tr>
<td>lrr</td>
<td>light_red_reverse</td>
</tr>
<tr>
<td>lrbl</td>
<td>light_red_blink</td>
</tr>
<tr>
<td>lrst</td>
<td>light_red_strike</td>
</tr>
<tr>
<td>u</td>
<td>blue</td>
</tr>
<tr>
<td>ub</td>
<td>blue_bold</td>
</tr>
<tr>
<td>uu</td>
<td>blue_underline</td>
</tr>
<tr>
<td>ui</td>
<td>blue_italic</td>
</tr>
<tr>
<td>ud</td>
<td>blue_dimmed</td>
</tr>
<tr>
<td>ur</td>
<td>blue_reverse</td>
</tr>
<tr>
<td>ubl</td>
<td>blue_blink</td>
</tr>
<tr>
<td>ust</td>
<td>blue_strike</td>
</tr>
<tr>
<td>lu</td>
<td>light_blue</td>
</tr>
<tr>
<td>lub</td>
<td>light_blue_bold</td>
</tr>
<tr>
<td>luu</td>
<td>light_blue_underline</td>
</tr>
<tr>
<td>lui</td>
<td>light_blue_italic</td>
</tr>
<tr>
<td>lud</td>
<td>light_blue_dimmed</td>
</tr>
<tr>
<td>lur</td>
<td>light_blue_reverse</td>
</tr>
<tr>
<td>lubl</td>
<td>light_blue_blink</td>
</tr>
<tr>
<td>lust</td>
<td>light_blue_strike</td>
</tr>
<tr>
<td>b</td>
<td>black</td>
</tr>
<tr>
<td>bb</td>
<td>black_bold</td>
</tr>
<tr>
<td>bu</td>
<td>black_underline</td>
</tr>
<tr>
<td>bi</td>
<td>black_italic</td>
</tr>
<tr>
<td>bd</td>
<td>black_dimmed</td>
</tr>
<tr>
<td>br</td>
<td>black_reverse</td>
</tr>
<tr>
<td>bbl</td>
<td>black_blink</td>
</tr>
<tr>
<td>bst</td>
<td>black_strike</td>
</tr>
<tr>
<td>ligr</td>
<td>light_gray</td>
</tr>
<tr>
<td>ligrb</td>
<td>light_gray_bold</td>
</tr>
<tr>
<td>ligru</td>
<td>light_gray_underline</td>
</tr>
<tr>
<td>ligri</td>
<td>light_gray_italic</td>
</tr>
<tr>
<td>ligrd</td>
<td>light_gray_dimmed</td>
</tr>
<tr>
<td>ligrr</td>
<td>light_gray_reverse</td>
</tr>
<tr>
<td>ligrbl</td>
<td>light_gray_blink</td>
</tr>
<tr>
<td>ligrst</td>
<td>light_gray_strike</td>
</tr>
<tr>
<td>y</td>
<td>yellow</td>
</tr>
<tr>
<td>yb</td>
<td>yellow_bold</td>
</tr>
<tr>
<td>yu</td>
<td>yellow_underline</td>
</tr>
<tr>
<td>yi</td>
<td>yellow_italic</td>
</tr>
<tr>
<td>yd</td>
<td>yellow_dimmed</td>
</tr>
<tr>
<td>yr</td>
<td>yellow_reverse</td>
</tr>
<tr>
<td>ybl</td>
<td>yellow_blink</td>
</tr>
<tr>
<td>yst</td>
<td>yellow_strike</td>
</tr>
<tr>
<td>ly</td>
<td>light_yellow</td>
</tr>
<tr>
<td>lyb</td>
<td>light_yellow_bold</td>
</tr>
<tr>
<td>lyu</td>
<td>light_yellow_underline</td>
</tr>
<tr>
<td>lyi</td>
<td>light_yellow_italic</td>
</tr>
<tr>
<td>lyd</td>
<td>light_yellow_dimmed</td>
</tr>
<tr>
<td>lyr</td>
<td>light_yellow_reverse</td>
</tr>
<tr>
<td>lybl</td>
<td>light_yellow_blink</td>
</tr>
<tr>
<td>lyst</td>
<td>light_yellow_strike</td>
</tr>
<tr>
<td>p</td>
<td>purple</td>
</tr>
<tr>
<td>pb</td>
<td>purple_bold</td>
</tr>
<tr>
<td>pu</td>
<td>purple_underline</td>
</tr>
<tr>
<td>pi</td>
<td>purple_italic</td>
</tr>
<tr>
<td>pd</td>
<td>purple_dimmed</td>
</tr>
<tr>
<td>pr</td>
<td>purple_reverse</td>
</tr>
<tr>
<td>pbl</td>
<td>purple_blink</td>
</tr>
<tr>
<td>pst</td>
<td>purple_strike</td>
</tr>
<tr>
<td>lp</td>
<td>light_purple</td>
</tr>
<tr>
<td>lpb</td>
<td>light_purple_bold</td>
</tr>
<tr>
<td>lpu</td>
<td>light_purple_underline</td>
</tr>
<tr>
<td>lpi</td>
<td>light_purple_italic</td>
</tr>
<tr>
<td>lpd</td>
<td>light_purple_dimmed</td>
</tr>
<tr>
<td>lpr</td>
<td>light_purple_reverse</td>
</tr>
<tr>
<td>lpbl</td>
<td>light_purple_blink</td>
</tr>
<tr>
<td>lpst</td>
<td>light_purple_strike</td>
</tr>
<tr>
<td>c</td>
<td>cyan</td>
</tr>
<tr>
<td>cb</td>
<td>cyan_bold</td>
</tr>
<tr>
<td>cu</td>
<td>cyan_underline</td>
</tr>
<tr>
<td>ci</td>
<td>cyan_italic</td>
</tr>
<tr>
<td>cd</td>
<td>cyan_dimmed</td>
</tr>
<tr>
<td>cr</td>
<td>cyan_reverse</td>
</tr>
<tr>
<td>cbl</td>
<td>cyan_blink</td>
</tr>
<tr>
<td>cst</td>
<td>cyan_strike</td>
</tr>
<tr>
<td>lc</td>
<td>light_cyan</td>
</tr>
<tr>
<td>lcb</td>
<td>light_cyan_bold</td>
</tr>
<tr>
<td>lcu</td>
<td>light_cyan_underline</td>
</tr>
<tr>
<td>lci</td>
<td>light_cyan_italic</td>
</tr>
<tr>
<td>lcd</td>
<td>light_cyan_dimmed</td>
</tr>
<tr>
<td>lcr</td>
<td>light_cyan_reverse</td>
</tr>
<tr>
<td>lcbl</td>
<td>light_cyan_blink</td>
</tr>
<tr>
<td>lcst</td>
<td>light_cyan_strike</td>
</tr>
<tr>
<td>w</td>
<td>white</td>
</tr>
<tr>
<td>wb</td>
<td>white_bold</td>
</tr>
<tr>
<td>wu</td>
<td>white_underline</td>
</tr>
<tr>
<td>wi</td>
<td>white_italic</td>
</tr>
<tr>
<td>wd</td>
<td>white_dimmed</td>
</tr>
<tr>
<td>wr</td>
<td>white_reverse</td>
</tr>
<tr>
<td>wbl</td>
<td>white_blink</td>
</tr>
<tr>
<td>wst</td>
<td>white_strike</td>
</tr>
<tr>
<td>dgr</td>
<td>dark_gray</td>
</tr>
<tr>
<td>dgrb</td>
<td>dark_gray_bold</td>
</tr>
<tr>
<td>dgru</td>
<td>dark_gray_underline</td>
</tr>
<tr>
<td>dgri</td>
<td>dark_gray_italic</td>
</tr>
<tr>
<td>dgrd</td>
<td>dark_gray_dimmed</td>
</tr>
<tr>
<td>dgrr</td>
<td>dark_gray_reverse</td>
</tr>
<tr>
<td>dgrbl</td>
<td>dark_gray_blink</td>
</tr>
<tr>
<td>dgrst</td>
<td>dark_gray_strike</td>
</tr>
</tbody>
</table>
<h3 id="hex-格式" tabindex="-1"> <code>&quot;#hex&quot;</code> 格式</h3>
<hr>
<p>&quot;#hex&quot; 格式是你通常看到的一种表示颜色的方式。它由简单的<code>#</code>字符以及后面的 6 个字符组成。前两个代表 <code>红色</code>，接下来两个代表 <code>绿色</code>，最后两个代表 <code>蓝色</code>。重要的是，这个字符串必须用引号包围，否则 Nushell 会认为它是一个被注释掉的字符串。</p>
<p>例子：红色的主要颜色是 &quot;#ff0000&quot; 或 &quot;#FF0000&quot;。字母的大写和小写没有区别。</p>
<p>这种 <code>&quot;#hex&quot;</code>格式允许我们为 Nushell 的不同部分指定 24 位真彩色调。</p>
<h2 id="完整-hex-格式" tabindex="-1"> <code>完整 &quot;#hex&quot;</code> 格式</h2>
<hr>
<p><code>完整 &quot;#hex&quot;</code>格式是对 <code>&quot;#hex&quot;</code> 格式的一种改进，但允许人们在一行中指定前景色、背景色和属性。</p>
<p>例如：<code>{ fg: &quot;#ff0000&quot; bg: &quot;#0000ff&quot; attr: b }</code></p>
<ul>
<li>前景色红色为 &quot;#hex&quot; 格式</li>
<li>背景色蓝色为 &quot;#hex&quot; 格式</li>
<li>属性为加粗的缩写形式</li>
</ul>
<h2 id="原始值" tabindex="-1"> 原始值</h2>
<hr>
<p>原始值是像<code>int</code>和<code>string</code>这样的值。原始值和形状可以用上面看到的各种颜色符号来设置。</p>
<p>这是当前的原始值列表。并非所有这些都是可配置的。可配置的被标记为 <code>*</code>。</p>
<table>
<thead>
<tr>
<th>原始值</th>
<th>默认颜色</th>
<th>可配置</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>any</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>binary</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>block</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>bool</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>cellpath</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>condition</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>custom</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>date</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>duration</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>expression</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>filesize</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>float</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>glob</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>import</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>int</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>list</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>nothing</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>number</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>operator</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>path</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>range</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>record</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>signature</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>string</code></td>
<td>Color::White.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>table</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>var</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>vardecl</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>variable</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="特殊的-原始值-不是真正的原始值-它们的存在仅仅是为了着色" tabindex="-1"> 特殊的 &quot;原始值&quot;（不是真正的原始值，它们的存在仅仅是为了着色）</h4>
<table>
<thead>
<tr>
<th>原始值</th>
<th>默认颜色</th>
<th>可配置</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>leading_trailing_space_bg</code></td>
<td>Color::Rgb(128, 128, 128))</td>
<td>*</td>
</tr>
<tr>
<td><code>header</code></td>
<td>Color::Green.bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>empty</code></td>
<td>Color::Blue.normal()</td>
<td>*</td>
</tr>
<tr>
<td><code>row_index</code></td>
<td>Color::Green.bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>hints</code></td>
<td>Color::DarkGray.normal()</td>
<td>*</td>
</tr>
</tbody>
</table>
<p>下面是一个改变其中一些数值的小例子。</p>
<div><pre><code><span>></span> <span>let</span> config <span>=</span> <span>{</span>
    color_config: <span>{</span>
        separator: purple
        leading_trailing_space_bg: <span>"#ffffff"</span>
        header: gb
        date: wd
        filesize: c
        row_index: cb
        bool: red
        int: green
        duration: blue_bold
        range: purple
        float: red
        string: white
        nothing: red
        binary: red
        cellpath: cyan
        hints: dark_gray
    <span>}</span>
<span>}</span>
</code></pre></div><p>下面是另一个使用多种颜色语法的小例子，其中有一些注释：</p>
<div><pre><code><span>></span> <span>let</span> config <span>=</span> <span>{</span>
    color_config: <span>{</span>
        separator: <span>"#88b719"</span> <span># this sets only the foreground color like PR #486</span>
        leading_trailing_space_bg: white <span># this sets only the foreground color in the original style</span>
        header: <span>{</span> <span># this is like PR #489</span>
            fg: <span>"#B01455"</span>, <span># note, quotes are required on the values with hex colors</span>
            bg: <span>"#ffb900"</span>,<span># note, commas are not required, it could also be all on one line</span>
            attr: bli <span># note, there are no quotes around this value. it works with or without quotes</span>
        <span>}</span>
        date: <span>"#75507B"</span>
        filesize: <span>"#729fcf"</span>
        row_index: <span>{</span>
            <span># note that this is another way to set only the foreground, no need to specify bg and attr</span>
            fg: <span>"#e50914"</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h2 id="shape-值" tabindex="-1"> <code>Shape</code> 值</h2>
<p>如上所述，&quot;形状&quot; 是一个用来表示语法着色的术语。</p>
<p>下面是当前支持的平面形状列表：</p>
<table>
<thead>
<tr>
<th>形状</th>
<th>默认样式</th>
<th>可配置</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shape_block</code></td>
<td>fg(Color::Blue).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_bool</code></td>
<td>fg(Color::LightCyan)</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_custom</code></td>
<td>bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_external</code></td>
<td>fg(Color::Cyan)</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_externalarg</code></td>
<td>fg(Color::Green).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_filepath</code></td>
<td>fg(Color::Cyan)</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_flag</code></td>
<td>fg(Color::Blue).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_float</code></td>
<td>fg(Color::Purple).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_garbage</code></td>
<td>fg(Color::White).on(Color::Red).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_globpattern</code></td>
<td>fg(Color::Cyan).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_int</code></td>
<td>fg(Color::Purple).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_internalcall</code></td>
<td>fg(Color::Cyan).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_list</code></td>
<td>fg(Color::Cyan).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_literal</code></td>
<td>fg(Color::Blue)</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_nothing</code></td>
<td>fg(Color::LightCyan)</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_operator</code></td>
<td>fg(Color::Yellow)</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_range</code></td>
<td>fg(Color::Yellow).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_record</code></td>
<td>fg(Color::Cyan).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_signature</code></td>
<td>fg(Color::Green).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_string</code></td>
<td>fg(Color::Green)</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_string_interpolation</code></td>
<td>fg(Color::Cyan).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_table</code></td>
<td>fg(Color::Blue).bold()</td>
<td>*</td>
</tr>
<tr>
<td><code>shape_variable</code></td>
<td>fg(Color::Purple)</td>
<td>*</td>
</tr>
</tbody>
</table>
<p>这里有一个小例子，说明如何对这些项目应用颜色。任何没有显示指定的都会被设置为默认的颜色。</p>
<div><pre><code><span>></span> <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    color_config: <span>{</span>
        shape_garbage: <span>{</span> fg: <span>"#FFFFFF"</span> bg: <span>"#FF0000"</span> attr: b<span>}</span>
        shape_bool: green
        shape_int: <span>{</span> fg: <span>"#0000ff"</span> attr: b<span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div><h2 id="提示-的配置和着色" tabindex="-1"> &quot;提示&quot;的配置和着色</h2>
<p>Nushell 的提示符可以通过这些环境变量进行配置：</p>
<ul>
<li><code>PROMPT_COMMAND</code>: 为设置提示而执行的代码（块）</li>
<li><code>PROMPT_COMMAND_RIGHT</code>: 为设置 <em>RIGHT</em> 提示而执行的代码（块）(参考 nu_scripts 里的 oh-my.nu)</li>
<li><code>PROMPT_INDICATOR</code> = &quot;〉&quot;: 提示后打印的标识（默认为&quot;&gt;&quot;类 Unicode 符号）</li>
<li><code>PROMPT_INDICATOR_VI_INSERT</code> = &quot;: &quot;</li>
<li><code>PROMPT_INDICATOR_VI_NORMAL</code> = &quot;v &quot;</li>
<li><code>PROMPT_MULTILINE_INDICATOR</code> = &quot;::: &quot;</li>
</ul>
<p>例如：对于一个简单的提示，我们可以这样做。注意<code>PROMPT_COMMAND</code>需要一个<code>block</code>而其他的需要一个<code>string</code>。</p>
<div><pre><code><span>></span> let-env PROMPT_COMMAND <span>=</span> <span>{</span> build-string <span>(</span>date now <span>|</span> <span>date</span> <span>format</span> <span>'%m/%d/%Y %I:%M:%S%.3f'</span><span>)</span> <span>': '</span> <span>(</span>pwd <span>|</span> path <span>basename</span><span>)</span> <span>}</span>
</code></pre></div><p>如果你不喜欢默认的<code>PROMPT_INDICATOR</code>，你可以这样改变它：</p>
<div><pre><code><span>></span> let-env PROMPT_INDICATOR <span>=</span> <span>"> "</span>
</code></pre></div><p>提示的颜色由 <code>PROMPT_COMMAND</code> 中的 <code>block</code> 控制，在这里你可以编写自己的自定义提示。我们写了一个稍微花哨点的，有 git 状态的，位于 <a href="https://github.com/nushell/nu_scripts/blob/main/prompt/oh-my.nu" target="_blank" rel="noopener noreferrer">nu_scripts 仓库</a>。</p>
<h2 id="ls-命令的配色-ls-colors" tabindex="-1"> <code>ls</code> 命令的配色:<code>LS_COLORS</code></h2>
<p>Nushell 将尊重并使用 Mac、Linux 和 Windows 上的 <code>LS_COLORS</code> 环境变量设置。这个设置允许你在做<a href="/book/commands/ls.html"><code>ls</code></a>时定义文件类型的颜色。例如，你可以让目录变成一种颜色，<code>_.md</code> markdown 文件一种颜色，<code>_.toml</code> 文件变成另一种颜色，等等。有很多方法可以给你的文件类型着色。</p>
<p>有一个详尽的清单可以在 <a href="https://github.com/trapd00r/LS_COLORS" target="_blank" rel="noopener noreferrer">这里</a> 看到，不过它可能太多了，但可以让你初步了解如何创建一个<code>ls_colors</code>文件，而<code>dircolors</code>可以把它变成<code>LS_COLORS</code>环境变量。</p>
<p><a href="https://www.linuxhowto.net/how-to-set-colors-for-ls-command/" target="_blank" rel="noopener noreferrer">这</a> 是对<code>LS_COLORS</code>的一个相当好的介绍。我相信你可以在网上找到更多相关教程。</p>
<p>我喜欢<code>vivid</code>应用程序，目前在我的<code>config.nu</code>中是这样配置的。你可以在 <a href="https://github.com/sharkdp/vivid" target="_blank" rel="noopener noreferrer">这里</a> 找到<code>vivid</code>。</p>
<p><code>let-env LS_COLORS = (vivid generate molokai | str trim)</code>。</p>
<p>如果没有设置 <code>LS_COLORS</code>，Nushell 将默认使用内置的 <code>LS_COLORS</code> 设置，基于 8 位（扩展）ANSI 颜色。</p>
<h2 id="主题" tabindex="-1"> 主题</h2>
<p>主题设计结合了上述所有的着色。这里有一个快速的例子，我们把它放在一起，以证明主题定制的能力。这是对我们在网络上看到的 <code>base16</code> 主题的一种转换。</p>
<p>使主题生效的关键是确保你在声明 <code>let config =</code> 行 <em>之前</em>，在<code>config.nu</code>文件中指定你要使用的所有主题和颜色：</p>
<div><pre><code><span># let's define some colors</span>

<span>let</span> base00 <span>=</span> <span>"#181818"</span> <span># Default Background</span>
<span>let</span> base01 <span>=</span> <span>"#282828"</span> <span># Lighter Background (Used for status bars, line number and folding marks)</span>
<span>let</span> base02 <span>=</span> <span>"#383838"</span> <span># Selection Background</span>
<span>let</span> base03 <span>=</span> <span>"#585858"</span> <span># Comments, Invisibles, Line Highlighting</span>
<span>let</span> base04 <span>=</span> <span>"#b8b8b8"</span> <span># Dark Foreground (Used for status bars)</span>
<span>let</span> base05 <span>=</span> <span>"#d8d8d8"</span> <span># Default Foreground, Caret, Delimiters, Operators</span>
<span>let</span> base06 <span>=</span> <span>"#e8e8e8"</span> <span># Light Foreground (Not often used)</span>
<span>let</span> base07 <span>=</span> <span>"#f8f8f8"</span> <span># Light Background (Not often used)</span>
<span>let</span> base08 <span>=</span> <span>"#ab4642"</span> <span># Variables, XML Tags, Markup Link Text, Markup Lists, Diff Deleted</span>
<span>let</span> base09 <span>=</span> <span>"#dc9656"</span> <span># Integers, Boolean, Constants, XML Attributes, Markup Link Url</span>
<span>let</span> base0a <span>=</span> <span>"#f7ca88"</span> <span># Classes, Markup Bold, Search Text Background</span>
<span>let</span> base0b <span>=</span> <span>"#a1b56c"</span> <span># Strings, Inherited Class, Markup Code, Diff Inserted</span>
<span>let</span> base0c <span>=</span> <span>"#86c1b9"</span> <span># Support, Regular Expressions, Escape Characters, Markup Quotes</span>
<span>let</span> base0d <span>=</span> <span>"#7cafc2"</span> <span># Functions, Methods, Attribute IDs, Headings</span>
<span>let</span> base0e <span>=</span> <span>"#ba8baf"</span> <span># Keywords, Storage, Selector, Markup Italic, Diff Changed</span>
<span>let</span> base0f <span>=</span> <span>"#a16946"</span> <span># Deprecated, Opening/Closing Embedded Language Tags, e.g. &lt;?php ?></span>

<span># we're creating a theme here that uses the colors we defined above.</span>

<span>let</span> base16_theme <span>=</span> <span>{</span>
    separator: <span>$base03</span>
    leading_trailing_space_bg: <span>$base04</span>
    header: <span>$base0b</span>
    date: <span>$base0e</span>
    filesize: <span>$base0d</span>
    row_index: <span>$base0c</span>
    bool: <span>$base08</span>
    int: <span>$base0b</span>
    duration: <span>$base08</span>
    range: <span>$base08</span>
    float: <span>$base08</span>
    string: <span>$base04</span>
    nothing: <span>$base08</span>
    binary: <span>$base08</span>
    cellpath: <span>$base08</span>
    hints: dark_gray

    <span># shape_garbage: { fg: $base07 bg: $base08 attr: b} # base16 white on red</span>
    <span># but i like the regular white on red for parse errors</span>
    shape_garbage: <span>{</span> fg: <span>"#FFFFFF"</span> bg: <span>"#FF0000"</span> attr: b<span>}</span>
    shape_bool: <span>$base0d</span>
    shape_int: <span>{</span> fg: <span>$base0e</span> attr: b<span>}</span>
    shape_float: <span>{</span> fg: <span>$base0e</span> attr: b<span>}</span>
    shape_range: <span>{</span> fg: <span>$base0a</span> attr: b<span>}</span>
    shape_internalcall: <span>{</span> fg: <span>$base0c</span> attr: b<span>}</span>
    shape_external: <span>$base0c</span>
    shape_externalarg: <span>{</span> fg: <span>$base0b</span> attr: b<span>}</span>
    shape_literal: <span>$base0d</span>
    shape_operator: <span>$base0a</span>
    shape_signature: <span>{</span> fg: <span>$base0b</span> attr: b<span>}</span>
    shape_string: <span>$base0b</span>
    shape_filepath: <span>$base0d</span>
    shape_globpattern: <span>{</span> fg: <span>$base0d</span> attr: b<span>}</span>
    shape_variable: <span>$base0e</span>
    shape_flag: <span>{</span> fg: <span>$base0d</span> attr: b<span>}</span>
    shape_custom: <span>{</span>attr: b<span>}</span>
<span>}</span>

<span># now let's apply our regular config settings but also apply the "color_config:" theme that we specified above.</span>

<span>let</span> config <span>=</span> <span>{</span>
  filesize_metric: <span>true</span>
  table_mode: rounded <span># basic, compact, compact_double, light, thin, with_love, rounded, reinforced, heavy, none, other</span>
  use_ls_colors: <span>true</span>
  color_config: <span>$base16_theme</span> <span># &lt;-- this is the theme</span>
  use_grid_icons: <span>true</span>
  footer_mode: always <span>#always, never, number_of_rows, auto</span>
  animate_prompt: <span>false</span>
  float_precision: <span>2</span>
  use_ansi_coloring: <span>true</span>
  filesize_format: <span>"b"</span> <span># b, kb, kib, mb, mib, gb, gib, tb, tib, pb, pib, eb, eib, zb, zib, auto</span>
  edit_mode: emacs <span># vi</span>
  max_history_size: <span>10000</span>
  log_level: error
<span>}</span>
</code></pre></div><p>如果你想在主题设计上火力全开，你需要把我在一开始提到的所有项目作为主题，包括<code>LS_COLORS</code>和提示。祝您好运!</p>
]]></content>
  </entry>
  <entry>
    <title type="html">从 Bash 到 Nu</title>
    <id>www.nushell.sh/zh-CN/book/coming_from_bash.html</id>
    <link href="www.nushell.sh/zh-CN/book/coming_from_bash.html"/>
    <updated>2022-06-04T13:17:54.505Z</updated>
    <content type="html"><![CDATA[<h1 id="从-bash-到-nu" tabindex="-1"> 从 Bash 到 Nu</h1>
<p>如果你是来自 Windows 上的<code>Git Bash</code>用户，那么你习惯的外部命令（bash、grep 等）在<code>nu</code>中默认是不可用的（除非你在 Windows 路径环境变量中明确包含了它们）。
要使这些命令在<code>nu</code>中可用，请在你的<code>config.nu</code>中添加以下一行，用<code>append</code>或<code>prepend</code>。</p>
<div><pre><code>let-env Path <span>=</span> <span>(</span><span>$env</span>.Path <span>|</span> prepend <span>'C:\Program Files\Git\usr\bin'</span><span>)</span>
</code></pre></div><p>注意：本表针对 Nu 0.14.1 或更高版本。</p>
<table>
<thead>
<tr>
<th>Bash</th>
<th>Nu</th>
<th>Task</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ls</code></td>
<td><code>ls</code></td>
<td>列出当前目录中的文件</td>
</tr>
<tr>
<td><code>ls &lt;dir&gt;</code></td>
<td><code>ls &lt;dir&gt;</code></td>
<td>列出给定目录中的文件</td>
</tr>
<tr>
<td><code>ls pattern*</code></td>
<td><code>ls pattern*</code></td>
<td>列出匹配给定模式的文件</td>
</tr>
<tr>
<td><code>ls -la</code></td>
<td><code>ls --long --all</code> or <code>ls -la</code></td>
<td>列出包含所有可用信息的文件，包括隐藏文件</td>
</tr>
<tr>
<td><code>ls -d */</code></td>
<td><code>ls | where type == dir</code></td>
<td>列出目录</td>
</tr>
<tr>
<td><code>find . -name *.rs</code></td>
<td><code>ls **/*.rs</code></td>
<td>递归地查找匹配给定模式的所有文件</td>
</tr>
<tr>
<td><code>find . -name Makefile | xargs vim</code></td>
<td><code>ls \*\*/Makefile | get name | vim $in</code></td>
<td>将值作为命令参数传递</td>
</tr>
<tr>
<td><code>cd &lt;directory&gt;</code></td>
<td><code>cd &lt;directory&gt;</code></td>
<td>切换到给定目录</td>
</tr>
<tr>
<td><code>cd</code></td>
<td><code>cd</code></td>
<td>切换到用户主目录</td>
</tr>
<tr>
<td><code>cd -</code></td>
<td><code>cd -</code></td>
<td>切换到前一个目录</td>
</tr>
<tr>
<td><code>mkdir &lt;path&gt;</code></td>
<td><code>mkdir &lt;path&gt;</code></td>
<td>创建给定的路径</td>
</tr>
<tr>
<td><code>mkdir -p &lt;path&gt;</code></td>
<td><code>mkdir &lt;path&gt;</code></td>
<td>创建给定的路径，如果父目录不存在则自动创建</td>
</tr>
<tr>
<td><code>touch test.txt</code></td>
<td><code>touch test.txt</code></td>
<td>新建文件</td>
</tr>
<tr>
<td><code>&gt; &lt;path&gt;</code></td>
<td><code>| save --raw &lt;path&gt;</code></td>
<td>保存字符串到给定文件</td>
</tr>
<tr>
<td><code>&gt;&gt; &lt;path&gt;</code></td>
<td><code>| save --raw --append &lt;path&gt;</code></td>
<td>追加字符串到给定文件</td>
</tr>
<tr>
<td><code>cat &lt;path&gt;</code></td>
<td><code>open --raw &lt;path&gt;</code></td>
<td>显示给定文件的内容</td>
</tr>
<tr>
<td></td>
<td><code>open &lt;path&gt;</code></td>
<td>将文件作为结构化数据读取</td>
</tr>
<tr>
<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>mv &lt;source&gt; &lt;dest&gt;</code></td>
<td>移动文件到新的位置</td>
</tr>
<tr>
<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>cp &lt;source&gt; &lt;dest&gt;</code></td>
<td>复制文件到新的位置</td>
</tr>
<tr>
<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>
<td><code>cp -r &lt;source&gt; &lt;dest&gt;</code></td>
<td>递归地将目录复制到一个新的位置</td>
</tr>
<tr>
<td><code>rm &lt;path&gt;</code></td>
<td><code>rm &lt;path&gt;</code></td>
<td>删除给定的文件</td>
</tr>
<tr>
<td></td>
<td><code>rm -t &lt;path&gt;</code></td>
<td>将给定的文件移到系统垃圾箱</td>
</tr>
<tr>
<td><code>rm -rf &lt;path&gt;</code></td>
<td><code>rm -r &lt;path&gt;</code></td>
<td>递归地删除给定的路径</td>
</tr>
<tr>
<td><code>chmod</code></td>
<td><code>&lt;not yet possible&gt;</code></td>
<td>改变文件属性</td>
</tr>
<tr>
<td><code>date -d &lt;date&gt;</code></td>
<td><code>&quot;&lt;date&gt;&quot; | into datetime -f &lt;format&gt;</code></td>
<td>解析日期 (<a href="https://docs.rs/chrono/0.4.15/chrono/format/strftime/index.html" target="_blank" rel="noopener noreferrer">日期格式文档</a>)</td>
</tr>
<tr>
<td><code>sed</code></td>
<td><code>str find-replace</code></td>
<td>查找和替换一个字符串中的模式</td>
</tr>
<tr>
<td><code>grep &lt;pattern&gt;</code></td>
<td><code>where $it =~ &lt;substring&gt;</code> or <code>find &lt;substring&gt;</code></td>
<td>过滤包含特定字符串的字符串</td>
</tr>
<tr>
<td><code>man &lt;command&gt;</code></td>
<td><code>help &lt;command&gt;</code></td>
<td>获得特定命令的帮助信息</td>
</tr>
<tr>
<td></td>
<td><code>help commands</code></td>
<td>列出所有可用的命令</td>
</tr>
<tr>
<td></td>
<td><code>help --find &lt;string&gt;</code></td>
<td>在所有可用的命令中搜索</td>
</tr>
<tr>
<td><code>command1 &amp;&amp; command2</code></td>
<td><code>command1; command2</code></td>
<td>运行一条命令，如果成功的话，再运行第二条</td>
</tr>
<tr>
<td><code>stat $(which git)</code></td>
<td><code>stat (which git).path</code></td>
<td>使用命令输出作为其他命令的参数</td>
</tr>
<tr>
<td><code>echo $PATH</code></td>
<td><code>echo $env.PATH</code></td>
<td>查看当前路径</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>vim $nu.config-path</code></td>
<td>永久地更新 PATH</td>
</tr>
<tr>
<td><code>export PATH = $PATH:/usr/other/bin</code></td>
<td><code>let-env PATH = ($env.PATH | append /usr/other/bin)</code></td>
<td>临时更新 PATH</td>
</tr>
<tr>
<td><code>export</code></td>
<td><code>echo $env</code></td>
<td>列出当前的环境变量</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>vim $nu.config-path</code></td>
<td>永久地更新环境变量</td>
</tr>
<tr>
<td><code>FOO=BAR ./bin</code></td>
<td><code>FOO=BAR ./bin</code></td>
<td>临时修改环境变量</td>
</tr>
<tr>
<td><code>export FOO=BAR</code></td>
<td><code>let-env FOO = BAR</code></td>
<td>为当前会话设置环境变量</td>
</tr>
<tr>
<td><code>echo $FOO</code></td>
<td><code>echo $env.FOO</code></td>
<td>使用环境变量</td>
</tr>
<tr>
<td><code>unset FOO</code></td>
<td><code>hide FOO</code></td>
<td>取消对当前会话的环境变量设置</td>
</tr>
<tr>
<td><code>alias s=&quot;git status -sb&quot;</code></td>
<td><code>alias s = git status -sb</code></td>
<td>临时定义一个别名</td>
</tr>
<tr>
<td><code>type FOO</code></td>
<td><code>which FOO</code></td>
<td>显示一个命令的信息（内置、别名或可执行）</td>
</tr>
<tr>
<td><code>&lt;update ~/.bashrc&gt;</code></td>
<td><code>vim $nu.config-path</code></td>
<td>永久添加和编辑别名（新开Shell会话生效）</td>
</tr>
<tr>
<td><code>bash -c &lt;commands&gt;</code></td>
<td><code>nu -c &lt;commands&gt;</code></td>
<td>运行一组命令（需要0.9.1或更高版本）</td>
</tr>
<tr>
<td><code>bash &lt;script file&gt;</code></td>
<td><code>nu &lt;script file&gt;</code></td>
<td>运行一个脚本文件（需要0.9.1或更高版本）</td>
</tr>
<tr>
<td><code>\</code></td>
<td><code>(</code> followed by <code>)</code></td>
<td>目前还不支持换行延续性</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  <entry>
    <title type="html">命令索引</title>
    <id>www.nushell.sh/zh-CN/book/command_reference.html</id>
    <link href="www.nushell.sh/zh-CN/book/command_reference.html"/>
    <updated>2022-06-04T13:17:54.505Z</updated>
    <content type="html"><![CDATA[<h1 id="命令索引" tabindex="-1"> 命令索引</h1>
<p>若要查看所有 Nushell 命令, 可以执行 <a href="/book/commands/help.html"><code>help commands</code></a>。</p>
<p>译注：本页内容由于是从源码生成的暂不支持国际化，大家还是先看英文版的凑合下吧。</p>
<table>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  <tr v-for="command in commands">
   <td><a :href="command.path"><code>{{ command.title }}</code></a></td>
   <td style="white-space: pre-wrap;">{{ command.frontmatter.usage }}</td>
  </tr>
</table>
]]></content>
  </entry>
  <entry>
    <title type="html">配置</title>
    <id>www.nushell.sh/zh-CN/book/configuration.html</id>
    <link href="www.nushell.sh/zh-CN/book/configuration.html"/>
    <updated>2022-06-04T13:17:54.506Z</updated>
    <content type="html"><![CDATA[<h1 id="配置" tabindex="-1"> 配置</h1>
<h2 id="nushell-配置与env-nu和config-nu" tabindex="-1"> Nushell 配置与<code>env.nu</code>和<code>config.nu</code></h2>
<p>Nushell 使用一个配置系统，在启动时加载并运行两个 Nushell 脚本文件：
首先是<code>env.nu</code>，然后是<code>config.nu</code>。
这些文件的路径可以通过调用<code>echo $nu.env-path</code>和<code>echo $nu.config-path</code>找到。
<code>env.nu</code>是用来定义环境变量的，之后这些环境变量定义将在<code>config.nu</code>中可用；
<code>config.nu</code>可以用来在全局命名空间中添加定义、别名等等。</p>
<p><em>(你可以把 Nushell 的配置加载顺序想象成在启动时执行两行 <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" target="_blank" rel="noopener noreferrer">REPL</a>：<code>source /path/to/env.nu</code>和<code>source /path/to/config.nu</code>。因此，用<code>env.nu</code>表示环境，用<code>config.nu</code>表示其他配置只是一个约定。)</em></p>
<p>当你在没有设置这些文件的情况下启动 Nushell，Nushell 会提示你下载<a href="https://github.com/nushell/nushell/blob/main/docs/sample_config/default_env.nu" target="_blank" rel="noopener noreferrer"><code>default env.nu</code></a>和<a href="https://github.com/nushell/nushell/blob/main/docs/sample_config/default_config.nu" target="_blank" rel="noopener noreferrer"><code>default config.nu</code></a>。
你可以通过浏览这些默认文件，了解环境变量的默认值和所有可配置项的列表。</p>
<h3 id="配置-env-config" tabindex="-1"> 配置 <code>$env.config</code></h3>
<p>Nushell 的主要设置是以记录的形式保存在 <code>config</code> 环境变量中。这个记录可以用以下方式创建：</p>
<div><pre><code>let-env <span>$config</span> <span>=</span> <span>{</span>
  <span>..</span>.
<span>}</span>
</code></pre></div><p>你也可以隐藏(shadow)<code>$env.config</code>并更新它：</p>
<div><pre><code>let-env <span>$config</span> <span>=</span> <span>(</span><span>$env</span>.config <span>|</span> upsert <span>&lt;</span>field name<span>></span> <span>&lt;</span>field value<span>></span><span>)</span>
</code></pre></div><p>按照约定，这个变量被定义在<code>config.nu</code>文件中。</p>
<h3 id="环境" tabindex="-1"> 环境</h3>
<p>你可以在 Nushell 会话期间使用<a href="/book/commands/let-env.html"><code>let-env</code></a>在<code>env.nu</code>文件中设置环境变量。比如：</p>
<div><pre><code>let-env FOO <span>=</span> <span>'BAR'</span>
</code></pre></div><p><em>(尽管 <code>$env.config</code> 是一个环境变量，按照惯例它仍然在 <code>config.nu</code> 中定义。)</em></p>
<p>以下是值得关注的且为 Nushell 所特有的几个相对重要的环境变量：</p>
<ul>
<li><code>LS_COLORS</code>: 在<code>ls</code>中为每个文件类型设置颜色</li>
<li><code>PROMPT_COMMAND</code>: 为设置提示而执行的代码（块或字符串）</li>
<li><code>PROMPT_COMMAND_RIGHT</code>: 为设置正确的提示而执行的代码（块）</li>
<li><code>PROMPT_INDICATOR = &quot;〉&quot;</code>: 提示后打印的提示符（默认为 &quot;&gt;&quot; 类似的 Unicode 符号）</li>
<li><code>PROMPT_INDICATOR_VI_INSERT = &quot;: &quot;</code></li>
<li><code>PROMPT_INDICATOR_VI_NORMAL = &quot;〉 &quot;</code></li>
<li><code>PROMPT_MULTILINE_INDICATOR = &quot;::: &quot;</code></li>
</ul>
<h3 id="颜色配置部分" tabindex="-1"> 颜色配置部分</h3>
<p>你可以在 <a href="/zh-CN/book/coloring_and_theming.html">相关章节</a> 中了解更多关于设置颜色和主题的信息。</p>
<h2 id="将-nu-配置为登录-shell" tabindex="-1"> 将 Nu 配置为登录 Shell</h2>
<p>要把 Nu 作为一个登录 Shell，你需要配置<code>$env</code>变量。这样，在你将使用 Nu 为登录 Shell 时才有足够的支持来运行外部命令。</p>
<p>你可以通过在另一个 Shell（如 Bash）中运行 Nu 来建立完整的环境变量集。一旦你进入 Nu，你可以运行这样的命令：</p>
<div><pre><code><span>></span> <span>env</span> <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> <span>echo</span> $<span>"let-env (<span>$it</span>.name) = '(<span>$it</span>.raw)'"</span> <span>}</span> <span>|</span> str collect <span>(</span>char <span>nl</span><span>)</span>
</code></pre></div><p>这将打印出<a href="/book/commands/let-env.html"><code>let-env</code></a>所有行，且包含每个环境变量及其设置。</p>
<p>接下来，在一些发行版上，你还需要确保 Nu 在<code>/etc/shells</code>列表中：</p>
<div><pre><code><span>></span> <span>cat</span> /etc/shells
<span># /etc/shells: valid login shells</span>
/bin/sh
/bin/dash
/bin/bash
/bin/rbash
/usr/bin/screen
/usr/bin/fish
/home/jonathan/.cargo/bin/nu
</code></pre></div><p>这样你就可以使用<code>chsh</code>命令来将 Nu 设置为你的登录 Shell。在你注销后下次登录时，应该可以看到一个闪亮的 Nu 提示。</p>
<h3 id="macos-保持-open-为-usr-bin-open" tabindex="-1"> macOS: 保持 <code>open</code> 为 <code>/usr/bin/open</code></h3>
<p>一些工具（例如 Emacs）依靠<code>open</code>命令来打开 Mac 上的文件。
由于 Nushell 有自己的<a href="/book/commands/open.html"><code>open</code></a>命令，它有不同的语义并隐藏了<code>/usr/bin/open</code>，这样某些工具在试图使用它时将出错。
一个解决这个问题的方法是为 Nushell 的<code>open</code>定义一个自定义命令，并在你的<code>config.nu</code>文件中为系统的<code>open</code>创建一个别名，像这样：</p>
<div><pre><code>def nuopen <span>[</span>arg, --raw <span>(</span>-r<span>)</span><span>]</span> <span>{</span> <span>if</span> <span>$raw</span> <span>{</span> <span>open</span> -r <span>$arg</span> <span>}</span> <span>else</span> <span>{</span> <span>open</span> <span>$arg</span> <span>}</span> <span>}</span>
<span>alias</span> <span>open</span> <span>=</span> ^open
</code></pre></div><h2 id="path-配置" tabindex="-1"> <code>PATH</code> 配置</h2>
<p>要在 <a href="https://en.wikipedia.org/wiki/PATH_(variable)" target="_blank" rel="noopener noreferrer">PATH 变量</a> 中添加一个路径，你可以在<code>env.nu</code>中使用 <a href="/book/commands/let-env.html"><code>let-env</code></a> 和 <a href="/book/commands/append.html"><code>append</code></a> 完成，如下：</p>
<div><pre><code>let-env <span>PATH</span> <span>=</span> <span>(</span><span>$env</span><span>.</span><span>PATH</span> <span>|</span> append <span>'/some/path'</span><span>)</span>
</code></pre></div><p>这将把<code>/some/path</code>追加到<code>PATH</code>的末尾；你也可以使用 <a href="/book/commands/prepend.html"><code>prepend</code></a> 将该路径添加到<code>PATH</code>的开头。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">创建你自己的错误</title>
    <id>www.nushell.sh/zh-CN/book/creating_errors.html</id>
    <link href="www.nushell.sh/zh-CN/book/creating_errors.html"/>
    <updated>2022-06-04T13:17:54.506Z</updated>
    <content type="html"><![CDATA[<h1 id="创建你自己的错误" tabindex="-1"> 创建你自己的错误</h1>
<p>使用 <a href="/zh-CN/book/metadata.html">元数据</a> 信息，你可以创建自己的自定义错误，错误信息由多个部分构成：</p>
<ul>
<li>错误的标题</li>
<li>错误信息的标签，其中包括标签的文本和要标注下划线的范围</li>
</ul>
<p>你可以使用<code>error make</code>命令来创建你自己的错误信息。例如，假设你有自己的名为<code>my-command</code>的命令，你想给调用者一个错误信息，说明传入的一个参数有问题。</p>
<p>首先，你可以从参数的来源中获取标注范围：</p>
<div><pre><code><span>let</span> span <span>=</span> <span>(</span>metadata <span>$x</span><span>)</span>.span<span>;</span>
</code></pre></div><p>接下来你可以通过 <code>error make</code> 命令来创建一个错误，该命令需要一个可以描述待创建错误的记录作为输入：</p>
<div><pre><code>error <span>make</span> <span>{</span>msg: <span>"this is fishy"</span>, label: <span>{</span>text: <span>"fish right here"</span>, start: <span>$span</span>.start, end: <span>$span</span>.end <span>}</span> <span>}</span>
</code></pre></div><p>与你的自定义命令放在一起后，它可能看起来像这样：</p>
<div><pre><code>def my-command <span>[</span>x<span>]</span> <span>{</span>
    <span>let</span> span <span>=</span> <span>(</span>metadata <span>$x</span><span>)</span>.span<span>;</span>
    error <span>make</span> <span>{</span>
        msg: <span>"this is fishy"</span>,
        label: <span>{</span>
            text: <span>"fish right here"</span>,
            start: <span>$span</span>.start,
            end: <span>$span</span>.end
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>现在当传入一个值调用时，我们会看到一个错误信息返回：</p>
<div><pre><code><span>></span> my-command <span>100</span>

Error:
  × this is fishy
   ╭─<span>[</span>entry <span>#5:1:1]</span>
 <span>1</span> │ my-command <span>100</span>
   ·            ─┬─
   ·             ╰── fish right here
   ╰────
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">自定义命令</title>
    <id>www.nushell.sh/zh-CN/book/custom_commands.html</id>
    <link href="www.nushell.sh/zh-CN/book/custom_commands.html"/>
    <updated>2022-06-04T13:17:54.506Z</updated>
    <content type="html"><![CDATA[<h1 id="自定义命令" tabindex="-1"> 自定义命令</h1>
<p>Nu 具备组合长管道的能力使你对数据和系统有很强的控制力，但它的代价是需要大量的键盘输入。不过理想情况下，你可以保存精心设计的管道以便反复使用。</p>
<p>这就是自定义命令(Custom Commands)的作用。</p>
<p>下面看一个自定义命令的例子：</p>
<div><pre><code>def greet <span>[</span>name<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello"</span> <span>$name</span>
<span>}</span>
</code></pre></div><p>在这个定义中，我们定义了<code>greet</code>命令，它需要一个参数<code>name</code>。在这个参数后面是自定义命令运行时将执行的代码块。当被调用时，自定义命令将把传递给<code>name</code>的值设置为<code>$name</code>变量，该变量在块内是可用的。</p>
<p>要运行上述命令，我们可以像调用内置命令一样调用它：</p>
<div><pre><code><span>></span> greet <span>"world"</span>
</code></pre></div><p>当我们这样做的时候，就会得到输出，如同我们使用内置命令一样：</p>
<div><pre><code>───┬───────
 0 │ hello
 1 │ world
───┴───────
</code></pre></div><div><p>TIP</p>
<p><code>echo</code>将其参数分别返回给管道。如果你想用它来生成一个单一的字符串，请在管道中添加<code> | str collect</code>：</p>
<div><pre><code>def greet <span>[</span>name<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello "</span> <span>$name</span> <span>|</span> str collect
<span>}</span>

greet nushell
</code></pre></div><p>返回 <code>hello nushell</code></p>
</div>
<h2 id="命令名称" tabindex="-1"> 命令名称</h2>
<p>在 Nushell 中，命令名是一串字符或一个带引号的字符串。下面是一些有效命令名的例子：<code>greet</code>, <code>get-size</code>, <code>mycommand123</code>, <code>&quot;mycommand&quot;</code>, <code>😊</code>, 和<code>123</code>。</p>
<p><em>注意：在 Nushell 中，通常的做法是用<code>-</code>来分隔命令的多个单词，以提高可读性。</em> 例如，使用 <code>get-size</code> 而不是 <code>getsize</code> 或者 <code>get_size</code>。</p>
<h2 id="子命令" tabindex="-1"> 子命令</h2>
<p>你也可以使用空格来定义命令的子命令(Subcommand)。例如，如果我们想给<code>str</code>添加一个新的子命令，可以通过命名我们的子命令以 &quot;str&quot; 开头来做到。比如：</p>
<div><pre><code>def <span>"str mycommand"</span> <span>[</span><span>]</span> <span>{</span>
  <span>echo</span> hello
<span>}</span>
</code></pre></div><p>现在我们可以像调用<code>str</code>的内置子命令一样调用我们的自定义命令：</p>
<div><pre><code><span>></span> str mycommand
</code></pre></div><h2 id="参数类型" tabindex="-1"> 参数类型</h2>
<p>在定义自定义命令时，你可以为每个参数命名并选择性地设置其类型。例如，你可以把上面的内容写成：</p>
<div><pre><code>def greet <span>[</span>name: string<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello "</span> <span>$name</span> <span>|</span> str collect
<span>}</span>
</code></pre></div><p>参数的类型是可选的。Nushell 支持不添加类型，此时会把参数类型当作<code>any</code>。如果你在参数上标注了一个类型，Nushell 将在你调用函数的时候检查该类型。</p>
<p>例如，假设你需要输入一个<code>int</code>类型：</p>
<div><pre><code>def greet <span>[</span>name: int<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello "</span> <span>$name</span> <span>|</span> str collect
<span>}</span>

greet world
</code></pre></div><p>如果我们尝试运行上述内容，Nushell 会告诉我们，类型不匹配：</p>
<div><pre><code>error: Type Error
  ┌─ shell:6:7
  │
5 │ greet world
  │       ^^^^^ Expected int, found world
</code></pre></div><p>这可以帮助指导你的用户只使用支持的类型来调用你所定义的命令。</p>
<p>目前可以支持的类型是（从 0.59.0 版本开始）：</p>
<ul>
<li><code>any</code></li>
<li><code>block</code></li>
<li><code>cell-path</code></li>
<li><code>duration</code></li>
<li><code>path</code></li>
<li><code>expr</code></li>
<li><code>filesize</code></li>
<li><code>glob</code></li>
<li><code>int</code></li>
<li><code>math</code></li>
<li><code>number</code></li>
<li><code>operator</code></li>
<li><code>range</code></li>
<li><code>cond</code></li>
<li><code>bool</code></li>
<li><code>signature</code></li>
<li><code>string</code></li>
<li><code>variable</code></li>
</ul>
<h2 id="具有默认值的参数" tabindex="-1"> 具有默认值的参数</h2>
<p>若要使一个参数成为可选的，并具有默认值，你可以在命令定义中指定该默认值：</p>
<div><pre><code>def greet <span>[</span>name <span>=</span> <span>"nushell"</span><span>]</span> <span>{</span>
  <span>echo</span> <span>"hello "</span> <span>$name</span> <span>|</span> str collect
<span>}</span>
</code></pre></div><p>你可以在没有参数的情况下调用这个命令，也可以指定一个值来覆盖默认值：</p>
<div><pre><code>> greet
hello nushell
> greet world
hello world
</code></pre></div><p>你也可以将默认值与相结合：</p>
<div><pre><code>def congratulate [age: int = 18] {
  echo "Happy birthday! Wow you are " $age " years old now!" | str collect
}
</code></pre></div><p>如果你想检查一个可选参数是否存在，而不是仅仅依赖一个默认值，请使用代替。</p>
<h2 id="可选位置参数" tabindex="-1"> 可选位置参数</h2>
<p>默认情况下，位置参数(Positional Parameters)是必须的。如果没有传递位置参数，我们将遇到一个报错：</p>
<div><pre><code>  × Missing required positional argument.
   ╭─[entry #23:1:1]
 1 │ greet
   ·      ▲
   ·      ╰── missing name
   ╰────
  help: Usage: greet &lt;name>
</code></pre></div><p>我们可以在一个位置参数的名字后面加上一个问号（<code>?</code>），将其标记为可选参数。比如：</p>
<div><pre><code>def greet <span>[</span>name?: string<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello"</span> <span>$name</span> <span>|</span> str collect
<span>}</span>

greet
</code></pre></div><p>使一个位置参数成为可选参数并不改变它在命令体中被访问的名称。如上例所示，尽管参数列表中有<code>?</code>的后缀，但它仍然以<code>$name</code>的形式被访问。</p>
<p>当一个可选参数没有被传递，它在命令体中的值等于<code>null</code>和<code>$nothing</code>。我们可以利用这一点来对没有传递参数的情况进行处理：</p>
<div><pre><code>def greet <span>[</span>name?: string<span>]</span> <span>{</span>
  <span>if</span> <span>(</span><span>$name</span> <span>==</span> null<span>)</span> <span>{</span>
    <span>echo</span> <span>"hello, I don't know your name!"</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>echo</span> <span>"hello "</span> <span>$name</span> <span>|</span> str collect
  <span>}</span>
<span>}</span>

greet
</code></pre></div><p>如果你只是想在参数缺失时设置一个默认值，那么使用来代替就更简单了。</p>
<p>如果必需的和可选的位置参数一起使用，那么必需的参数必须先出现在定义中。</p>
<h2 id="标志" tabindex="-1"> 标志</h2>
<p>除了传递位置参数之外, 你还可以通过为自定义命令定义标志(Flags)来传递命名参数。</p>
<p>比如：</p>
<div><pre><code>def greet <span>[</span>
  name: string
  --age: int
<span>]</span> <span>{</span>
  <span>echo</span> <span>$name</span> <span>$age</span>
<span>}</span>
</code></pre></div><p>在上面的<code>greet</code>定义中，我们定义了<code>name</code>位置参数以及<code>age</code>标志。这允许<code>greet</code>的调用者也可以选择传递<code>age</code>参数。</p>
<p>你可以用以下方法调用上述内容：</p>
<div><pre><code><span>></span> greet world --age <span>10</span>
</code></pre></div><p>或者：</p>
<div><pre><code><span>></span> greet --age <span>10</span> world
</code></pre></div><p>或者甚至完全不使用标志：</p>
<div><pre><code>> greet world
</code></pre></div><p>标志也可以指定一个缩写版本，这允许你传递一个更简单的标志，如同传递一个更容易阅读的全写标志那样。</p>
<p>让我们扩展前面的例子，为<code>age</code>添加一个缩写标志：</p>
<div><pre><code>def greet <span>[</span>
  name: string
  --age <span>(</span>-a<span>)</span>: int
<span>]</span> <span>{</span>
  <span>echo</span> <span>$name</span> <span>$age</span>
<span>}</span>
</code></pre></div><p><em>注意：</em> 标志是以其全称命名的，所以上面的例子的命令体内需要使用<code>$age</code>而不是<code>$a</code>。</p>
<p>现在，我们可以使用缩写标志来调用这个新的定义：</p>
<div><pre><code>> greet -a 10 hello
</code></pre></div><h2 id="剩余参数" tabindex="-1"> 剩余参数</h2>
<p>在某些情况下, 你可能想定义一个需要任意数量的位置参数的命令。我们可以用一个剩余参数(Rest Parameter)来实现这一点，通过下面的<code>...</code>语法：</p>
<div><pre><code>def greet <span>[</span><span>..</span>.name: string<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello all:"</span>
  <span>for</span> <span>$n</span> <span>in</span> <span>$name</span> <span>{</span>
    <span>echo</span> <span>$n</span>
  <span>}</span>
<span>}</span>

greet earth mars jupiter venus
</code></pre></div><p>我们可以使用任意数量的参数来调用上述<code>greet</code>命令的定义，包括完全没有参数，所有的参数都将被收集到<code>$name</code>列表中。</p>
<p>剩余参数可以和位置参数一起使用：</p>
<div><pre><code>def greet <span>[</span>vip: string, <span>..</span>.name: string<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello to our VIP "</span> <span>$vip</span> <span>|</span> str collect
  <span>echo</span> <span>"and hello to everybody else:"</span>
  <span>for</span> <span>$n</span> <span>in</span> <span>$name</span> <span>{</span>
    <span>echo</span> <span>$n</span>
  <span>}</span>
<span>}</span>

<span>#     $vip          $name</span>
<span>#     ---- ------------------------</span>
greet moon earth mars jupiter venus
</code></pre></div><h2 id="为命令添加文档" tabindex="-1"> 为命令添加文档</h2>
<p>为了更好地帮助用户使用你的自定义命令，也可以为其添加额外的命令和参数描述。</p>
<p>以我们之前的例子为例：</p>
<div><pre><code>def greet <span>[</span>
  name: string
  --age <span>(</span>-a<span>)</span>: int
<span>]</span> <span>{</span>
  <span>echo</span> <span>$name</span> <span>$age</span>
<span>}</span>
</code></pre></div><p>一旦定义完毕，我们可以运行<code>help greet</code>来获得该命令的帮助信息：</p>
<div><pre><code>Usage:
  > greet &lt;name> {flags}

Parameters:
  &lt;name>

Flags:
  -h, --help: Display this help message
  -a, --age &lt;integer>
</code></pre></div><p>你可以看到我们定义的参数和标志，以及所有命令都会得到的<code>-h</code>帮助标志。</p>
<p>为了改进这个帮助，我们可以在定义中加入描述，这些描述将在帮助中显示出来：</p>
<div><pre><code><span># A greeting command that can greet the caller</span>
def greet <span>[</span>
  name: string      <span># The name of the person to greet</span>
  --age <span>(</span>-a<span>)</span>: int   <span># The age of the person</span>
<span>]</span> <span>{</span>
  <span>echo</span> <span>$name</span> <span>$age</span>
<span>}</span>
</code></pre></div><p>我们给定义和参数添加的注释会作为描述出现在命令的<code>help</code>中。</p>
<p>现在，如果我们运行<code>help greet</code>，就会得到一些更友好的帮助文本：</p>
<div><pre><code>A greeting command that can greet the caller

Usage:
  > greet &lt;name> {flags}

Parameters:
  &lt;name> The name of the person to greet

Flags:
  -h, --help: Display this help message
  -a, --age &lt;integer>: The age of the person
</code></pre></div><h2 id="管道输出" tabindex="-1"> 管道输出</h2>
<p>自定义命令会像内置命令一样流式输出。例如，假设我们想重构这个管道：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> get name
</code></pre></div><p>让我们把<a href="/book/commands/ls.html"><code>ls</code></a>移到我们编写的命令中：</p>
<div><pre><code>def my-ls <span>[</span><span>]</span> <span>{</span> <span>ls</span> <span>}</span>
</code></pre></div><p>我们就可以像使用<a href="/book/commands/ls.html"><code>ls</code></a>一样使用这个命令的输出：</p>
<div><pre><code>> my-ls | get name
───┬───────────────────────
 0 │ myscript.nu
 1 │ myscript2.nu
 2 │ welcome_to_nushell.md
───┴───────────────────────
</code></pre></div><p>这让我们可以很容易地创建自定义命令并处理它们的输出。注意，我们不像其他语言那样使用返回语句，取而代之的是我们创建管道，而其输出数据流可以连接到其他管道。</p>
<h2 id="管道输入" tabindex="-1"> 管道输入</h2>
<p>如同其他命令一样，自定义命令也可以从管道中获取输入，这个输入会自动传递给自定义命令所使用的代码块。</p>
<p>让我们创建一个把所有接收值都加倍的命令：</p>
<div><pre><code>def double <span>[</span><span>]</span> <span>{</span>
  each <span>{</span> <span>|</span>it<span>|</span> <span>2</span> * <span>$it</span> <span>}</span>
<span>}</span>
</code></pre></div><p>现在，如果我们在一个管道中调用上述命令，就可以看到它对输入的处理结果：</p>
<div><pre><code>> [1 2 3] | double
───┬─────
 0 │ 2
 1 │ 4
 2 │ 6
───┴─────
</code></pre></div><p>我们还可以使用<code>$in</code>变量来存储输入，以便在后面使用：</p>
<div><pre><code>def nullify <span>[</span><span>..</span>.cols<span>]</span> <span>{</span>
  <span>let</span> start <span>=</span> <span>$in</span>
  <span>$cols</span> <span>|</span> reduce --fold <span>$start</span> <span>{</span> <span>|</span>col, <span>df</span><span>|</span>
    <span>$df</span> <span>|</span> upsert <span>$col</span> null
  <span>}</span>
<span>}</span>
</code></pre></div><h2 id="持久化" tabindex="-1"> 持久化</h2>
<p>关于如何持久化自定义命令，以便在你启动 Nushell 时它们是可用的，请参阅 <a href="/zh-CN/book/configuration.html">配置</a> 部分并添加你的启动脚本。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">自定义补全</title>
    <id>www.nushell.sh/zh-CN/book/custom_completions.html</id>
    <link href="www.nushell.sh/zh-CN/book/custom_completions.html"/>
    <updated>2022-06-04T13:17:54.507Z</updated>
    <content type="html"><![CDATA[<h1 id="自定义补全" tabindex="-1"> 自定义补全</h1>
<p>自定义补全允许你混合使用 Nushell 的两个功能：自定义命令和补全。有了它们，你就能够创建支持对位置参数和标志(Flags)参数进行自动补全的命令。这些自定义补全既适用于自定义命令，也适用于 <a href="/zh-CN/book/externs.html">已知的外部或<code>extern</code>命令</a>。</p>
<p>自定义命令有两个部分：处理补全的命令和使用<code>@</code>将此命令附加到另一个命令的类型中。</p>
<h2 id="自定义补全例子" tabindex="-1"> 自定义补全例子</h2>
<p>我们来看一个例子：</p>
<div><pre><code><span>></span> def animals <span>[</span><span>]</span> <span>{</span> <span>[</span><span>"cat"</span>, <span>"dog"</span>, <span>"eel"</span> <span>]</span> <span>}</span>
<span>></span> def my-command <span>[</span>animal: string@animals<span>]</span> <span>{</span> print <span>$animal</span> <span>}</span>
<span>>|</span> my-command
<span>cat</span>                 dog                 eel
</code></pre></div><p>在第一行中，我们创建了一个自定义命令，将返回三个不同动物的列表。这些是我们想在补全中使用的值。一旦我们创建了这个命令，我们就可以用它来为其他自定义命令和 <code>extern</code> 提供补全。</p>
<p>在第二行，我们使用<code>string@animals</code>。这告诉了 Nushell 两件事：用于类型检查的参数的形状，以及如果用户想在该位置补全输入值，需要使用的自定义完成。</p>
<p>在第三行，我们输入我们的自定义命令的名称<code>my-command</code>，然后输入空格，再输入<code>&lt;tab&gt;</code>键，就可以触发我们的自动补全功能。自定义补全的工作方式与系统中的其他补全方式相同，比如允许你输入<code>e</code>，然后按<code>&lt;tab&gt;</code>键，得到 &quot;eel&quot; 自动补全。</p>
<h2 id="模块和自定义补全" tabindex="-1"> 模块和自定义补全</h2>
<p>你可能更喜欢让你的自定义补全远离你的代码的公共 API。为此，你可以将模块和自定义补全结合起来。</p>
<p>让我们把上面的例子放在一个模块中：</p>
<div><pre><code>module commands <span>{</span>
    def animals <span>[</span><span>]</span> <span>{</span>
        <span>[</span><span>"cat"</span>, <span>"dog"</span>, <span>"eel"</span> <span>]</span>
    <span>}</span>

    <span>export</span> def my-command <span>[</span>animal: string@animals<span>]</span> <span>{</span>
        print <span>$animal</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>在我们的模块中，我们选择只导出自定义命令<code>my-command</code>，而不导出自定义补全<code>animals</code>。这使得本模块的用户可以调用命令，甚至使用自定义补全逻辑，而不需要访问自定义补全。这样可以让 API 更干净，同时仍然提供所有相同的好处。</p>
<p>这是可能的，因为使用<code>@</code>的自定义补全标签在命令第一次被解析时就被锁定了。</p>
<h2 id="自定义补全和-extern" tabindex="-1"> 自定义补全和 <code>extern</code></h2>
<p>一个强大的组合是为 <a href="/zh-CN/book/externs.html">已知的<code>extern</code>命令</a> 添加自定义补全。这些工作方式与向自定义命令添加自定义补全的方式相同：创建自定义补全，然后用<code>@</code>附加到 <code>extern</code> 的一个位置参数或标志参数的类型中。</p>
<p>如果你仔细看一下默认配置中的例子，你会看到这个：</p>
<div><pre><code><span>export</span> extern <span>"git push"</span> <span>[</span>
    remote?: string@<span>"nu-complete git remotes"</span>, <span># the name of the remote</span>
    refspec?: string@<span>"nu-complete git branches"</span># the branch / refspec
    <span>..</span>.
<span>]</span>
</code></pre></div><p>自定义补全在这个例子中的作用与前面的例子中的作用相同。上面的例子根据用户当前所处的位置，调用了两个不同的自定义补全。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">DataFrames</title>
    <id>www.nushell.sh/zh-CN/book/dataframes.html</id>
    <link href="www.nushell.sh/zh-CN/book/dataframes.html"/>
    <updated>2022-06-04T13:17:54.509Z</updated>
    <content type="html"><![CDATA[<h1 id="dataframes" tabindex="-1"> DataFrames</h1>
<div><p>TIP</p>
<p>DataFrame 相关命令从 0.33.1 版本开始支持</p>
</div>
<p>正如我们到目前为止所看到的，Nushell 把数据处理作为其主要任务。<code>Lists</code> 和 <code>Tables</code>的存在是为了帮助你循环处理值，以便执行多种操作或轻而易举地找到数据。然而，在某些操作中，基于行的数据布局并不是处理数据的最有效方式，特别是在处理极其庞大的文件时。对于大型数据集的<code>group-by</code>或<code>join</code>等操作，如果不使用适当的数据格式，会占用大量的内存，并可能耗费大量的计算时间。</p>
<p>出于这个原因，Nushell 引入了<code>DataFrame</code>结构。<code>DataFrame</code>以列格式存储数据，以 <a href="https://arrow.apache.org/" target="_blank" rel="noopener noreferrer">Apache Arrow</a> 规范为基础，并使用 <a href="https://github.com/pola-rs/polars" target="_blank" rel="noopener noreferrer">Polars</a> 作为执行极其 <a href="https://h2oai.github.io/db-benchmark/" target="_blank" rel="noopener noreferrer">快速列式操作</a> 的马达。</p>
<p>你现在可能想知道这个组合能有多快，以及它如何能使数据工作更容易、更可靠。出于这个原因，让我们在本页开始时介绍一下处理数据时的常见操作的性能测试情况。</p>
<h2 id="性能测试对比" tabindex="-1"> 性能测试对比</h2>
<p>在这个小的性能测试练习中，我们将比较本地的 Nushell 原生命令、Nushell DataFrame 相关命令和<a href="https://pandas.pydata.org/" target="_blank" rel="noopener noreferrer">Python Pandas</a>命令。暂时不要太在意<code>dataframe</code>命令，它们将在本页后面的章节中解释。</p>
<blockquote>
<p>系统细节：本节介绍的性能测试是用一台配备 Intel(R) Core(TM) i7-10710U
（CPU @1.10GHz 1.61GHz）和 16 GB 内存的机器运行的。</p>
<p>所有的例子都在 Nushell 0.33.1 版本上运行。</p>
</blockquote>
<h3 id="文件信息" tabindex="-1"> 文件信息</h3>
<p>我们将用于性能测试的文件是 <a href="https://www.stats.govt.nz/assets/Uploads/New-Zealand-business-demography-statistics/New-Zealand-business-demography-statistics-At-February-2020/Download-data/Geographic-units-by-industry-and-statistical-area-2000-2020-descending-order-CSV.zip" target="_blank" rel="noopener noreferrer">新西兰商业人口统计</a> 数据集。
如果你想尝试这些测试，请下载该文件。</p>
<p>该数据集有 5 列，5,429,252 行。我们可以通过使用<code>dfr list</code>命令来检查：</p>
<div><pre><code><span>></span> <span>let</span> <span>df</span> <span>=</span> <span>(</span>dfr <span>open</span> .<span>\</span>Data7602DescendingYearOrder.csv<span>)</span>
<span>></span> dfr list

───┬──────┬─────────┬─────────
 <span># │ name │  rows   │ columns</span>
───┼──────┼─────────┼─────────
 <span>0</span> │ <span>$df</span>  │ <span>5429252</span> │ <span>5</span>
───┴──────┴─────────┴─────────
</code></pre></div><p>我们可以用<code>dfr first</code>看一下文件的第一行：</p>
<div><pre><code><span>></span> <span>$df</span> <span>|</span> dfr first

───┬──────────┬─────────┬──────┬───────────┬──────────
 <span># │ anzsic06 │  Area   │ year │ geo_count │ ec_count</span>
───┼──────────┼─────────┼──────┼───────────┼──────────
 <span>0</span> │ A        │ A100100 │ <span>2000</span> │        <span>96</span> │      <span>130</span>
 <span>1</span> │ A        │ A100200 │ <span>2000</span> │       <span>198</span> │      <span>110</span>
 <span>2</span> │ A        │ A100300 │ <span>2000</span> │        <span>42</span> │       <span>25</span>
 <span>3</span> │ A        │ A100400 │ <span>2000</span> │        <span>66</span> │       <span>40</span>
 <span>4</span> │ A        │ A100500 │ <span>2000</span> │        <span>63</span> │       <span>40</span>
───┴──────────┴─────────┴──────┴───────────┴──────────
</code></pre></div><p>...最后，我们可以了解一下推断出的数据类型：</p>
<div><pre><code><span>></span> <span>$df</span> <span>|</span> dfr dtypes

───┬───────────┬───────
 <span># │  column   │ dtype</span>
───┼───────────┼───────
 <span>0</span> │ anzsic06  │ str
 <span>1</span> │ Area      │ str
 <span>2</span> │ year      │ i64
 <span>3</span> │ geo_count │ i64
 <span>4</span> │ ec_count  │ i64
───┴───────────┴───────
</code></pre></div><h3 id="加载文件" tabindex="-1"> 加载文件</h3>
<p>让我们先来比较一下各种方法的加载时间。首先，我们将使用 Nushell 的<a href="/book/commands/open.html"><code>open</code></a>命令加载数据：</p>
<div><pre><code><span>></span> benchmark <span>{</span>open .<span>\</span>Data7602DescendingYearOrder.csv<span>}</span>

───┬─────────────────────────
 <span># │        real time</span>
───┼─────────────────────────
 <span>0</span> │ 30sec 479ms 614us 400ns
───┴─────────────────────────
</code></pre></div><p>使用原生的 Nushell 功能加载文件需要 30 秒。对于加载 500 万条记录来说，这还算不错！但我们可以做得更好一些。</p>
<p>现在让我们使用 Pandas。我们将使用以下脚本来加载文件：</p>
<div><pre><code><span>import</span> pandas <span>as</span> pd

df <span>=</span> pd<span>.</span>read_csv<span>(</span><span>"Data7602DescendingYearOrder.csv"</span><span>)</span>
</code></pre></div><p>而它的性能测试结果是：</p>
<div><pre><code><span>></span> benchmark <span>{</span>python load.py<span>}</span>

───┬───────────────────────
 <span># │       real time</span>
───┼───────────────────────
 <span>0</span> │ 2sec 91ms 872us 900ns
───┴───────────────────────
</code></pre></div><p>这是一个很大的进步，从 30 秒到 2 秒。干得好，Pandas!</p>
<p>也许我们加载数据可以再快一点，这一次我们将使用 Nushell 的<code>dfr open</code>命令：</p>
<div><pre><code><span>></span> benchmark <span>{</span>dfr <span>open</span> .<span>\</span>Data7602DescendingYearOrder.csv<span>}</span>

───┬───────────────────
 <span># │     real time</span>
───┼───────────────────
 <span>0</span> │ 601ms 700us 700ns
───┴───────────────────
</code></pre></div><p>这一次，我们花了 0.6 秒。一点也不差。</p>
<h3 id="group-by比较" tabindex="-1"> <code>Group-by</code>比较</h3>
<p>这次让我们做一个稍微复杂的操作。我们将按年份对数据进行分组，并根据<code>geo_count</code>列对分组求和。</p>
<p>同样，我们要从 Nushell 的原生命令开始：</p>
<div><p>TIP</p>
<p>如果你想运行这个例子，请注意接下来的命令将使用大量的内存，在该命令执行期间可能会影响你的系统性能。</p>
</div>
<div><pre><code><span>></span> benchmark <span>{</span>
	<span>open</span> .<span>\</span>Data7602DescendingYearOrder.csv
	<span>|</span> group-by year
	<span>|</span> pivot header rows
	<span>|</span> upsert rows <span>{</span> get rows <span>|</span> math <span>sum</span> <span>}</span>
	<span>|</span> flatten
<span>}</span>

───┬────────────────────────
 <span># │       real time</span>
───┼────────────────────────
 <span>0</span> │ 6min 30sec 622ms 312us
───┴────────────────────────
</code></pre></div><p>所以，执行这个聚合操作需要 6 分钟。</p>
<p>让我们试试在<code>pandas</code>中进行同样的操作：</p>
<div><pre><code><span>import</span> pandas <span>as</span> pd

df <span>=</span> pd<span>.</span>read_csv<span>(</span><span>"Data7602DescendingYearOrder.csv"</span><span>)</span>
res <span>=</span> df<span>.</span>groupby<span>(</span><span>"year"</span><span>)</span><span>[</span><span>"geo_count"</span><span>]</span><span>.</span><span>sum</span><span>(</span><span>)</span>
<span>print</span><span>(</span>res<span>)</span>
</code></pre></div><p>而性能测试的结果是：</p>
<div><pre><code><span>></span> benchmark <span>{</span>python .<span>\</span>load.py<span>}</span>

───┬────────────────────────
 <span># │       real time</span>
───┼────────────────────────
 <span>0</span> │ 1sec 966ms 954us 800ns
───┴────────────────────────
</code></pre></div><p>一点也不差！同样，Pandas 设法在很短的时间内完成了它。</p>
<p>为了进行比较，让我们试试 Nushell DataFrames。我们要把所有的操作放在一个<code>nu</code>文件中，以确保我们做的是类似的操作：</p>
<div><pre><code><span>let</span> <span>df</span> <span>=</span> <span>(</span>dfr <span>open</span> Data7602DescendingYearOrder.csv<span>)</span>
<span>let</span> res <span>=</span> <span>(</span><span>$df</span> <span>|</span> dfr group-by year <span>|</span> dfr aggregate <span>sum</span> <span>|</span> dfr <span>select</span> geo_count<span>)</span>
<span>$res</span>
</code></pre></div><p>当使用 DataFrames 时的性能测试结果是：</p>
<div><pre><code><span>></span> benchmark <span>{</span>source load.nu<span>}</span>

───┬───────────────────
 <span># │     real time</span>
───┼───────────────────
 <span>0</span> │ 557ms 658us 500ns
───┴───────────────────
</code></pre></div><p>幸运的是，Nushell DataFrame 设法将时间再次减半。这不是很好吗？</p>
<p>正如你所看到的，Nushell 的<code>DataFrame</code>命令和现在最常见的做数据分析的工具一样快。这个发行版中的命令有可能成为你做数据分析的首选工具。通过组合复杂的 Nushell 管道，你可以以一种可靠的方式从数据中提取信息。</p>
<h2 id="使用-dataframes" tabindex="-1"> 使用 DataFrames</h2>
<p>在看到了可以用<code>DataFrame</code>命令完成的事情之后，现在是时候开始测试它们了。首先，让我们创建一个样本 CSV 文件，该文件将成为我们的样本 DataFrame，并与示例一起使用。在你喜欢的编辑器中粘贴下面几行来创建样本 csv 文件：</p>
<div><pre><code><span>int_1</span><span>,</span><span>int_2</span><span>,</span><span>float_1</span><span>,</span><span>float_2</span><span>,</span><span>first</span><span>,</span><span>second</span><span>,</span><span>third</span><span>,</span><span>word</span>
<span>1</span><span>,</span><span>11</span><span>,</span><span>0.1</span><span>,</span><span>1.0</span><span>,</span><span>a</span><span>,</span><span>b</span><span>,</span><span>c</span><span>,</span><span>first</span>
<span>2</span><span>,</span><span>12</span><span>,</span><span>0.2</span><span>,</span><span>1.0</span><span>,</span><span>a</span><span>,</span><span>b</span><span>,</span><span>c</span><span>,</span><span>second</span>
<span>3</span><span>,</span><span>13</span><span>,</span><span>0.3</span><span>,</span><span>2.0</span><span>,</span><span>a</span><span>,</span><span>b</span><span>,</span><span>c</span><span>,</span><span>third</span>
<span>4</span><span>,</span><span>14</span><span>,</span><span>0.4</span><span>,</span><span>3.0</span><span>,</span><span>b</span><span>,</span><span>a</span><span>,</span><span>c</span><span>,</span><span>second</span>
<span>0</span><span>,</span><span>15</span><span>,</span><span>0.5</span><span>,</span><span>4.0</span><span>,</span><span>b</span><span>,</span><span>a</span><span>,</span><span>a</span><span>,</span><span>third</span>
<span>6</span><span>,</span><span>16</span><span>,</span><span>0.6</span><span>,</span><span>5.0</span><span>,</span><span>b</span><span>,</span><span>a</span><span>,</span><span>a</span><span>,</span><span>second</span>
<span>7</span><span>,</span><span>17</span><span>,</span><span>0.7</span><span>,</span><span>6.0</span><span>,</span><span>b</span><span>,</span><span>c</span><span>,</span><span>a</span><span>,</span><span>third</span>
<span>8</span><span>,</span><span>18</span><span>,</span><span>0.8</span><span>,</span><span>7.0</span><span>,</span><span>c</span><span>,</span><span>c</span><span>,</span><span>b</span><span>,</span><span>eight</span>
<span>9</span><span>,</span><span>19</span><span>,</span><span>0.9</span><span>,</span><span>8.0</span><span>,</span><span>c</span><span>,</span><span>c</span><span>,</span><span>b</span><span>,</span><span>ninth</span>
<span>0</span><span>,</span><span>10</span><span>,</span><span>0.0</span><span>,</span><span>9.0</span><span>,</span><span>c</span><span>,</span><span>c</span><span>,</span><span>b</span><span>,</span><span>ninth</span>
</code></pre></div><p>保存该文件并随意命名，在这些例子中，该文件将被称为<code>test_small.csv</code>。</p>
<p>现在，要将该文件作为 DataFrame 进行读取，请使用<code>dfr open</code>命令，如下所示：</p>
<div><pre><code><span>></span> <span>let</span> <span>df</span> <span>=</span> <span>(</span>dfr <span>open</span> test_small.csv<span>)</span>
</code></pre></div><p>这应该会在内存中创建一个值<code>df</code>，用来存放我们刚刚创建的数据。</p>
<div><p>TIP</p>
<p><code>dfrs open</code>命令可以读取 <strong>csv</strong> 或 <strong>parquet</strong> 文件。</p>
</div>
<p>要查看存储在内存中的所有 DataFrames，你可以使用：</p>
<div><pre><code><span>></span> dfr list

───┬──────┬──────┬─────────
 <span># │ name │ rows │ columns</span>
───┼──────┼──────┼─────────
 <span>0</span> │ <span>$df</span>  │ <span>10</span>   │ <span>8</span>
───┴──────┴──────┴─────────
</code></pre></div><p>正如你所看到的，该命令显示了所创建的 DataFrame 以及关于它们的基本信息。</p>
<p>如果你想看到加载的 DataFrame 的预览，你可以将 DataFrame 变量发送到流中：</p>
<div><pre><code><span>></span> <span>$df</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │  word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼────────
 <span>0</span> │     <span>1</span> │    <span>11</span> │  <span>0.1000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ first
 <span>1</span> │     <span>2</span> │    <span>12</span> │  <span>0.2000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ second
 <span>2</span> │     <span>3</span> │    <span>13</span> │  <span>0.3000</span> │  <span>2.0000</span> │ a     │ b      │ c     │ third
 <span>3</span> │     <span>4</span> │    <span>14</span> │  <span>0.4000</span> │  <span>3.0000</span> │ b     │ a      │ c     │ second
 <span>4</span> │     <span>0</span> │    <span>15</span> │  <span>0.5000</span> │  <span>4.0000</span> │ b     │ a      │ a     │ third
 <span>5</span> │     <span>6</span> │    <span>16</span> │  <span>0.6000</span> │  <span>5.0000</span> │ b     │ a      │ a     │ second
 <span>6</span> │     <span>7</span> │    <span>17</span> │  <span>0.7000</span> │  <span>6.0000</span> │ b     │ c      │ a     │ third
 <span>7</span> │     <span>8</span> │    <span>18</span> │  <span>0.8000</span> │  <span>7.0000</span> │ c     │ c      │ b     │ eight
 <span>8</span> │     <span>9</span> │    <span>19</span> │  <span>0.9000</span> │  <span>8.0000</span> │ c     │ c      │ b     │ ninth
 <span>9</span> │     <span>0</span> │    <span>10</span> │  <span>0.0000</span> │  <span>9.0000</span> │ c     │ c      │ b     │ ninth
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴────────
</code></pre></div><p>有了内存中的 DataFrame，我们就可以开始对 <code>DataFrame</code> 进行列操作。</p>
<div><p>TIP</p>
<p>如果你想看到所有可用的 DataFrame 命令，你可以使用<code>help dfr</code>。</p>
</div>
<h2 id="基本聚合" tabindex="-1"> 基本聚合</h2>
<p>让我们从 DataFrame 的基本聚合开始，通过使用<code>aggregate</code>命令对<code>df</code>中存在的所有列进行求和：</p>
<div><pre><code><span>></span> <span>$df</span> <span>|</span> dfr aggregate <span>sum</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬──────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │ word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼──────
 <span>0</span> │    <span>40</span> │   <span>145</span> │  <span>4.5000</span> │ <span>46.0000</span> │       │        │       │
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴──────
</code></pre></div><p>正如你所看到的，聚合函数(<code>aggregate</code>)为那些有意义的列计算出了总和。如果你想过滤掉文本列，你可以使用<code>select</code>命令来选择你想要的列。</p>
<div><pre><code><span>$df</span> <span>|</span> dfr aggregate <span>sum</span> <span>|</span> dfr <span>select</span> int_1 int_2 float_1 float_2

───┬───────┬───────┬─────────┬─────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2</span>
───┼───────┼───────┼─────────┼─────────
 <span>0</span> │    <span>40</span> │   <span>145</span> │  <span>4.5000</span> │ <span>46.0000</span>
───┴───────┴───────┴─────────┴─────────
</code></pre></div><p>你甚至可以像存储任何其他 Nushell 变量一样存储这个聚合的结果：</p>
<div><pre><code><span>></span> <span>let</span> res <span>=</span> <span>(</span><span>$df</span> <span>|</span> dfr aggregate <span>sum</span> <span>|</span> dfr <span>select</span> int_1 int_2 float_1 float_2<span>)</span>
</code></pre></div><p>现在我们有两个 DataFrame 存储在内存中：</p>
<div><pre><code><span>></span> dfr list

───┬──────┬──────┬─────────
 <span># │ name │ rows │ columns</span>
───┼──────┼──────┼─────────
 <span>0</span> │ <span>$df</span>  │ <span>10</span>   │ <span>8</span>
 <span>1</span> │ <span>$res</span> │ <span>1</span>    │ <span>4</span>
───┴──────┴──────┴─────────
</code></pre></div><p>很整洁，不是吗？</p>
<p>你可以在 DataFrame 上进行若干聚合，以便从中提取基本信息，也可以对你的全新 DataFrame 进行基本数据分析。</p>
<h2 id="连接-dataframe" tabindex="-1"> 连接 DataFrame</h2>
<p>也可以用一个列作为参考来连接(<code>join</code>)两个 DataFrame。我们将把我们的迷你 DataFrame 与另一个迷你 DataFrame 连接起来。在另一个文件中复制这些行，并创建相应的 DataFrame（在以下例子中，我们将称之为<code>test_small_a.csv</code>）。</p>
<div><pre><code>int_1a,int_2,float_1,float_2,first
9,14,0.4,3.0,a
8,13,0.3,2.0,a
7,12,0.2,1.0,a
6,11,0.1,0.0,b
</code></pre></div><p>我们使用<code>dfr open</code>命令来创建新的变量：</p>
<div><pre><code><span>></span> <span>let</span> df_a <span>=</span> <span>(</span>dfr <span>open</span> test_small_a.csv<span>)</span>
</code></pre></div><p>现在，当第二个 DataFrame 加载到内存中时，我们可以使用左边 DataFrame 的<code>int_1</code>列和右边 DataFrame 的<code>int_1a</code>列来连接它们。</p>
<div><pre><code><span>></span> <span>$df</span> <span>|</span> dfr <span>join</span> <span>$df_a</span> -l <span>[</span>int_1<span>]</span> -r <span>[</span>int_1a<span>]</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬─────────┬─────────────┬───────────────┬───────────────┬─────────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │  word   │ int_2_right │ float_1_right │ float_2_right │ first_right</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼─────────┼─────────────┼───────────────┼───────────────┼─────────────
 <span>0</span> │     <span>6</span> │    <span>16</span> │  <span>0.6000</span> │  <span>5.0000</span> │ b     │ a      │ a     │ second  │          <span>11</span> │        <span>0.1000</span> │        <span>0.0000</span> │ b
 <span>1</span> │     <span>7</span> │    <span>17</span> │  <span>0.7000</span> │  <span>6.0000</span> │ b     │ c      │ a     │ third   │          <span>12</span> │        <span>0.2000</span> │        <span>1.0000</span> │ a
 <span>2</span> │     <span>8</span> │    <span>18</span> │  <span>0.8000</span> │  <span>7.0000</span> │ c     │ c      │ b     │ eight   │          <span>13</span> │        <span>0.3000</span> │        <span>2.0000</span> │ a
 <span>3</span> │     <span>9</span> │    <span>19</span> │  <span>0.9000</span> │  <span>8.0000</span> │ c     │ c      │ b     │ ninth   │          <span>14</span> │        <span>0.4000</span> │        <span>3.0000</span> │ a
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴─────────┴─────────────┴───────────────┴───────────────┴─────────────
</code></pre></div><div><p>TIP</p>
<p>在<code>Nu</code>中，当一个命令有多个参数，并期望得到多个值时，我们用方括号<code>[]</code>来包裹这些值。在<code>dfr join</code>的情况下，我们可以对多个列进行连接，只要它们具有相同的类型，例如我们可以这样做：<code>$df | dfr join $df_a -l [int_1 int_2] -r [int_1a int_2]</code>。</p>
</div>
<p>默认情况下，连接命令做的是内连接，也就是说，它将保留两个 DataFrame 都有相同值的记录。你可以选择一个左联接来保留左边 DataFrame 中缺失的行。你也可以保存这个结果，以便在以后的操作中使用它。</p>
<h2 id="dataframe-分组" tabindex="-1"> DataFrame 分组</h2>
<p>可以用 DataFrame 进行的最强大的操作之一是<code>group-by</code>。这个命令将允许你根据一个分组条件进行聚合操作。在 Nushell 中，<code>GroupBy</code>是一种可以被存储和重复使用的对象，可以被用于多个聚合。这是很方便的，因为在进行分组时，创建分组对是最昂贵的运算，如果你打算用同一个分组条件进行多个操作，就没有必要重复该运算。</p>
<p>要创建一个<code>GroupBy</code>对象，你只需要使用<code>group-by</code>命令：</p>
<div><pre><code><span>></span> <span>let</span> group <span>=</span> <span>(</span><span>$df</span> <span>|</span> dfr group-by first<span>)</span>
<span>></span> <span>$group</span>

───┬──────────┬───────
 <span># │ property │ value</span>
───┼──────────┼───────
 <span>0</span> │ group by │ first
───┴──────────┴───────
</code></pre></div><p>当打印 <code>GroupBy</code> 对象时，我们可以看到被用作条件的列来对 DataFrame 进行分组。使用<code>GroupBy</code>，我们可以使用多种操作对 DataFrame 进行聚合。</p>
<div><pre><code><span>$group</span> <span>|</span> dfr aggregate <span>sum</span>

───┬───────┬───────────┬───────────┬─────────────┬─────────────
 <span># │ first │ int_1     │ int_2     │ float_1     │ float_2</span>
───┼───────┼───────────┼───────────┼─────────────┼─────────────
 <span>0</span> │ a     │         <span>6</span> │        <span>36</span> │      <span>0.6000</span> │      <span>4.0000</span>
 <span>1</span> │ b     │        <span>17</span> │        <span>62</span> │      <span>2.2000</span> │     <span>18.0000</span>
 <span>2</span> │ c     │        <span>17</span> │        <span>47</span> │      <span>1.7000</span> │     <span>24.0000</span>
───┴───────┴───────────┴───────────┴─────────────┴─────────────
</code></pre></div><p>使用同样的 <code>GroupBy</code>，你可以对整个 DataFrame 进行另一个操作，比如本例中的<code>min</code>：</p>
<div><pre><code><span>$group</span> <span>|</span> aggregate min

───┬───────┬───────────┬───────────┬─────────────┬─────────────
 <span># │ first │ int_1     │ int_2     │ float_1     │ float_2</span>
───┼───────┼───────────┼───────────┼─────────────┼─────────────
 <span>0</span> │ a     │         <span>1</span> │        <span>11</span> │      <span>0.1000</span> │      <span>1.0000</span>
 <span>1</span> │ b     │         <span>0</span> │        <span>14</span> │      <span>0.4000</span> │      <span>3.0000</span>
 <span>2</span> │ c     │         <span>0</span> │        <span>10</span> │      <span>0.0000</span> │      <span>7.0000</span>
───┴───────┴───────────┴───────────┴─────────────┴─────────────
</code></pre></div><p>创建的<code>GroupBy</code>对象非常方便，它甚至可以被用作表格透视的基础。作为一个例子，让我们使用名为<code>second</code>的列作为透视列，而<code>float_1</code>列作为值列：</p>
<div><pre><code><span>></span> <span>$group</span> <span>|</span> dfr pivot second float_1 <span>sum</span>

───┬───────┬────────┬────────┬────────
 <span># │ first │   b    │   a    │   c</span>
───┼───────┼────────┼────────┼────────
 <span>0</span> │ a     │ <span>0.6000</span> │        │
 <span>1</span> │ c     │        │        │ <span>1.7000</span>
 <span>2</span> │ b     │        │ <span>1.5000</span> │ <span>0.7000</span>
───┴───────┴────────┴────────┴────────
</code></pre></div><div><p>TIP</p>
<p>透视操作是一种基于两列数据进行聚合的方法。在前面的例子中，透视命令的结果产生了一个表格，代表了列<code>float_1</code>中所有数值的总和，这些数值在列<code>first</code>（现在是行）和<code>second</code>（现在是列）中共享。因此，显示在第<code>b</code>行和第<code>a</code>列的值<code>1.5</code>是所有浮点的总和，其中第<code>first</code>列是<code>b</code>，第<code>second</code>列是<code>a</code>。</p>
</div>
<p>正如你所看到的，<code>GroupBy</code>对象是一个非常强大的变量，在你操作数据集时，它值得被保留在内存中。</p>
<h2 id="创建-dataframes" tabindex="-1"> 创建 DataFrames</h2>
<p>也可以从基本的 Nushell 基础类型，如整数、小数或字符串，来构建 DataFrames。让我们使用<code>to-df</code>命令来创建一个小的 DataFrame：</p>
<div><pre><code><span>></span> <span>let</span> a <span>=</span> <span>(</span><span>[</span><span>[</span>a b<span>]</span><span>;</span> <span>[</span><span>1</span> <span>2</span><span>]</span> <span>[</span><span>3</span> <span>4</span><span>]</span> <span>[</span><span>5</span> <span>6</span><span>]</span><span>]</span> <span>|</span> dfr to-df<span>)</span>
<span>></span> <span>$a</span>

───┬───┬───
 <span># │ b │ a</span>
───┼───┼───
 <span>0</span> │ <span>2</span> │ <span>1</span>
 <span>1</span> │ <span>4</span> │ <span>3</span>
 <span>2</span> │ <span>6</span> │ <span>5</span>
───┴───┴───
</code></pre></div><div><p>TIP</p>
<p>目前，并不是所有的 Nushell 基本类型都可以转换为 DataFrame。随着 DataFrame 功能的成熟，这一点将在未来发生变化。</p>
</div>
<p>我们可以在一个 DataFrame 中添加列，以创建一个新的变量。作为一个例子，让我们在迷你 DataFrame <code>$a</code> 上添加两列：</p>
<div><pre><code><span>></span> <span>let</span> a2 <span>=</span> <span>(</span><span>$a</span> <span>|</span> dfr with-column <span>$a</span>.a --name a2 <span>|</span> dfr with-column <span>$a</span>.a --name a3<span>)</span>

───┬───┬───┬────┬────
 <span># │ b │ a │ a2 │ a3</span>
───┼───┼───┼────┼────
 <span>0</span> │ <span>2</span> │ <span>1</span> │  <span>1</span> │  <span>1</span>
 <span>1</span> │ <span>4</span> │ <span>3</span> │  <span>3</span> │  <span>3</span>
 <span>2</span> │ <span>6</span> │ <span>5</span> │  <span>5</span> │  <span>5</span>
───┴───┴───┴────┴────
</code></pre></div><p>Nushell 强大的管道语法允许我们通过从其他 DataFrame 中获取数据并将其附加到这些 DataFrame 中来创建新的 DataFrame。现在，如果你列出你的 DataFrame，你会看到总共有四个：</p>
<div><pre><code><span>></span> dfr list

───┬───────┬──────┬─────────
 <span># │  name │ rows │ columns</span>
───┼───────┼──────┼─────────
 <span>0</span> │ <span>$a</span>    │ <span>3</span>    │ <span>2</span>
 <span>1</span> │ <span>$a2</span>   │ <span>3</span>    │ <span>4</span>
 <span>2</span> │ <span>$df_a</span> │ <span>4</span>    │ <span>5</span>
 <span>3</span> │ <span>$df</span>   │ <span>10</span>   │ <span>8</span>
───┴───────┴──────┴─────────
</code></pre></div><p>值得一提的是，在使用 DataFrame 时，内存是如何被优化的呢？这要感谢 <strong>Apache Arrow</strong> 和 <strong>Polars</strong>。在一个非常简单的表示中，DataFrame 中的每一列都是一个 Arrow 数组，它使用了几种内存规格，以塞满尽可能多的数据（查看 <a href="https://arrow.apache.org/docs/format/Columnar.html" target="_blank" rel="noopener noreferrer">Arrow 列格式</a> ）；另一个优化技巧是，只要有可能，DataFrame 中的列就会在多个 DataFrame 之间共享，避免了相同数据的内存重复占用。这意味着 DataFrame <code>$a</code>和<code>$a2</code>共享我们用<code>to-df</code>命令创建的两个列。由于这个原因，不能改变 DataFrame 中某一列的值。然而，你可以根据其他列或 DataFrame 的数据创建新的列。</p>
<h2 id="使用系列" tabindex="-1"> 使用系列</h2>
<p>系列(<code>Series</code>) 是 <code>DataFrame</code> 的基本组成部分。每个系列代表一个具有相同数据类型的列，我们可以创建多个不同类型的系列，如浮点、整型或字符串。</p>
<p>让我们通过使用<code>to-df</code>命令创建一个系列，来开始我们对系列的探索：</p>
<div><pre><code><span>></span> <span>let</span> new <span>=</span> <span>(</span><span>[</span><span>9</span> <span>8</span> <span>4</span><span>]</span> <span>|</span> dfr to-df<span>)</span>
<span>></span> <span>$new</span>

───┬───
 <span># │ 0</span>
───┼───
 <span>0</span> │ <span>9</span>
 <span>1</span> │ <span>8</span>
 <span>2</span> │ <span>4</span>
───┴───
</code></pre></div><p>我们从一个整数列表创建了一个新的系列（我们也可以用浮点数或字符串做同样的事情）。</p>
<p>系列已经定义了自己的基本操作，它们可以用来创建其他系列。让我们通过对先前创建的列进行一些运算来创建一个新的系列：</p>
<div><pre><code><span>></span> <span>let</span> new_2 <span>=</span> <span>(</span><span>$new</span> * <span>3</span> + <span>10</span><span>)</span>
<span>></span> <span>$new_2</span>

───┬────
 <span># │ 0</span>
───┼────
 <span>0</span> │ <span>37</span>
 <span>1</span> │ <span>34</span>
 <span>2</span> │ <span>22</span>
───┴────
</code></pre></div><p>现在我们有一个新的系列，它是通过对前一个变量进行基本操作而构建的。</p>
<div><p>TIP</p>
<p>如果你想看看你在内存中存储了多少变量，你可以使用<code>$nu.scope.vars</code>。</p>
</div>
<p>让我们重新命名我们之前的系列为 <code>memorable</code></p>
<div><pre><code><span>></span> <span>let</span> new_2 <span>=</span> <span>(</span><span>$new_2</span> <span>|</span> dfr <span>rename</span> memorable<span>)</span>
<span>></span> <span>$new_2</span>

───┬───────────
 <span># │ memorable</span>
───┼───────────
 <span>0</span> │        <span>37</span>
 <span>1</span> │        <span>34</span>
 <span>2</span> │        <span>22</span>
───┴───────────
</code></pre></div><p>只要两个系列的数据类型相同，我们也可以对它们进行基本操作：</p>
<div><pre><code><span>></span> <span>$new</span> - <span>$new_2</span>

───┬──────────
 <span># │ sub_0_0</span>
───┼──────────
 <span>0</span> │     -28
 <span>1</span> │     -26
 <span>2</span> │     -18
───┴──────────
</code></pre></div><p>而且我们可以将它们添加到先前定义的 DataFrames 中：</p>
<div><pre><code><span>></span> <span>let</span> new_df <span>=</span> <span>(</span><span>$a</span> <span>|</span> dfr with-column <span>$new</span> --name new_col<span>)</span>
<span>></span> <span>$new_df</span>

───┬───┬───┬─────────
 <span># │ b │ a │ new_col</span>
───┼───┼───┼─────────
 <span>0</span> │ <span>2</span> │ <span>1</span> │       <span>9</span>
 <span>1</span> │ <span>4</span> │ <span>3</span> │       <span>8</span>
 <span>2</span> │ <span>6</span> │ <span>5</span> │       <span>4</span>
───┴───┴───┴─────────
</code></pre></div><p>存储在 DataFrame 中的系列也可以直接使用，例如，我们可以将列<code>a</code>和<code>b</code>相乘来创建一个新系列：</p>
<div><pre><code><span>></span> <span>$new_df</span>.a * <span>$new_df</span>.b

───┬─────────
 <span># │ mul_a_b</span>
───┼─────────
 <span>0</span> │       <span>2</span>
 <span>1</span> │      <span>12</span>
 <span>2</span> │      <span>30</span>
───┴─────────
</code></pre></div><p>我们可以开始使用管道，以创建新的列和 DataFrames：</p>
<div><pre><code><span>></span> <span>let</span> <span>$new_df</span> <span>=</span> <span>(</span><span>$new_df</span> <span>|</span> dfr with-column <span>(</span><span>$new_df</span>.a * <span>$new_df</span>.b / <span>$new_df</span>.new_col<span>)</span> --name my_sum<span>)</span>
<span>></span> <span>let</span> <span>$new_df</span>

───┬───┬───┬─────────┬────────
 <span># │ b │ a │ new_col │ my_sum</span>
───┼───┼───┼─────────┼────────
 <span>0</span> │ <span>2</span> │ <span>1</span> │       <span>9</span> │      <span>0</span>
 <span>1</span> │ <span>4</span> │ <span>3</span> │       <span>8</span> │      <span>1</span>
 <span>2</span> │ <span>6</span> │ <span>5</span> │       <span>4</span> │      <span>7</span>
───┴───┴───┴─────────┴────────
</code></pre></div><p>Nushell 的管道系统可以帮助你创建非常有趣的工作流程。</p>
<h2 id="系列和掩码" tabindex="-1"> 系列和掩码</h2>
<p>在使用 DataFrames 时，系列还有另一个关键用途，那就是我们可以用它们来建立布尔掩码（Mask）。让我们先用等于运算符创建一个简单的掩码：</p>
<div><pre><code><span>></span> <span>let</span> mask <span>=</span> <span>(</span><span>$new</span> <span>==</span> <span>8</span><span>)</span>
<span>></span> <span>$mask</span>

───┬─────────
 <span># │ new_col</span>
───┼─────────
 <span>0</span> │ <span>false</span>
 <span>1</span> │ <span>true</span>
 <span>2</span> │ <span>false</span>
───┴─────────
</code></pre></div><p>有了这个掩码，我们现在可以过滤一个 DataFrame，像这样：</p>
<div><pre><code><span>></span> <span>$new_df</span> <span>|</span> dfr filter-with <span>$mask</span>

───┬───┬───┬─────────┬────────
 <span># │ a │ b │ new_col │ my_sum</span>
───┼───┼───┼─────────┼────────
 <span>0</span> │ <span>3</span> │ <span>4</span> │       <span>8</span> │      <span>1</span>
───┴───┴───┴─────────┴────────
</code></pre></div><p>现在我们有一个新的 DataFrame，其中只有掩码为真的值。</p>
<p>掩码也可以从 Nushell 列表中创建，比如：</p>
<div><pre><code><span>></span> <span>let</span> mask1 <span>=</span> <span>(</span><span>[</span>true <span>true</span> false<span>]</span> <span>|</span> dfr to-df mask<span>)</span>
<span>></span> <span>$new_df</span> <span>|</span> dfr filter-with <span>$mask1</span>

───┬───┬───┬─────────┬────────
 <span># │ a │ b │ new_col │ my_sum</span>
───┼───┼───┼─────────┼────────
 <span>0</span> │ <span>1</span> │ <span>2</span> │       <span>9</span> │      <span>0</span>
 <span>1</span> │ <span>3</span> │ <span>4</span> │       <span>8</span> │      <span>1</span>
───┴───┴───┴─────────┴────────
</code></pre></div><p>为了创建复杂的掩码，我们可以使用<code>AND</code>：</p>
<div><pre><code><span>></span> <span>$mask</span> <span>&amp;&amp;</span> <span>$mask1</span>

───┬──────────────────
 <span># │ and_new_col_mask</span>
───┼──────────────────
 <span>0</span> │ <span>false</span>
 <span>1</span> │ <span>true</span>
 <span>2</span> │ <span>false</span>
───┴──────────────────
</code></pre></div><p>或者 <code>OR</code> 操作：</p>
<div><pre><code><span>></span> <span>$mask</span> <span>||</span> <span>$mask1</span>

───┬─────────────────
 <span># │ or_new_col_mask</span>
───┼─────────────────
 <span>0</span> │ <span>true</span>
 <span>1</span> │ <span>true</span>
 <span>2</span> │ <span>false</span>
───┴─────────────────
</code></pre></div><p>我们也可以通过检查某些值是否存在于其他系列来创建一个掩码。使用我们创建的第一个 DataFrame，我们可以这样做：</p>
<div><pre><code><span>></span> <span>let</span> mask3 <span>=</span> <span>(</span><span>$df</span>.first <span>|</span> dfr is-in <span>(</span><span>[</span>b c<span>]</span> <span>|</span> dfr to-df<span>))</span>

───┬──────
 <span># │ first</span>
───┼───────
 <span>0</span> │ <span>false</span>
 <span>1</span> │ <span>false</span>
 <span>2</span> │ <span>false</span>
 <span>3</span> │ <span>true</span>
 <span>4</span> │ <span>true</span>
 <span>5</span> │ <span>true</span>
 <span>6</span> │ <span>true</span>
 <span>7</span> │ <span>true</span>
 <span>8</span> │ <span>true</span>
 <span>9</span> │ <span>true</span>
───┴───────
</code></pre></div><p>而这个新的掩码可以用来过滤 DataFrame</p>
<div><pre><code><span>></span> <span>$df</span> <span>|</span> dfr filter-with <span>$mask3</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬─────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │  word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼─────────
 <span>0</span> │     <span>4</span> │    <span>14</span> │  <span>0.4000</span> │  <span>3.0000</span> │ b     │ a      │ c     │ second
 <span>1</span> │     <span>0</span> │    <span>15</span> │  <span>0.5000</span> │  <span>4.0000</span> │ b     │ a      │ a     │ third
 <span>2</span> │     <span>6</span> │    <span>16</span> │  <span>0.6000</span> │  <span>5.0000</span> │ b     │ a      │ a     │ second
 <span>3</span> │     <span>7</span> │    <span>17</span> │  <span>0.7000</span> │  <span>6.0000</span> │ b     │ c      │ a     │ third
 <span>4</span> │     <span>8</span> │    <span>18</span> │  <span>0.8000</span> │  <span>7.0000</span> │ c     │ c      │ b     │ eight
 <span>5</span> │     <span>9</span> │    <span>19</span> │  <span>0.9000</span> │  <span>8.0000</span> │ c     │ c      │ b     │ ninth
 <span>6</span> │     <span>0</span> │    <span>10</span> │  <span>0.0000</span> │  <span>9.0000</span> │ c     │ c      │ b     │ ninth
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴─────────
</code></pre></div><p>另一个可以用掩码进行的操作是设置或替换一个系列的值。例如，我们可以改变列<code>first</code>中的值，如果该值包含<code>a</code>：</p>
<div><pre><code><span>></span> <span>$df</span>.first <span>|</span> dfr <span>set</span> new --mask <span>(</span><span>$df</span>.first <span>=~</span> a<span>)</span>

───┬────────
 <span># │ string</span>
───┼────────
 <span>0</span> │ new
 <span>1</span> │ new
 <span>2</span> │ new
 <span>3</span> │ b
 <span>4</span> │ b
 <span>5</span> │ b
 <span>6</span> │ b
 <span>7</span> │ c
 <span>8</span> │ c
 <span>9</span> │ c
───┴────────
</code></pre></div><h2 id="系列作为索引" tabindex="-1"> 系列作为索引</h2>
<p>系列也可以作为过滤 DataFrame 的一种方式，将它们作为索引列表使用。例如，假设我们想从原始 DataFrame 中获取第1、4和6行。针对这一点，我们可以使用以下命令来提取这些信息：</p>
<div><pre><code><span>></span> <span>let</span> indices <span>=</span> <span>(</span><span>[</span><span>1</span> <span>4</span> <span>6</span><span>]</span> <span>|</span> dfr to-df<span>)</span>
<span>></span> <span>$df</span> <span>|</span> dfr take <span>$indices</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │  word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼────────
 <span>0</span> │     <span>2</span> │    <span>12</span> │  <span>0.2000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ second
 <span>1</span> │     <span>0</span> │    <span>15</span> │  <span>0.5000</span> │  <span>4.0000</span> │ b     │ a      │ a     │ third
 <span>2</span> │     <span>7</span> │    <span>17</span> │  <span>0.7000</span> │  <span>6.0000</span> │ b     │ c      │ a     │ third
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴────────
</code></pre></div><p>命令<code>take</code>非常方便，特别是当我们把它与其他命令混合使用时。
比方说，我们想提取列<code>first</code>的唯一元素的所有行。为了做到这一点，我们可以使用<code>dfr arg-unique</code>命令，如下例所示：</p>
<div><pre><code><span>></span> <span>let</span> indices <span>=</span> <span>(</span><span>$df</span>.first <span>|</span> dfr arg-unique<span>)</span>
<span>></span> <span>$df</span> <span>|</span> dfr take <span>$indices</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │  word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼────────
 <span>0</span> │     <span>1</span> │    <span>11</span> │  <span>0.1000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ first
 <span>1</span> │     <span>4</span> │    <span>14</span> │  <span>0.4000</span> │  <span>3.0000</span> │ b     │ a      │ c     │ second
 <span>2</span> │     <span>8</span> │    <span>18</span> │  <span>0.8000</span> │  <span>7.0000</span> │ c     │ c      │ b     │ eight
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴────────
</code></pre></div><p>或者，如果我们想使用一个特定的列来创建一个新的有序 DataFrame，该怎么办？我们可以使用<code>dfr arg-sort</code>来完成这个任务。在下一个例子中，我们可以通过<code>word</code>列对 DataFrame 进行排序：</p>
<div><p>TIP</p>
<p>同样的结果也可以用<code>sort</code>命令来完成。</p>
</div>
<div><pre><code><span>></span> <span>let</span> indices <span>=</span> <span>(</span><span>$df</span>.word <span>|</span> dfr arg-sort<span>)</span>
<span>></span> <span>$df</span> <span>|</span> dfr take <span>$indices</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │  word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼────────
 <span>0</span> │     <span>8</span> │    <span>18</span> │  <span>0.8000</span> │  <span>7.0000</span> │ c     │ c      │ b     │ eight
 <span>1</span> │     <span>1</span> │    <span>11</span> │  <span>0.1000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ first
 <span>2</span> │     <span>9</span> │    <span>19</span> │  <span>0.9000</span> │  <span>8.0000</span> │ c     │ c      │ b     │ ninth
 <span>3</span> │     <span>0</span> │    <span>10</span> │  <span>0.0000</span> │  <span>9.0000</span> │ c     │ c      │ b     │ ninth
 <span>4</span> │     <span>2</span> │    <span>12</span> │  <span>0.2000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ second
 <span>5</span> │     <span>4</span> │    <span>14</span> │  <span>0.4000</span> │  <span>3.0000</span> │ b     │ a      │ c     │ second
 <span>6</span> │     <span>6</span> │    <span>16</span> │  <span>0.6000</span> │  <span>5.0000</span> │ b     │ a      │ a     │ second
 <span>7</span> │     <span>3</span> │    <span>13</span> │  <span>0.3000</span> │  <span>2.0000</span> │ a     │ b      │ c     │ third
 <span>8</span> │     <span>0</span> │    <span>15</span> │  <span>0.5000</span> │  <span>4.0000</span> │ b     │ a      │ a     │ third
 <span>9</span> │     <span>7</span> │    <span>17</span> │  <span>0.7000</span> │  <span>6.0000</span> │ b     │ c      │ a     │ third
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴────────
</code></pre></div><p>最后，我们可以通过在标记的索引中设置一个新值来创建新的系列。请看下一条命令：</p>
<div><pre><code><span>></span> <span>let</span> indices <span>=</span> <span>(</span><span>[</span><span>0</span> <span>2</span><span>]</span> <span>|</span> dfr to-df<span>)</span><span>;</span>
<span>></span> <span>$df</span>.int_1 <span>|</span> dfr set-with-idx <span>123</span> --indices <span>$indices</span>

───┬───────
 <span># │ int_1</span>
───┼───────
 <span>0</span> │   <span>123</span>
 <span>1</span> │     <span>2</span>
 <span>2</span> │   <span>123</span>
 <span>3</span> │     <span>4</span>
 <span>4</span> │     <span>0</span>
 <span>5</span> │     <span>6</span>
 <span>6</span> │     <span>7</span>
 <span>7</span> │     <span>8</span>
 <span>8</span> │     <span>9</span>
 <span>9</span> │     <span>0</span>
───┴───────
</code></pre></div><h2 id="唯一值" tabindex="-1"> 唯一值</h2>
<p>另一个可以用<code>Series</code>完成的操作是在一个列表或列中搜索唯一值。让我们再次使用我们创建的第一个 DataFrame 来测试这些操作。</p>
<p>第一个也是最常见的操作是<code>value_counts</code>。这个命令计算出一个系列中存在的唯一值的数量。例如，我们可以用它来计算 <code>first</code> 列各值的出现次数：</p>
<div><pre><code><span>></span> <span>$df</span>.first <span>|</span> dfr value-counts

───┬───────┬────────
 <span># │ first │ counts</span>
───┼───────┼────────
 <span>0</span> │ b     │      <span>4</span>
 <span>1</span> │ c     │      <span>3</span>
 <span>2</span> │ a     │      <span>3</span>
───┴───────┴────────
</code></pre></div><p>正如预期的那样，该命令返回一个新的 DataFrame，可以用来做更多的查询。</p>
<p>继续我们对 <code>Series</code> 的探索，我们要做的下一件事是只从一个系列中获得唯一值，像这样：</p>
<div><pre><code><span>></span> <span>$df</span>.first <span>|</span> dfr unique

───┬───────
 <span># │ first</span>
───┼───────
 <span>0</span> │ c
 <span>1</span> │ b
 <span>2</span> │ a
───┴───────
</code></pre></div><p>或者我们可以得到一个掩码，用来过滤出数据唯一或重复的行。例如，我们可以选择列 <code>word</code> 中含唯一值的行：</p>
<div><pre><code><span>></span> <span>$df</span> <span>|</span> dfr filter-with <span>(</span><span>$df</span>.word <span>|</span> dfr is-unique<span>)</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬───────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │ word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼───────
 <span>0</span> │     <span>1</span> │    <span>11</span> │  <span>0.1000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ first
 <span>1</span> │     <span>8</span> │    <span>18</span> │  <span>0.8000</span> │  <span>7.0000</span> │ c     │ c      │ b     │ eight
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴───────
</code></pre></div><p>或所有含重复值的行：</p>
<div><pre><code><span>></span> <span>$df</span> <span>|</span> dfr filter-with <span>(</span><span>$df</span>.word <span>|</span> dfr is-duplicated<span>)</span>

───┬───────┬───────┬─────────┬─────────┬───────┬────────┬───────┬────────
 <span># │ int_1 │ int_2 │ float_1 │ float_2 │ first │ second │ third │  word</span>
───┼───────┼───────┼─────────┼─────────┼───────┼────────┼───────┼────────
 <span>0</span> │     <span>2</span> │    <span>12</span> │  <span>0.2000</span> │  <span>1.0000</span> │ a     │ b      │ c     │ second
 <span>1</span> │     <span>3</span> │    <span>13</span> │  <span>0.3000</span> │  <span>2.0000</span> │ a     │ b      │ c     │ third
 <span>2</span> │     <span>4</span> │    <span>14</span> │  <span>0.4000</span> │  <span>3.0000</span> │ b     │ a      │ c     │ second
 <span>3</span> │     <span>0</span> │    <span>15</span> │  <span>0.5000</span> │  <span>4.0000</span> │ b     │ a      │ a     │ third
 <span>4</span> │     <span>6</span> │    <span>16</span> │  <span>0.6000</span> │  <span>5.0000</span> │ b     │ a      │ a     │ second
 <span>5</span> │     <span>7</span> │    <span>17</span> │  <span>0.7000</span> │  <span>6.0000</span> │ b     │ c      │ a     │ third
 <span>6</span> │     <span>9</span> │    <span>19</span> │  <span>0.9000</span> │  <span>8.0000</span> │ c     │ c      │ b     │ ninth
 <span>7</span> │     <span>0</span> │    <span>10</span> │  <span>0.0000</span> │  <span>9.0000</span> │ c     │ c      │ b     │ ninth
───┴───────┴───────┴─────────┴─────────┴───────┴────────┴───────┴────────
</code></pre></div><h2 id="dataframe-命令" tabindex="-1"> Dataframe 命令</h2>
<p>到目前为止，我们已经看到了很多可以使用 <code>DataFrame</code> 相关命令的操作。然而，到目前为止，我们所使用的命令并不包括所有可用来处理数据的命令，请放心，随着该功能的稳定，还会有更多的命令。</p>
<p>下表列出了可用的<code>DataFrame</code>命令及其描述，并尽可能显示其类似的 Nushell 命令。</p>
<table>
<thead>
<tr>
<th>命令名</th>
<th>应用于</th>
<th>描述</th>
<th>Nushell 类似命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>aggregate</td>
<td>DataFrame, GroupBy, Series</td>
<td>在一个 DataFrame、GroupBy 或系列对象上执行聚合操作</td>
<td>math</td>
</tr>
<tr>
<td>all-false</td>
<td>Series</td>
<td>如果所有的值都是假的，则返回真</td>
<td></td>
</tr>
<tr>
<td>all-true</td>
<td>Series</td>
<td>如果所有的值都是真的，则返回真</td>
<td>all?</td>
</tr>
<tr>
<td>arg-max</td>
<td>Series</td>
<td>返回系列中最大值的索引</td>
<td></td>
</tr>
<tr>
<td>arg-min</td>
<td>Series</td>
<td>返回系列中最小值的索引</td>
<td></td>
</tr>
<tr>
<td>arg-sort</td>
<td>Series</td>
<td>返回排序后的系列的索引</td>
<td></td>
</tr>
<tr>
<td>arg-true</td>
<td>Series</td>
<td>返回值为真的索引</td>
<td></td>
</tr>
<tr>
<td>arg-unique</td>
<td>Series</td>
<td>返回唯一值的索引</td>
<td></td>
</tr>
<tr>
<td>column</td>
<td>DataFrame</td>
<td>将选定的列作为系列返回</td>
<td>get</td>
</tr>
<tr>
<td>count-null</td>
<td>Series</td>
<td>计算空值</td>
<td></td>
</tr>
<tr>
<td>count-unique</td>
<td>Series</td>
<td>计算唯一值</td>
<td></td>
</tr>
<tr>
<td>drop</td>
<td>DataFrame</td>
<td>通过删除选定的列来创建一个新的 DataFrame</td>
<td>drop</td>
</tr>
<tr>
<td>drop-duplicates</td>
<td>DataFrame</td>
<td>删除 DataFrame 中的重复值</td>
<td></td>
</tr>
<tr>
<td>drop-nulls</td>
<td>DataFrame, Series</td>
<td>丢弃 DataFrame 中的空值</td>
<td></td>
</tr>
<tr>
<td>dtypes</td>
<td>DataFrame</td>
<td>显示 DataFrame 的数据类型</td>
<td></td>
</tr>
<tr>
<td>filter-with</td>
<td>DataFrame</td>
<td>使用 Mask 作为参考来过滤 DataFrame</td>
<td></td>
</tr>
<tr>
<td>first</td>
<td>DataFrame</td>
<td>用第一行创建新的 DataFrame</td>
<td>first</td>
</tr>
<tr>
<td>get</td>
<td>DataFrame</td>
<td>用选定的列创建 DataFrame</td>
<td>get</td>
</tr>
<tr>
<td>group-by</td>
<td>DataFrame</td>
<td>创建一个 GroupBy 对象，可用于其他聚合</td>
<td>group-by</td>
</tr>
<tr>
<td>is-duplicated</td>
<td>Series</td>
<td>创建表示重复值的 Mask</td>
<td></td>
</tr>
<tr>
<td>is-in</td>
<td>Series</td>
<td>检查一个系列的元素是否包含在右边的系列中</td>
<td>in</td>
</tr>
<tr>
<td>is-not-null</td>
<td>Series</td>
<td>创建值为非空的 Mask</td>
<td></td>
</tr>
<tr>
<td>is-null</td>
<td>Series</td>
<td>创建值为空的 Mask</td>
<td><code>&lt;column_name&gt; == $nothing</code></td>
</tr>
<tr>
<td>is-unique</td>
<td>Series</td>
<td>创建表示唯一值的 Mask</td>
<td></td>
</tr>
<tr>
<td>join</td>
<td>DataFrame</td>
<td>使用列作为参考来连接一个 DataFrame</td>
<td></td>
</tr>
<tr>
<td>last</td>
<td>DataFrame</td>
<td>用最后几行创建新的 DataFrame</td>
<td>last</td>
</tr>
<tr>
<td>list</td>
<td></td>
<td>列出已存储的 DataFrame</td>
<td></td>
</tr>
<tr>
<td>melt</td>
<td>DataFrame</td>
<td>将一个 DataFrame 从宽格式转为长格式</td>
<td></td>
</tr>
<tr>
<td>not</td>
<td>Series Inverts boolean mask</td>
<td></td>
<td></td>
</tr>
<tr>
<td>open</td>
<td></td>
<td>从 csv 文件中加载 DataFrame</td>
<td>open</td>
</tr>
<tr>
<td>pivot</td>
<td>GroupBy</td>
<td>在 GroupBy 对象上执行透视操作</td>
<td>pivot</td>
</tr>
<tr>
<td>rename</td>
<td>Series</td>
<td>重命名一个系列</td>
<td>rename</td>
</tr>
<tr>
<td>sample</td>
<td>DataFrame</td>
<td>创建样本 DataFrame</td>
<td></td>
</tr>
<tr>
<td>select</td>
<td>DataFrame</td>
<td>用选定的列创建一个新的 DataFrame</td>
<td>select</td>
</tr>
<tr>
<td>set</td>
<td>Series</td>
<td>在给定的 Mask 为真时设置值</td>
<td></td>
</tr>
<tr>
<td>set-with-idx</td>
<td>Series</td>
<td>设置给定索引中的值</td>
<td></td>
</tr>
<tr>
<td>shift</td>
<td>Series</td>
<td>将值移到一个给定的时段</td>
<td></td>
</tr>
<tr>
<td>show</td>
<td>DataFrame</td>
<td>将 DataFrame 的一个部分转换为一个表或列表值</td>
<td></td>
</tr>
<tr>
<td>slice</td>
<td>DataFrame</td>
<td>从行的切片中创建新的 DataFrame</td>
<td></td>
</tr>
<tr>
<td>sort</td>
<td>DataFrame, Series</td>
<td>创建新的排序 DataFrame 或系列</td>
<td>sort</td>
</tr>
<tr>
<td>take</td>
<td>DataFrame, Series</td>
<td>使用给定的索引创建新的 DataFrame</td>
<td></td>
</tr>
<tr>
<td>to-csv</td>
<td>DataFrame</td>
<td>将 DataFrame 保存为 csv 文件</td>
<td>to csv</td>
</tr>
<tr>
<td>to-df</td>
<td></td>
<td>将一个管道里的表或列表转换为 DataFrame</td>
<td></td>
</tr>
<tr>
<td>to-dummies</td>
<td>DataFrame</td>
<td>创建一个带有假值的新 DataFrame</td>
<td></td>
</tr>
<tr>
<td>to-parquet</td>
<td>DataFrame</td>
<td>将 DataFrame 保存到 parquet 文件中</td>
<td></td>
</tr>
<tr>
<td>unique</td>
<td>Series</td>
<td>返回一个系列中的唯一值</td>
<td>uniq</td>
</tr>
<tr>
<td>value-counts</td>
<td>Series</td>
<td>返回一个带有系列中唯一值的计数的 DataFrame</td>
<td></td>
</tr>
<tr>
<td>where</td>
<td>DataFrame</td>
<td>过滤 DataFrame 以符合条件</td>
<td>where</td>
</tr>
<tr>
<td>with-column</td>
<td>DataFrame</td>
<td>在 DataFrame 中添加一个系列</td>
<td><code>insert &lt;column_name&gt; &lt;value&gt; | upsert &lt;column_name&gt; { &lt;new_value&gt; }</code></td>
</tr>
</tbody>
</table>
<h2 id="dataframes-的未来" tabindex="-1"> DataFrames 的未来</h2>
<p>我们希望在本页结束时，你已经牢固掌握了如何使用 DataFrame 相关命令。正如你所看到的，它们提供了强大的操作，可以帮助你更快更原生地处理数据。</p>
<p>然而，DataFrames 的未来仍然是非常实验性的，随着这些命令的成熟，新的命令和利用这些命令的工具将被加入。例如，DataFrames 的下一步是引入惰性 DataFrames，这将允许你定义复杂的数据操作，这些操作将在你决定 &quot;<strong>完成</strong>&quot; 这个管道时才被执行。这将使 Nushell 有机会选择最佳计划来查询你所要求的数据。</p>
<p>请继续访问本书，以查看 DataFrames 的最新情况，以及它们如何帮助你更快更有效地处理数据。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">环境</title>
    <id>www.nushell.sh/zh-CN/book/environment.html</id>
    <link href="www.nushell.sh/zh-CN/book/environment.html"/>
    <updated>2022-06-04T13:17:54.509Z</updated>
    <content type="html"><![CDATA[<h1 id="环境" tabindex="-1"> 环境</h1>
<p>Shell 中的一个常见任务是控制外部应用程序将使用的环境变量。这通常是自动完成的，因为环境被打包，并在外部应用程序启动时提供给它。但有时，我们希望更精确地控制一个应用程序看到的环境变量。</p>
<p>你可以使用<a href="/book/commands/env.html"><code>env</code></a>命令查看当前环境变量：</p>
<div><pre><code>   #           name                 type                value                 raw
──────────────────────────────────────────────────────────────────────────────────────────
  16   DISPLAY              string               :0                   :0
  17   EDITOR               string               nvim                 nvim
  28   LANG                 string               en_US.UTF-8          en_US.UTF-8
  35   PATH                 list&lt;unknown>        [list 16 items]      /path1:/path2:/...
  36   PROMPT_COMMAND       block                &lt;Block 197>
</code></pre></div><p>在 Nushell 中，环境变量可以是任何值，并且有任何类型（见<code>type</code>列）。
Nushell 中使用的环境变量的实际值在<code>value</code>列下。
你可以直接使用<code>$env</code>变量查询该值，例如，<code>$env.PATH | length</code>。
最后的<code>raw</code>列显示了将被发送到外部应用程序的实际值（详见 <a href="/zh-CN/book/environment.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%BD%AC%E6%8D%A2">环境变量转换</a> ）。</p>
<p>环境最初是由 Nu 的 <a href="/zh-CN/book/configuration.html">配置文件</a> 和 Nu 的运行环境创建的。</p>
<h2 id="设置环境变量" tabindex="-1"> 设置环境变量</h2>
<p>有几种方法可以设置环境变量：</p>
<h3 id="let-env" tabindex="-1"> <a href="/book/commands/let-env.html"><code>let-env</code></a></h3>
<p>使用<code>let-env</code>命令是最直接的方法：</p>
<div><pre><code><span>></span> let-env FOO <span>=</span> <span>'BAR'</span>
</code></pre></div><p><code>let-env</code> 类似于 bash 中的 <strong>export</strong> 命令。</p>
<p>因此，如果你想扩展<code>PATH</code>变量，你可以这样做：</p>
<div><pre><code>let-env <span>PATH</span> <span>=</span> <span>(</span><span>$env</span><span>.</span><span>PATH</span> <span>|</span> prepend <span>'/path/you/want/to/add'</span><span>)</span>
</code></pre></div><p>在这里，我们把指定文件夹前置添加到<code>PATH</code>中的现有路径中，所以它将有最高的优先级。
如果你想给它最低的优先级，你可以使用<code>append</code>命令。</p>
<h3 id="load-env" tabindex="-1"> <a href="/book/commands/load-env.html"><code>load-env</code></a></h3>
<p>如果你有一个以上的环境变量需要设置，你可以使用<code>load-env</code>并创建一个键/值对记录(Record)，以用于加载多个环境变量：</p>
<div><pre><code><span>></span> load-env <span>{</span> <span>"BOB"</span><span>:</span> <span>"FOO"</span>, <span>"JAY"</span><span>:</span> <span>"BAR"</span> <span>}</span>
</code></pre></div><h3 id="一次性环境变量" tabindex="-1"> 一次性环境变量</h3>
<p>这些变量被定义为只在执行代码块的过程中临时有效。
详情请看 <a href="/zh-CN/book/environment.html#%E4%B8%80%E6%AC%A1%E6%80%A7%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">一次性环境变量</a> 。</p>
<h3 id="调用def-env定义的命令" tabindex="-1"> 调用<a href="/book/commands/def-env.html"><code>def-env</code></a>定义的命令</h3>
<p>详情见 <a href="/zh-CN/book/environment.html#%E4%BB%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">从自定义命令中定义环境</a>。</p>
<h3 id="使用模块导出" tabindex="-1"> 使用模块导出</h3>
<p>参见 <a href="/zh-CN/book/modules.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">模块</a> 部分了解更多详情。</p>
<h2 id="作用域" tabindex="-1"> 作用域</h2>
<p>当你设置环境变量时，它将只在当前作用域内可用（变量所在的块和它里面的任何块）。</p>
<p>这里有一个小例子来演示环境变量作用域：</p>
<div><pre><code><span>></span> let-env FOO <span>=</span> <span>"BAR"</span>
<span>></span> <span>do</span> <span>{</span>
    let-env FOO <span>=</span> <span>"BAZ"</span>
    <span>$env</span>.FOO <span>==</span> <span>"BAZ"</span>
<span>}</span>
<span>true</span>
<span>></span> <span>$env</span>.FOO <span>==</span> <span>"BAR"</span>
<span>true</span>
</code></pre></div><h2 id="目录切换" tabindex="-1"> 目录切换</h2>
<p>Shell 中常见的任务是用<a href="/book/commands/cd.html"><code>cd</code></a>命令来改变目录。
在 Nushell 中，调用<code>cd</code>等同于设置<code>PWD</code>环境变量。
因此，它遵循与其他环境变量相同的规则（例如，作用域）。</p>
<h2 id="一次性环境变量-1" tabindex="-1"> 一次性环境变量</h2>
<p>在 Bash 和其他软件的启发下，有一个常用的简便方法，可以设置一次性环境变量：</p>
<div><pre><code><span>></span> <span>FOO</span><span>=</span>BAR <span>echo</span> <span>$env</span>.FOO
BAR
</code></pre></div><p>你也可以使用<a href="/book/commands/with-env.html"><code>with-env</code></a>来更明确地做同样的事情：</p>
<div><pre><code><span>></span> with-env <span>{</span> FOO: BAR <span>}</span> <span>{</span> <span>echo</span> <span>$env</span>.FOO <span>}</span>
BAR
</code></pre></div><p><a href="/book/commands/with-env.html"><code>with-env</code></a>命令将暂时把环境变量设置为给定的值（这里：变量 &quot;FOO&quot; 被赋为 &quot;BAR&quot; 值）。一旦这样做了，<a href="/zh-CN/book/types_of_data.html#%E5%9D%97">块</a> 将在这个新的环境变量设置下运行。</p>
<h2 id="永久性环境变量" tabindex="-1"> 永久性环境变量</h2>
<p>你也可以在启动时设置环境变量，使它们在 Nushell 运行期间都可用。
要做到这一点，请在 <a href="/zh-CN/book/configuration.html">Nu 配置文件</a> 中设置一个环境变量。
比如：</p>
<div><pre><code><span># In config.nu</span>
let-env FOO <span>=</span> <span>'BAR'</span>
</code></pre></div><h2 id="从自定义命令中定义环境变量" tabindex="-1"> 从自定义命令中定义环境变量</h2>
<p>由于作用域规则，在自定义命令中定义的任何环境变量都只存在于该命令的作用域内。
然而，用<a href="/book/commands/def-env.html"><code>def-env</code></a>而不是<a href="/book/commands/def.html"><code>def</code></a>定义的命令（它也适用于<code>export def</code>，见 <a href="/zh-CN/book/modules.html">模块</a>）将在调用者一方保留环境设置：</p>
<div><pre><code><span>></span> def-env foo <span>[</span><span>]</span> <span>{</span>
    let-env FOO <span>=</span> <span>'BAR'</span>
<span>}</span>

<span>></span> foo

<span>></span> <span>$env</span>.FOO
BAR
</code></pre></div><h2 id="环境变量转换" tabindex="-1"> 环境变量转换</h2>
<p>你可以通过设置<code>ENV_CONVERSIONS</code>环境变量，来在字符串和值之间转换其他环境变量。
例如，<a href="https://github.com/nushell/nushell/blob/main/docs/sample_config/default_env.nu" target="_blank" rel="noopener noreferrer">默认环境配置</a>包括将<code>PATH</code>（和 Windows 上使用的<code>Path</code>）环境变量从一个字符串转换为一个列表。
在 <code>env.nu</code> 和 <code>config.nu</code> 配置文件加载后，任何在<code>ENV_CONVERSIONS</code>内指定的现有环境变量将根据其<code>from_string</code>字段被转换为任何类型的值。
外部工具要求环境变量是字符串，因此，任何非字符串的环境变量需要先进行转换：
值-&gt;字符串的转换由<code>ENV_CONVERSIONS</code>的<code>to_string</code>字段设置，每次运行外部命令时都会进行转换。</p>
<p>让我们用一个例子来说明转换的情况。
把以下内容放在你的<code>config.nu</code>中：</p>
<div><pre><code>let-env ENV_CONVERSIONS <span>=</span> <span>{</span>
    <span># ... you might have Path and PATH already there, add:</span>
    FOO <span>:</span> <span>{</span>
        from_string: <span>{</span> <span>|</span>s<span>|</span> <span>$s</span> <span>|</span> <span>split</span> row <span>'-'</span> <span>}</span>
        to_string: <span>{</span> <span>|</span><span>v</span><span>|</span> <span>$v</span> <span>|</span> str collect <span>'-'</span> <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p>现在，在一个 Nushell 实例内执行：</p>
<div><pre><code><span>></span> with-env <span>{</span> FOO <span>:</span> <span>'a-b-c'</span> <span>}</span> <span>{</span> nu <span>}</span>  <span># runs Nushell with FOO env. var. set to 'a-b-c'</span>

<span>></span> <span>$env</span>.FOO
  <span>0</span>   a
  <span>1</span>   b
  <span>2</span>   c
</code></pre></div><p>你可以看到<code>$env.FOO</code>现在是一个新的 Nushell 实例中的列表，配置已经更新。
你也可以通过以下方式手动测试转换：</p>
<div><pre><code><span>></span> <span>do</span> <span>$env</span>.ENV_CONVERSIONS.FOO.from_string <span>'a-b-c'</span>
</code></pre></div><p>现在，为了测试列表-&gt;字符串的转换，运行：</p>
<div><pre><code><span>></span> nu -c <span>'$env.FOO'</span>
a-b-c
</code></pre></div><p>因为<code>nu</code>是一个外部程序，Nushell 根据<code>ENV_CONVERSIONS.FOO.to_string</code>翻译了 <code>[ a b c ]</code> 列表，并把它传递给<code>nu</code>进程。
用<code>nu -c</code>运行命令不会加载配置文件，因此<code>FOO</code>的环境转换没有了，它被显示为一个普通的字符串 —— 这样我们可以验证转换是否成功。
你也可以通过<code>do $env.ENV_CONVERSIONS.FOO.to_string [a b c]</code>手动运行这个步骤。</p>
<p>如果我们回头看一下<a href="/book/commands/env.html"><code>env</code></a>命令，<code>raw</code>列显示由<code>ENV_CONVERSIONS.&lt;name&gt;.to_string</code>翻译的值，<code>value</code>列显示 Nushell 中使用的值（在<code>FOO</code>的情况下是<code>ENV_CONVERSIONS.&lt;name&gt;.from_string</code>的结果）。
如果这个值不是字符串，并且没有<code>to_string</code>的转换，它就不会被传递给外部（见<code>PROMPT_COMMAND</code>的<code>raw</code>列）。
一个例外是<code>PATH</code>（Windows 上的<code>Path</code>）。默认情况下，它在启动时将字符串转换为列表，在运行外部程序时，如果没有指定手动转换，则从列表转换为字符串。</p>
<p><em>(重要! 环境转换字符串-&gt;值发生在 <code>env.nu</code> 和 <code>config.nu</code> 被运行<strong>之后</strong>。<code>env.nu</code> 和 <code>config.nu</code> 中的所有环境变量仍然是字符串，除非你手动将它们设置为一些其他的值。)</em></p>
<h2 id="删除环境变量" tabindex="-1"> 删除环境变量</h2>
<p>只有当一个环境变量被设置在当前作用域中时，你才能通过 <a href="/book/commands/hide.html"><code>hide</code></a> 命令“删除”它：</p>
<div><pre><code><span>></span> let-env FOO <span>=</span> <span>'BAR'</span>
<span>..</span>.
<span>></span> hide FOO
</code></pre></div><p>隐藏也是有作用域的，这既允许你暂时删除一个环境变量，又可以防止你从子作用域内修改父环境：</p>
<div><pre><code><span>></span> let-env FOO <span>=</span> <span>'BAR'</span>
<span>></span> <span>do</span> <span>{</span>
    hide FOO
    <span># $env.FOO does not exist</span>
  <span>}</span>
<span>></span> <span>$env</span>.FOO
BAR
</code></pre></div><p>关于隐藏的更多细节，请参考 <a href="/zh-CN/book/modules.html#%E9%9A%90%E8%97%8F">模块</a></p>
]]></content>
  </entry>
  <entry>
    <title type="html">转移到系统</title>
    <id>www.nushell.sh/zh-CN/book/escaping.html</id>
    <link href="www.nushell.sh/zh-CN/book/escaping.html"/>
    <updated>2022-06-04T13:17:54.509Z</updated>
    <content type="html"><![CDATA[<h1 id="转移到系统" tabindex="-1"> 转移到系统</h1>
<p>Nu 提供了一套你可以在不同操作系统中使用的命令（也成为&quot;内部&quot;命令），而且具备这种一致性是很有帮助的。但有时，你需要运行一个与 Nu 内部命令同名的外部命令。例如，要运行外部的<code>ls</code>或<code>date</code>命令，你可以使用脱字符 (^) 命令。用 <code>^</code> 前缀 可以转移调用用户 PATH 中的命令（例如：<code>/bin/ls</code>，而不是 Nu 内部的 <a href="/book/commands/ls.html"><code>ls</code></a> 命令）。</p>
<p>Nu 的内部命令：</p>
<div><pre><code><span>></span> <span>ls</span>
</code></pre></div><p>转移到外部命令：</p>
<div><pre><code><span>></span> ^ls
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">外部命令</title>
    <id>www.nushell.sh/zh-CN/book/externs.html</id>
    <link href="www.nushell.sh/zh-CN/book/externs.html"/>
    <updated>2022-06-04T13:17:54.510Z</updated>
    <content type="html"><![CDATA[<h1 id="外部命令" tabindex="-1"> 外部命令</h1>
<p>调用外部命令是将 Nushell 作为一个 Shell 使用的基本部分（通常也将 Nushell 作为一种语言使用）。但是有一个问题，对于 Nushell 之外的命令而言，Nushell 不能帮助寻找调用中的错误，或者自动补全，或者语法高亮。</p>
<p>这就是 <code>extern</code> 的作用。<code>extern</code>关键字允许你为 Nushell 之外的命令写一个完整的签名，这样你就能得到上述所有的好处。如果你看一下默认配置，你会发现其中有一些<code>extern</code>调用。下面是其中之一：</p>
<div><pre><code>  <span>export</span> extern <span>"git push"</span> <span>[</span>
    remote?: string@<span>"nu-complete git remotes"</span>,   <span># the name of the remote</span>
    refspec?: string@<span>"nu-complete git branches"</span>  <span># the branch / refspec</span>
    --verbose<span>(</span>-v<span>)</span>                                <span># be more verbose</span>
    --quiet<span>(</span>-q<span>)</span>                                  <span># be more quiet</span>
    --repo: string                               <span># repository</span>
    --all                                        <span># push all refs</span>
    --mirror                                     <span># mirror all refs</span>
    --delete<span>(</span>-d<span>)</span>                                 <span># delete refs</span>
    --tags                                       <span># push tags (can't be used with --all or --mirror)</span>
    --dry-run<span>(</span>-n<span>)</span>                                <span># dry run</span>
    --porcelain                                  <span># machine-readable output</span>
    --force<span>(</span>-f<span>)</span>                                  <span># force updates</span>
    --force-with-lease: string                   <span># require old value of ref to be at this value</span>
    --recurse-submodules: string                 <span># control recursive pushing of submodules</span>
    --thin                                       <span># use thin pack</span>
    --receive-pack: string                       <span># receive pack program</span>
    --exec: string                               <span># receive pack program</span>
    --set-upstream<span>(</span>-u<span>)</span>                           <span># set upstream for git pull/status</span>
    --progress                                   <span># force progress reporting</span>
    --prune                                      <span># prune locally removed refs</span>
    --no-verify                                  <span># bypass pre-push hook</span>
    --follow-tags                                <span># push missing but relevant tags</span>
    --signed: string                             <span># GPG sign the push</span>
    --atomic                                     <span># request atomic transaction on remote side</span>
    --push-option<span>(</span>-o<span>)</span>: string                    <span># option to transmit</span>
    --ipv4<span>(</span>-4<span>)</span>                                   <span># use IPv4 addresses only</span>
    --ipv6<span>(</span>-6<span>)</span>                                   <span># use IPv6 addresses only</span>
  <span>]</span>
</code></pre></div><p>你会注意到这给了你所有与内部命令相同的描述性语法，让你描述标志(Flags)、短标志(Short Flags)、位置参数、类型等等。</p>
<h2 id="类型和自定义补全" tabindex="-1"> 类型和自定义补全</h2>
<p>在上面的例子中，你会注意到有些类型后面有<code>@</code>，接着后面是命令的名称。我们有独立的章节进一步谈论 <a href="/zh-CN/book/custom_completions.html">自定义补全</a>。</p>
<p>参数的类型（或形状）和自定义补全都告诉 Nushell 如何完成对该标志或位置值的补全。例如，将类型设置为<code>path</code>允许 Nushell 为你将值补全为一个文件路径。使用<code>@</code>和一个自定义的补全方式覆盖了这个默认行为，让该自定义补全方式返回给你完整的补全列表。</p>
<h2 id="局限性" tabindex="-1"> 局限性</h2>
<p>目前的<code>extern</code>语法有一些限制。在 Nushell 中，标志和位置参数是非常灵活的：标志可以在位置参数之前, 也可以与位置参数混合, 还可以跟随位置参数。许多外部命令没有这种灵活性。目前还没有一种方法来确保标志和位置参数的特定顺序与外部命令所要求的风格保持一致。</p>
<p>第二个限制是，有些外部命令要求使用<code>=</code>来传递标志和值。在 Nushell 中，<code>=</code>是一种方便的可选默认参数语法，目前还没有办法按要求使用它。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">安装 Nu</title>
    <id>www.nushell.sh/zh-CN/book/installation.html</id>
    <link href="www.nushell.sh/zh-CN/book/installation.html"/>
    <updated>2022-06-04T13:17:54.510Z</updated>
    <content type="html"><![CDATA[<h1 id="安装-nu" tabindex="-1"> 安装 Nu</h1>
<p>有很多方法可以获取并使用 Nu。你可以从我们的<a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">发布页面</a>下载预编译的二进制文件，也可以 <a href="https://repology.org/project/nushell/versions" target="_blank" rel="noopener noreferrer">使用你喜欢的软件包管理器</a>，或者从源码构建。</p>
<h2 id="预编译二进制包" tabindex="-1"> 预编译二进制包</h2>
<p>Nu 二进制文件在 <a href="https://github.com/nushell/nushell/releases" target="_blank" rel="noopener noreferrer">GitHub 的 Release 页</a>发布，适用于 Linux、macOS 和 Windows。只需下载并解压二进制文件，然后将其复制到你的系统<code>PATH</code>上的某个位置即可。</p>
<h2 id="软件包管理器" tabindex="-1"> 软件包管理器</h2>
<p>Nu 可以通过几个软件包管理器获得：</p>
<p><a href="https://repology.org/project/nushell/versions" target="_blank" rel="noopener noreferrer"><img src="https://repology.org/badge/vertical-allrepos/nushell.svg" alt="打包状态"></a></p>
<p>对于 macOS 和 Linux，<a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">Homebrew</a>是一个流行的选择（<code>brew install nushell</code>）。</p>
<p>对于 Windows 用户：</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/package-manager/winget/" target="_blank" rel="noopener noreferrer">Winget</a> (<code>winget install nushell</code>)</li>
<li><a href="https://chocolatey.org/" target="_blank" rel="noopener noreferrer">Chocolatey</a> (<code>choco install nushell</code>)</li>
<li><a href="https://scoop.sh/" target="_blank" rel="noopener noreferrer">Scoop</a> (<code>scoop install nu</code>)</li>
</ul>
<h2 id="从源码构建" tabindex="-1"> 从源码构建</h2>
<p>你也可以从源代码构建<code>Nu</code>。首先，你需要设置 Rust 工具链和它的依赖项。</p>
<h3 id="安装编译器套件" tabindex="-1"> 安装编译器套件</h3>
<p>为了使 Rust 能够正常工作，你需要在你的系统上安装一个兼容的编译器套件。以下是推荐的编译器套件：</p>
<ul>
<li>Linux：GCC 或 Clang</li>
<li>macOS：Clang (安装 Xcode)</li>
<li>Windows：MSVC（安装 <a href="https://visualstudio.microsoft.com/vs/community/" target="_blank" rel="noopener noreferrer">Visual Studio</a> 或 <a href="https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022" target="_blank" rel="noopener noreferrer">Visual Studio Build Tools</a>)
<ul>
<li>请确保安装 &quot;用 C++进行桌面开发&quot; 相关包</li>
<li>任何 Visual Studio 版本都可以(社区版是免费的)</li>
</ul>
</li>
</ul>
<h3 id="安装-rust" tabindex="-1"> 安装 Rust</h3>
<p>如果我们的系统中还没有 Rust，最好的方法是通过 <a href="https://rustup.rs/" target="_blank" rel="noopener noreferrer">rustup</a> 来安装它。Rustup 是一种管理 Rust 安装的工具，可以管理使用不同的 Rust 版本。</p>
<p>Nu 目前需要 <strong>最新（1.60 或更高）的稳定</strong> 版本的 Rust。最好的方法是让<code>rustup</code>为你找到正确的版本。当你第一次打开<code>rustup</code>时，它会询问你想安装哪个版本的 Rust：</p>
<div><pre><code>Current installation options:

default <span>host</span> triple: x86_64-unknown-linux-gnu
default toolchain: stable
profile: default
modify <span>PATH</span> variable: <span>yes</span>

<span>1</span><span>)</span> Proceed with installation <span>(</span>default<span>)</span>
<span>2</span><span>)</span> Customize installation
<span>3</span><span>)</span> Cancel installation
</code></pre></div><p>一旦我们准备好了，我们就按 <code>1</code>，然后回车。</p>
<p>如果你不愿意通过<code>rustup</code>来安装 Rust，你也可以通过其他方法来安装它（比如从 Linux 发行版的软件包中）。只要确保安装 1.60 或更高版本的 Rust 即可。</p>
<h3 id="依赖" tabindex="-1"> 依赖</h3>
<h4 id="debian-ubuntu" tabindex="-1"> Debian/Ubuntu</h4>
<p>你将需要安装 &quot;pkg-config&quot; 和 &quot;libssl-dev&quot; 包：</p>
<div><pre><code><span>apt</span> <span>install</span> pkg-config libssl-dev
</code></pre></div><p>对于希望使用 &quot;rawkey&quot; 或 &quot;clipboard&quot; 可选功能的 Linux 用户，需要安装 &quot;libx11-dev&quot; 和 &quot;libxcb-composite0-dev&quot; 软件包。</p>
<div><pre><code><span>apt</span> <span>install</span> libxcb-composite0-dev libx11-dev
</code></pre></div><h4 id="基于-rhel-的发行版" tabindex="-1"> 基于 RHEL 的发行版</h4>
<p>你需要安装 &quot;libxcb&quot;、&quot;openssl-devel&quot; 和 &quot;libX11-devel&quot;：</p>
<div><pre><code>yum <span>install</span> libxcb openssl-devel libX11-devel
</code></pre></div><h4 id="macos" tabindex="-1"> macOS</h4>
<p>使用 <a href="https://brew.sh/" target="_blank" rel="noopener noreferrer">Homebrew</a>，你需要通过如下方式安装 &quot;openssl&quot; 和 &quot;cmake&quot; ：</p>
<div><pre><code>brew <span>install</span> openssl cmake
</code></pre></div><h3 id="使用-crates-io进行构建" tabindex="-1"> 使用 <a href="https://crates.io" target="_blank" rel="noopener noreferrer">crates.io</a>进行构建</h3>
<p>Nu 发行版会作为源码发布到流行的 Rust 包仓库 <a href="https://crates.io/" target="_blank" rel="noopener noreferrer">crates.io</a>，这使得使用 <code>cargo</code> 构建并安装最新的 Nu 版本变得很容易：</p>
<div><pre><code><span>></span> cargo <span>install</span> nu
</code></pre></div><p>如此即可! <code>cargo</code>工具将完成下载 Nu 及其源码依赖，构建并将其安装到 cargo bin 路径中，以便我们能够运行它。</p>
<p>如果你想安装更多的功能，你可以使用：</p>
<div><pre><code><span>></span> cargo <span>install</span> nu --features<span>=</span>extra
</code></pre></div><p>安装完毕后，我们可以使用 <code>nu</code> 命令运行 Nu：</p>
<div><pre><code>$ nu
/home/jt/Source<span>></span>
</code></pre></div><h3 id="从-github-仓库构建" tabindex="-1"> 从 GitHub 仓库构建</h3>
<p>我们也可以从 GitHub 上的最新源码构建自己的 Nu。这让我们可以立即获得最新的功能和错误修复。首先，克隆源码仓库：</p>
<div><pre><code><span>></span> <span>git</span> clone https://github.com/nushell/nushell.git
</code></pre></div><p>然后，我们可以用以下方式构建和运行 Nu：</p>
<div><pre><code><span>></span> <span>cd</span> nushell
nushell<span>></span> cargo build --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --features<span>=</span>extra
</code></pre></div><p>你也可以在<strong>发布</strong>模式下构建和运行 Nu：</p>
<div><pre><code>nushell<span>></span> cargo build --release --workspace --features<span>=</span>extra <span>&amp;&amp;</span> cargo run --release --features<span>=</span>extra
</code></pre></div><p>熟悉 Rust 的人可能会问，如果 &quot;run&quot; 默认会构建，为什么我们还要做 &quot;build&quot; 和 &quot;run&quot; 这两个步骤？这是为了解决 Cargo 中新的 <code>default-run</code> 选项的缺陷，并确保所有插件都被构建，尽管这在将来可能不再需要。</p>
<h2 id="设置登录-shell-nix" tabindex="-1"> 设置登录 Shell (*nix)</h2>
<p><strong>!!! Nu 仍在开发中，对于日常使用可能并不稳定。!!!</strong></p>
<p>要设置登录 Shell，你可以使用<a href="https://linux.die.net/man/1/chsh" target="_blank" rel="noopener noreferrer"><code>chsh</code></a>命令。
一些 Linux 发行版有一个位于<code>/etc/shells</code>的有效 Shell 列表，在 Nu 被列入白名单之前不允许改变 Shell。如果你没有更新<code>shells</code>文件，你可能会看到类似于下面的错误：</p>
<div><pre><code>chsh: /home/username/.cargo/bin/nu is an invalid shell
</code></pre></div><p>你可以通过在<code>shells</code>文件中添加你的 Nu 二进制文件来把 Nu 添加到允许的 Shells 列表中。
添加的路径可以用<code>which nu</code>命令找到，通常是<code>$HOME/.cargo/bin/nu</code>。</p>
<h2 id="设置默认的-shell-windows-终端" tabindex="-1"> 设置默认的 Shell (Windows 终端)</h2>
<p>如果你使用的是 <a href="https://github.com/microsoft/terminal" target="_blank" rel="noopener noreferrer">Windows Terminal</a>，你可以通过添加如下内容到你的终端设置<code>&quot;profiles&quot;</code>（JSON 文件）中来设置<code>nu</code>作为你的默认 Shell：</p>
<div><pre><code><span>{</span>
  <span>"guid"</span><span>:</span> <span>"{2b372ca1-1ee2-403d-a839-6d63077ad871}"</span>,
  <span>"hidden"</span><span>:</span> false,
  <span>"icon"</span><span>:</span> <span>"https://www.nushell.sh/icon.png"</span>,
  <span>"name"</span><span>:</span> <span>"Nu Shell"</span>,
  <span>"commandline"</span><span>:</span> <span>"nu.exe"</span>
<span>}</span>
</code></pre></div><p>最后需要做的是将 <code>&quot;defaultProfile&quot;</code> 改为:</p>
<div><pre><code><span>"defaultProfile"</span><span>:</span> <span>"{2b372ca1-1ee2-403d-a839-6d63077ad871}"</span>,
</code></pre></div><p>之后，<code>nu</code> 应该会在 <strong>Windows Terminal</strong> 启动时被加载。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">介绍</title>
    <id>www.nushell.sh/zh-CN/book/introduction.html</id>
    <link href="www.nushell.sh/zh-CN/book/introduction.html"/>
    <updated>2022-06-04T13:17:54.510Z</updated>
    <content type="html"><![CDATA[<h1 id="介绍" tabindex="-1"> 介绍</h1>
<p>大家好，欢迎来到 Nushell 项目。这个项目的目标是彰显 Shell 的 Unix 哲学，就是用管道将简单的命令连接在一起，并且带来现代的开发风格。</p>
<p>Nu 从许多熟悉的领域中汲取了线索：bash 等传统 shell，PowerShell 等高级 shell，函数式编程，系统编程等。但是 Nu 并没有试图成为所有行业的杰作，而是将精力集中在做好一些事情上：</p>
<ul>
<li>创建具有现代感的灵活的跨平台 Shell</li>
<li>允许你将命令行应用程序与可理解数据结构的 Shell 进行混合和匹配</li>
<li>具有现代命令行应用程序提供的用户体验优化</li>
</ul>
<p>了解 Nu 可以做什么的最简单方式就是通过一些例子，所以让我们沉浸进去吧。</p>
<p>当你运行一个类似 <code>ls</code> 的命令时，第一个注意到的是所得到的不是一个文本块，而是一个结构化的表。</p>
<div><pre><code>> ls
────┬────────────────────┬──────┬────────┬────────────
 #  │ name               │ type │ size   │ modified
────┼────────────────────┼──────┼────────┼────────────
  0 │ 404.html           │ File │  429 B │ 3 days ago
  1 │ CONTRIBUTING.md    │ File │  955 B │ 8 mins ago
  2 │ Gemfile            │ File │ 1.1 KB │ 3 days ago
  3 │ Gemfile.lock       │ File │ 6.9 KB │ 3 days ago
  4 │ LICENSE            │ File │ 1.1 KB │ 3 days ago
  5 │ README.md          │ File │  213 B │ 3 days ago
...
</code></pre></div><p>这个表不仅仅是用另一种方式显示了当前目录。就像电子表格中的表一样，我们可以更加交互性地处理数据。</p>
<p>我们做的第一件事是将表格通过尺寸来排序。为了做到这点，我们将会把 <code>ls</code> 的输出喂给一个可以根据列的内容来排序表格的命令。</p>
<div><pre><code>> ls | sort-by size | reverse
────┬────────────────────┬──────┬────────┬────────────
 #  │ name               │ type │ size   │ modified
────┼────────────────────┼──────┼────────┼────────────
  0 │ Gemfile.lock       │ File │ 6.9 KB │ 3 days ago
  1 │ SUMMARY.md         │ File │ 3.7 KB │ 3 days ago
  2 │ Gemfile            │ File │ 1.1 KB │ 3 days ago
  3 │ LICENSE            │ File │ 1.1 KB │ 3 days ago
  4 │ CONTRIBUTING.md    │ File │  955 B │ 9 mins ago
  5 │ books.md           │ File │  687 B │ 3 days ago
...
</code></pre></div><p>你可以看到我们没有给 <code>ls</code> 传递命令行参数。作为代替，我们使用了 Nu 提供的 <code>sort-by</code> 命令来排序 <code>ls</code> 的输出。为了让最大的文件位于顶部，我们还使用了 <code>reverse</code>。</p>
<p>Nu 提供了许多可在表格上工作的命令。例如，我们可以过滤 <code>ls</code> 表格，只显示大于 1 KB 的文件：</p>
<div><pre><code>> ls | where size > 1kb
───┬──────────────┬──────┬────────┬────────────
 # │ name         │ type │ size   │ modified
───┼──────────────┼──────┼────────┼────────────
 0 │ Gemfile      │ File │ 1.1 KB │ 3 days ago
 1 │ Gemfile.lock │ File │ 6.9 KB │ 3 days ago
 2 │ LICENSE      │ File │ 1.1 KB │ 3 days ago
 3 │ SUMMARY.md   │ File │ 3.7 KB │ 3 days ago
───┴──────────────┴──────┴────────┴────────────
</code></pre></div><p>就像 Unix 哲学所体现的那样，作为可以相互交流的命令，为我们提供了许多种不同的配对。让我们看一个不同的命令：</p>
<div><pre><code>> ps
─────┬───────┬──────────────────┬─────────┬─────────┬──────────┬─────────
 #   │ pid   │ name             │ status  │ cpu     │ mem      │ virtual
─────┼───────┼──────────────────┼─────────┼─────────┼──────────┼─────────
   0 │ 33155 │ nu_plugin_core_p │ Running │  3.8496 │   1.8 MB │  4.4 GB
   1 │ 32841 │ mdworker_shared  │ Running │  0.0000 │  19.3 MB │  4.4 GB
   2 │ 32829 │ CoreServicesUIAg │ Running │  0.0000 │  16.1 MB │  4.5 GB
   3 │ 32828 │ mdworker_shared  │ Running │  0.0000 │  23.0 MB │  4.4 GB
</code></pre></div><p>如果你使用过 Linux，可能会对 <code>ps</code> 命令相当熟悉。这个命令为我们展示了系统所有正在运行的进程和它们的状态与名称。我们同样可以查看到它们的 CPU 占用。</p>
<p>如果我们想显示正在使用 CPU 的进程怎么办？ 就像我们之前使用 <code>ls</code> 命令一样，我们也可以使用 <code>ps</code> 命令返回的表：</p>
<div><pre><code>> ps | where cpu > 10
───┬──────┬──────────────────┬─────────┬────────┬──────────┬─────────
 # │ pid  │ name             │ status  │ cpu    │ mem      │ virtual
───┼──────┼──────────────────┼─────────┼────────┼──────────┼─────────
 0 │ 3971 │ Google Chrome He │ Running │ 5.1263 │  99.4 MB │  5.5 GB
 1 │  360 │ iTerm2           │ Running │ 6.6635 │ 218.6 MB │  6.0 GB
───┴──────┴──────────────────┴─────────┴────────┴──────────┴─────────
</code></pre></div><p>到目前为止，我们已经看到使用 <code>ls</code> 和 <code>ps</code> 列出文件和进程。 Nu 还提供了其他可以创建有用信息表的命令。 接下来，让我们探索<code>date</code> 和 <code>sys</code>。</p>
<p>运行 <code>date</code> 将给出当前日期与时间的信息：</p>
<div><pre><code>> date
──────────┬────────
 year     │ 2020
 month    │ 5
 day      │ 5
 hour     │ 21
 minute   │ 13
 second   │ 17
 timezone │ +02:00
──────────┴────────
</code></pre></div><p>运行 <code>sys</code> 将给出 Nu 所运行的系统的信息：</p>
<div><pre><code>> sys
─────────┬─────────────────────────────────────────
 host    │ [row 7 columns]
 cpu     │ [row cores current ghz max ghz min ghz]
 disks   │ [table 2 rows]
 mem     │ [row free swap free swap total total]
 net     │ [table 11 rows]
 battery │ [table 1 rows]
─────────┴─────────────────────────────────────────
</code></pre></div><p>和之前的表有些不一样， <code>sys</code> 命令给出的表在单元格内包含了另一些结构化的表格，而非简单的数值。为了查看到这些数据，我们需要选择要看的列：</p>
<div><pre><code>> sys | get host
──────────┬─────────────────────────────────────────────
 name     │ Linux
 release  │ 5.3.0-1019-azure
 version  │ #20-Ubuntu SMP Fri Mar 27 23:54:23 UTC 2020
 hostname │ lifeless
 arch     │ x86_64
 uptime   │ 8:03:47:32
 sessions │ [table 2 rows]
──────────┴─────────────────────────────────────────────
</code></pre></div><p><code>get</code> 命令让我们跳入表格中一列的内容。这样，我们正在观看 &quot;host&quot; 列，它包含了关于 Nu 所运行的主机的信息。操作系统的名字、主机名、CPU 架构等等。让我们看看系统上的用户名：</p>
<div><pre><code>> sys | get host.sessions
───┬─────────
 # │ &lt;value>
───┼─────────
 0 │ jonathan
───┴─────────
</code></pre></div><p>目前，系统上只有一个用户，名为 <code>jonathan</code>。 你会注意到，我们可以传递路径（ <code>host.sessions</code> 部分），而不仅仅是传递列名。 Nu 将采用该路径并转到表中的相应数据位置。</p>
<p>您可能已经注意到其他的不同之处。 我们没有一个数据表，而是只有一个元素：字符串 &quot;jonathan&quot;。 Nu 使用数据表和字符串。 字符串是在 Nu 之外使用命令的重要组成部分。</p>
<p>让我们看看字符串如何在 Nu 之外起作用。 我们将从前面的示例开始，并运行外部的 <code>echo</code> 命令（ <code>^</code> 告诉 nu 不要使用内置的 <code>echo</code> 命令）：</p>
<div><pre><code>> sys | get host.sessions | ^echo $it
jonathan
</code></pre></div><p>如果这看起来与我们以前的传统 Shell 非常相似，那么就说明你拥有敏锐的眼睛！ 相似，但是有一个重要的区别：我们对前面看到的值调用了 <code>^echo</code> 。 这允许我们将数据从 Nu 传递到 <code>echo</code>（或 Nu 外部的任何命令，例如 <code>git</code>）。</p>
<p><em>注意：Nu 的内建命令的帮助文本可以用 <code>help</code> 来浏览</em>:</p>
<div><pre><code>> help config
Configuration management.

Usage:
  > config &lt;subcommand> {flags}

Subcommands:
  config get - Gets a value from the config
  config set - Sets a value in the config
  config set_into - Sets a value in the config
  config clear - clear the config
  config load - Loads the config from the path given
  config remove - Removes a value from the config
  config path - return the path to the config file

Flags:
  -h, --help: Display this help message
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">Reedline，Nu 的行编辑器</title>
    <id>www.nushell.sh/zh-CN/book/line_editor.html</id>
    <link href="www.nushell.sh/zh-CN/book/line_editor.html"/>
    <updated>2022-06-04T13:17:54.511Z</updated>
    <content type="html"><![CDATA[<h1 id="reedline-nu-的行编辑器" tabindex="-1"> Reedline，Nu 的行编辑器</h1>
<p>Nushell 的行编辑器 <a href="https://github.com/nushell/reedline" target="_blank" rel="noopener noreferrer">Reedline</a> 是一个跨平台的行读取器，它被设计为模块化且颇具灵活性的。该引擎的作用是负责控制命令历史，验证，自动补全，提示以及屏幕绘制。</p>
<h2 id="配置" tabindex="-1"> 配置</h2>
<h3 id="编辑模式" tabindex="-1"> 编辑模式</h3>
<p>Reedline 允许你使用两种模式来编辑文本：vi 和 emacs。如果没有指定，默认的编辑模式是 emacs 模式。若要自行设置喜欢的模式，你可以修改配置文件为相应模式。比如：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.
    edit_mode: emacs
    <span>..</span>.
  <span>}</span>
</code></pre></div><h4 id="默认键盘绑定" tabindex="-1"> 默认键盘绑定</h4>
<p>每种编辑模式都有相应的 vi 或 emacs 文本编辑的常用快捷键设置。</p>
<p>Emacs 和 Vi 快捷键绑定</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Esc</td>
<td>Esc</td>
</tr>
<tr>
<td>Backspace</td>
<td>退格</td>
</tr>
<tr>
<td>End</td>
<td>移至行尾</td>
</tr>
<tr>
<td>End</td>
<td>补全历史提示</td>
</tr>
<tr>
<td>Home</td>
<td>移至行首</td>
</tr>
<tr>
<td>Ctr + c</td>
<td>取消当前行</td>
</tr>
<tr>
<td>Ctr + l</td>
<td>清除屏幕</td>
</tr>
<tr>
<td>Ctr + r</td>
<td>搜索历史</td>
</tr>
<tr>
<td>Ctr + Right</td>
<td>Complete history word</td>
</tr>
<tr>
<td>Ctr + Right</td>
<td>右移一个词</td>
</tr>
<tr>
<td>Ctr + Left</td>
<td>左移一个词</td>
</tr>
<tr>
<td>Up</td>
<td>菜单上移</td>
</tr>
<tr>
<td>Up</td>
<td>上移</td>
</tr>
<tr>
<td>Down</td>
<td>菜单下移</td>
</tr>
<tr>
<td>Down</td>
<td>下移</td>
</tr>
<tr>
<td>Left</td>
<td>菜单左移</td>
</tr>
<tr>
<td>Left</td>
<td>左移</td>
</tr>
<tr>
<td>Right</td>
<td>完成历史提示</td>
</tr>
<tr>
<td>Right</td>
<td>菜单右移</td>
</tr>
<tr>
<td>Right</td>
<td>右移</td>
</tr>
<tr>
<td>Ctr + b</td>
<td>菜单左移</td>
</tr>
<tr>
<td>Ctr + b</td>
<td>左移</td>
</tr>
<tr>
<td>Ctr + f</td>
<td>完成历史提示</td>
</tr>
<tr>
<td>Ctr + f</td>
<td>菜单右移</td>
</tr>
<tr>
<td>Ctr + f</td>
<td>右移</td>
</tr>
<tr>
<td>Ctr + p</td>
<td>菜单上移</td>
</tr>
<tr>
<td>Ctr + p</td>
<td>上移</td>
</tr>
<tr>
<td>Ctr + n</td>
<td>菜单下移</td>
</tr>
<tr>
<td>Ctr + n</td>
<td>下移</td>
</tr>
</tbody>
</table>
<p>Vi 普通键绑定</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>事件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctr + c</td>
<td>取消当前行</td>
</tr>
<tr>
<td>Ctr + l</td>
<td>清除屏幕</td>
</tr>
<tr>
<td>Up</td>
<td>菜单上移</td>
</tr>
<tr>
<td>Up</td>
<td>上移</td>
</tr>
<tr>
<td>Down</td>
<td>菜单下移</td>
</tr>
<tr>
<td>Down</td>
<td>下移</td>
</tr>
<tr>
<td>Left</td>
<td>菜单左移</td>
</tr>
<tr>
<td>Left</td>
<td>左移</td>
</tr>
<tr>
<td>Right</td>
<td>菜单右移</td>
</tr>
<tr>
<td>Right</td>
<td>右移</td>
</tr>
</tbody>
</table>
<p>除了之前的键盘绑定，在正常 Vi 模式下，你可以使用经典的 Vi 快捷键来进行移动或者执行相应的动作。可用的组合的选项是：</p>
<p>Vi 正常移动快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>移动</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>前移一个单词</td>
</tr>
<tr>
<td>d</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>0</td>
<td>移动到行首</td>
</tr>
<tr>
<td>$</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>f</td>
<td>行内向右查找字符</td>
</tr>
<tr>
<td>t</td>
<td>行内右移到指定字符前</td>
</tr>
<tr>
<td>F</td>
<td>行内向左查找字符</td>
</tr>
<tr>
<td>T</td>
<td>行内左移到指定字符前</td>
</tr>
</tbody>
</table>
<p>Vi 正常操作快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>删除</td>
</tr>
<tr>
<td>p</td>
<td>在光标之后粘贴</td>
</tr>
<tr>
<td>P</td>
<td>在光标之前粘贴</td>
</tr>
<tr>
<td>h</td>
<td>左移</td>
</tr>
<tr>
<td>l</td>
<td>右移</td>
</tr>
<tr>
<td>j</td>
<td>下移</td>
</tr>
<tr>
<td>k</td>
<td>上移</td>
</tr>
<tr>
<td>w</td>
<td>右移一个单词</td>
</tr>
<tr>
<td>b</td>
<td>左移一个单词</td>
</tr>
<tr>
<td>i</td>
<td>在光标前插入</td>
</tr>
<tr>
<td>a</td>
<td>在光标后插入</td>
</tr>
<tr>
<td>0</td>
<td>移到行首</td>
</tr>
<tr>
<td>^</td>
<td>移到行首</td>
</tr>
<tr>
<td>$</td>
<td>移到行尾</td>
</tr>
<tr>
<td>u</td>
<td>撤销</td>
</tr>
<tr>
<td>c</td>
<td>修改</td>
</tr>
<tr>
<td>x</td>
<td>删除字符</td>
</tr>
<tr>
<td>s</td>
<td>搜索历史</td>
</tr>
<tr>
<td>D</td>
<td>删除当前位置到行尾</td>
</tr>
<tr>
<td>A</td>
<td>在当前行最后插入</td>
</tr>
</tbody>
</table>
<h3 id="命令历史" tabindex="-1"> 命令历史</h3>
<p>如前所述，Reedline 管理并存储所有被编辑并发送给 Nushell 的命令。要配置 Reedline 可以存储的最大记录数，你需要在配置文件中调整这个值：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.
    max_history_size: <span>1000</span>
    <span>..</span>.
  <span>}</span>
</code></pre></div><h3 id="定制你的提示" tabindex="-1"> 定制你的提示</h3>
<p>Reedline 的提示语也是高度可定制的。为了构建你的完美提示符，你可以在配置文件中定义下面的环境变量：</p>
<div><pre><code><span># Use nushell functions to define your right and left prompt</span>
def create_left_prompt <span>[</span><span>]</span> <span>{</span>
    <span>let</span> path_segment <span>=</span> <span>(</span><span>$env</span><span>.</span><span>PWD</span><span>)</span>

    <span>$path_segment</span>
<span>}</span>

def create_right_prompt <span>[</span><span>]</span> <span>{</span>
    <span>let</span> time_segment <span>=</span> <span>(</span><span>[</span>
        <span>(</span>date now <span>|</span> <span>date</span> <span>format</span> <span>'%m/%d/%Y %r'</span><span>)</span>
    <span>]</span> <span>|</span> str collect<span>)</span>

    <span>$time_segment</span>
<span>}</span>

let-env PROMPT_COMMAND <span>=</span> <span>{</span> create_left_prompt <span>}</span>
let-env PROMPT_COMMAND_RIGHT <span>=</span> <span>{</span> create_right_prompt <span>}</span>
</code></pre></div><div><p>TIP</p>
<p>你并非必须要用 Nushell 的函数来定义环境变量，也可以使用简单的字符串来定义它们。</p>
</div>
<p>你也可以通过修改以下环境变量来定制行编辑器的提示符：</p>
<div><pre><code>let-env PROMPT_INDICATOR <span>=</span> <span>"〉"</span>
let-env PROMPT_INDICATOR_VI_INSERT <span>=</span> <span>": "</span>
let-env PROMPT_INDICATOR_VI_NORMAL <span>=</span> <span>"〉"</span>
let-env PROMPT_MULTILINE_INDICATOR <span>=</span> <span>"::: "</span>
</code></pre></div><div><p>TIP</p>
<p>提示符是环境变量，它代表了提示的状态</p>
</div>
<h2 id="按键绑定" tabindex="-1"> 按键绑定</h2>
<p>Reedline 按键绑定是一个强大的结构，它允许你建立一连串的事件，而且这些事件可以通过特定的按键组合来触发。</p>
<p>例如，我们假设你想把补全菜单绑定到 <code>Ctrl + t</code> 这组快捷键上（默认是<code>tab</code>）。你可以添加下面的条目到你的配置文件：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    keybindings: <span>[</span>
      <span>{</span>
        name: completion_menu
        modifier: control
        keycode: char_t
        mode: emacs
        event: <span>{</span> send: menu name: completion_menu <span>}</span>
      <span>}</span>
    <span>]</span>

    <span>..</span>.
  <span>}</span>
</code></pre></div><p>在加载这个新的 <code>config.nu</code> 之后，你的新键盘绑定（<code>Ctrl + t</code>）将打开命令自动补全。</p>
<p>每个按键绑定都需要以下元素：</p>
<ul>
<li>name: 为你的绑定键取一个独特的名字，以便于在<code>$config.keybindings</code>中引用</li>
<li>modifier: 绑定键的修饰符。选项有：
<ul>
<li>none</li>
<li>control</li>
<li>alt</li>
<li>shift</li>
<li>control | alt</li>
<li>control | alt | shift</li>
</ul>
</li>
<li>keycode: 这代表要按下的键</li>
<li>mode: emacs, vi_insert, vi_normal (一个单独的字符串或一个列表，例如： [<code>vi_insert</code> <code>vi_normal</code>])</li>
<li>event: 键盘绑定要发送的事件的类型。选项包括：
<ul>
<li>send</li>
<li>edit</li>
<li>until</li>
</ul>
</li>
</ul>
<div><p>TIP</p>
<p>所有可用的修饰键、键码和事件都可以通过<code>keybindings list</code>命令找到。</p>
</div>
<div><p>TIP</p>
<p>添加到 <code>vi_insert</code> 模式中的按键绑定将在行编辑器处于插入模式（可以写入文本）时可用，而标有 <code>vi_normal</code> 模式的按键绑定将在正常模式下（当光标使用 h、j、k 或 l 移动时）可用。</p>
</div>
<p>键盘绑定条目的事件部分是定义要执行的动作的地方。在这个字段，你可以使用一个记录或一个记录列表。比如这样：</p>
<div><pre><code>  <span>..</span>.
  event: <span>{</span> send: Enter <span>}</span>
  <span>..</span>.
</code></pre></div><p>或者</p>
<div><pre><code>  <span>..</span>.
  event: <span>[</span>
    <span>{</span> edit: Clear <span>}</span>
    <span>{</span> send: Enter <span>}</span>
  <span>]</span>
  <span>..</span>.
</code></pre></div><p>上述第一个按键绑定例子遵循第一种情况，只有一个事件被发送到引擎。</p>
<p>后一个按键绑定的例子是向引擎发送一系列的事件。它首先清除提示，插入一个字符串，然后输入该值。</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    keybindings: <span>[</span>
    <span>{</span>
      name: change_dir_with_fzf
      modifier: CONTROL
      keycode: Char_t
      mode: emacs
      event:<span>[</span>
          <span>{</span> edit: Clear <span>}</span>
          <span>{</span> edit: InsertString,
            value: <span>"cd (ls | where type == dir | each { |it| <span>$it</span>.name} | str collect (char nl) | fzf | decode utf-8 | str trim)"</span>

          <span>}</span>
          <span>{</span> send: Enter <span>}</span>
        <span>]</span>
    <span>}</span>

    <span>..</span>.
  <span>}</span>
</code></pre></div><p>上面按键绑定的缺点是，插入的文本将被验证处理并保存在历史记录中，这使得按键绑定的执行速度有点慢，而且会用相同的命令来填充命令历史。出于这个原因，可以采用 <code>ExecuteHostCommand</code> 类型的事件。下一个例子以更简单的方式做了与前一个相同的事情，发送了一个单一的事件给引擎：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    keybindings: <span>[</span>
    <span>{</span>
      name: change_dir_with_fzf
      modifier: CONTROL
      keycode: Char_y
      mode: emacs
      event: <span>{</span>
        send: ExecuteHostCommand,
        cmd: <span>"cd (ls | where type == dir | each { |it| <span>$it</span>.name} | str collect (char nl) | fzf | decode utf-8 | str trim)"</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>

    <span>..</span>.
  <span>}</span>
</code></pre></div><p>在我们继续之前，你一定已经注意到，编辑和发送的语法发生了变化，因此有必要对它们进行更多的解释。 <code>send</code> 是所有可以被引擎处理的 <code>Reedline</code> 事件，而 <code>edit</code> 是所有可以被引擎处理的 <code>EditCommands</code>。</p>
<h3 id="send类型" tabindex="-1"> <code>send</code>类型</h3>
<p>要找到 <code>send</code> 的所有可用选项，你可以使用：</p>
<div><pre><code>keybindings list <span>|</span> where <span>type</span> <span>==</span> events
</code></pre></div><p>而 <code>send</code> 事件的语法如下：</p>
<div><pre><code>    <span>..</span>.
      event: <span>{</span> send: <span>&lt;</span>NAME OF EVENT FROM LIST<span>></span> <span>}</span>
    <span>..</span>.
</code></pre></div><div><p>TIP</p>
<p>你可以用大写字母来命名事件的名称，键盘绑定解析器是不区分大小写的。</p>
</div>
<p>这条规则有两个例外：<code>Menu</code>和<code>ExecuteHostCommand</code>。这两个事件需要一个额外的字段来完成，<code>Menu</code> 需要有一个菜单的名称才能触发（自动补全菜单或历史命令菜单）：</p>
<div><pre><code>    <span>..</span>.
      event: <span>{</span>
        send: menu
        name: completion_menu
      <span>}</span>
    <span>..</span>.
</code></pre></div><p>而 <code>ExecuteHostCommand</code> 需要一个有效的命令，它将被发送到引擎：</p>
<div><pre><code>    <span>..</span>.
      event: <span>{</span>
        send: ExecuteHostCommand
        cmd: <span>"cd ~"</span>
      <span>}</span>
    <span>..</span>.
</code></pre></div><p>值得一提的是，在事件列表中，你还会看到<code>Edit([])</code>，<code>Multiple([])</code>和<code>UntilFound([])</code>。这些选项对解析器是不可见的，因为它们是基于键盘绑定的定义来构建的。例如，当你在键盘绑定事件里面定义了一个记录列表时，就会为你建立一个<code>Multiple([])</code>事件。<code>Edit([])</code>事件与前面提到的<code>edit</code>类型相同。<code>UntilFound([])</code>事件和前面提到的<code>until</code>类型一样。</p>
<h3 id="edit类型" tabindex="-1"> <code>edit</code>类型</h3>
<p><code>edit</code>类型是<code>Edit([])</code>事件的简化。<code>event</code>类型简化了定义复杂编辑事件的按键绑定。要列出可用的选项，你可以使用下面的命令：</p>
<div><pre><code>keybindings list <span>|</span> where <span>type</span> <span>==</span> edits
</code></pre></div><p>以下是编辑的常用语法：</p>
<div><pre><code>    <span>..</span>.
      event: <span>{</span> edit: <span>&lt;</span>NAME OF EDIT FROM LIST<span>></span> <span>}</span>
    <span>..</span>.
</code></pre></div><p>列表中带有 <code>()</code> 的编辑的语法有一点变化，因为这些编辑需要一个额外的值来进行完全定义。例如，如果我们想在提示符所在的位置插入一个字符串，那么你将不得不使用如下方式：</p>
<div><pre><code>    <span>..</span>.
      event: <span>{</span>
        edit: InsertString
        value: <span>"MY NEW STRING"</span>
      <span>}</span>
    <span>..</span>.
</code></pre></div><p>或者说你想向右移动，直到第一个<code>S</code>：</p>
<div><pre><code>    <span>..</span>.
      event: <span>{</span>
        edit: MoveRightUntil
        value: <span>"S"</span>
      <span>}</span>
    <span>..</span>.
</code></pre></div><p>正如你所看到的，这两种类型将允许你构建你需要的任何类型的按键绑定。</p>
<h3 id="until类型" tabindex="-1"> <code>until</code>类型</h3>
<p>为了完成这个按键绑定之旅，我们需要讨论事件的<code>until</code>类型。正如你到目前为止所看到的，你可以发送一个单一的事件或一个事件列表。而当一个事件列表被发送时，每一个事件都会被处理。</p>
<p>然而，在有些情况下，你可能想把不同的事件分配给同一个键盘绑定。这在 Nushell 菜单中特别有用。例如，假设你仍然想用<code>Ctrl + t</code>激活你的补全菜单，但你也想在菜单被激活后用同一个快捷键移动到下一个元素。</p>
<p>对于这些情况，我们有<code>until</code>关键字。在<code>until</code>事件中列出的事件将被逐一处理，不同的是，一旦一个事件被成功处理，事件处理就会停止。</p>
<p>下一个键盘绑定就是这种情况：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    keybindings: <span>[</span>
      <span>{</span>
        name: completion_menu
        modifier: control
        keycode: char_t
        mode: emacs
        event: <span>{</span>
          until: <span>[</span>
            <span>{</span> send: menu name: completion_menu <span>}</span>
            <span>{</span> send: MenuNext <span>}</span>
          <span>]</span>
        <span>}</span>
      <span>}</span>
    <span>]</span>

    <span>..</span>.
  <span>}</span>
</code></pre></div><p>上面的按键绑定将首先尝试打开一个补全菜单。如果菜单没有激活，它将激活它并发送一个成功信号。如果再次按下按键绑定，因为已经有一个激活的菜单，那么它将发送的下一个事件是<code>MenuNext</code>，这意味着它将把选择器移动到菜单的下一个元素。</p>
<p>正如你所看到的，<code>until</code>关键字允许我们为同一个键盘绑定定义两个事件。在写这篇文章的时候，只有菜单事件允许这种类型的分层。其他非菜单事件类型将总是返回一个成功值，这意味着<code>until</code>事件在到达第一个命令时就会停止。</p>
<p>例如，下一个按键绑定将总是发送一个<code>down</code>，因为该事件总是成功的。</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    keybindings: <span>[</span>
      <span>{</span>
        name: completion_menu
        modifier: control
        keycode: char_t
        mode: emacs
        event: <span>{</span>
          until: <span>[</span>
            <span>{</span> send: down <span>}</span>
            <span>{</span> send: menu name: completion_menu <span>}</span>
            <span>{</span> send: menunext <span>}</span>
          <span>]</span>
        <span>}</span>
      <span>}</span>
    <span>]</span>

    <span>..</span>.
  <span>}</span>
</code></pre></div><h3 id="移除一个默认的按键绑定" tabindex="-1"> 移除一个默认的按键绑定</h3>
<p>如果你想删除某个默认的按键绑定，而不打算使用不同的动作来替代它，你可以设置<code>event: null</code>。</p>
<p>例如，在所有的编辑模式下，禁用 <code>Ctrl + l</code> 清除屏幕：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    keybindings: <span>[</span>
      <span>{</span>
        modifier: control
        keycode: char_l
        mode: <span>[</span>emacs, vi_normal, vi_insert<span>]</span>
        event: null
      <span>}</span>
    <span>]</span>

    <span>..</span>.
  <span>}</span>

</code></pre></div><h3 id="排查键盘绑定问题" tabindex="-1"> 排查键盘绑定问题</h3>
<p>你的终端环境可能并不总是以你期望的方式将你的组合键冒泡到 Nushell 上。
你可以使用<code>keybindings listen</code>命令来确定 Nushell 是否真的收到了某些按键，以及如何收到的。</p>
<h2 id="菜单" tabindex="-1"> 菜单</h2>
<p>感谢 Reedline，Nushell 的菜单可以帮助你完成日常的 Shell 脚本操作。接下来我们介绍一下在使用 Nushell 时一直可用的默认菜单。</p>
<h3 id="帮助菜单" tabindex="-1"> 帮助菜单</h3>
<p>帮助菜单的存在是为了方便你过渡到 Nushell。假设你正在组建一个惊人的管道，然后你忘记了反转一个字符串的内部命令。你可以用<code>ctr+q</code>来激活帮助菜单，而不是删除你的管道。一旦激活，只需输入你要找的命令的关键词，菜单就会显示与你的输入相匹配的命令，而匹配的依据就是命令的名称或描述。</p>
<p>要浏览菜单，你可以用<code>tab</code>选择下一个元素，你可以按左键或右键滚动描述，你甚至可以在行中粘贴可用的命令例子。</p>
<p>帮助菜单可以通过修改以下参数进行配置：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    menus <span>=</span> <span>[</span>
      <span>..</span>.
      <span>{</span>
        name: help_menu
        only_buffer_difference: <span>true</span> <span># Search is done on the text written after activating the menu</span>
        marker: <span>"? "</span>                 <span># Indicator that appears with the menu is active</span>
        type: <span>{</span>
            layout: description      <span># Type of menu</span>
            columns: <span>4</span>               <span># Number of columns where the options are displayed</span>
            col_width: <span>20</span>            <span># Optional value. If missing all the screen width is used to calculate column width</span>
            col_padding: <span>2</span>           <span># Padding between columns</span>
            selection_rows: <span>4</span>        <span># Number of rows allowed to display found options</span>
            description_rows: <span>10</span>     <span># Number of rows allowed to display command description</span>
        <span>}</span>
        style: <span>{</span>
            text: green                   <span># Text style</span>
            selected_text: green_reverse  <span># Text style for selected option</span>
            description_text: yellow      <span># Text style for description</span>
        <span>}</span>
      <span>}</span>
      <span>..</span>.
    <span>]</span>
    <span>..</span>.
</code></pre></div><h3 id="补全菜单" tabindex="-1"> 补全菜单</h3>
<p>补全菜单是一个上下文敏感的菜单，它将根据提示的状态给出建议。这些建议的范围包括从路径建议到替代命令。在编写命令时，你可以激活该菜单以查看内部命令的可用选项。另外，如果你已经为外部命令定义了你的自定义补全方式，这些补全提示也会出现在菜单中。</p>
<p>默认情况下，补全菜单是通过按<code>tab</code>访问的，它可以通过修改配置对象中的这些值来进行配置：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    menus <span>=</span> <span>[</span>
      <span>..</span>.
      <span>{</span>
        name: completion_menu
        only_buffer_difference: <span>false</span> <span># Search is done on the text written after activating the menu</span>
        marker: <span>"| "</span>                  <span># Indicator that appears with the menu is active</span>
        type: <span>{</span>
            layout: columnar          <span># Type of menu</span>
            columns: <span>4</span>                <span># Number of columns where the options are displayed</span>
            col_width: <span>20</span>             <span># Optional value. If missing all the screen width is used to calculate column width</span>
            col_padding: <span>2</span>            <span># Padding between columns</span>
        <span>}</span>
        style: <span>{</span>
            text: green                   <span># Text style</span>
            selected_text: green_reverse  <span># Text style for selected option</span>
            description_text: yellow      <span># Text style for description</span>
        <span>}</span>
      <span>}</span>
      <span>..</span>.
    <span>]</span>
    <span>..</span>.
</code></pre></div><p>通过修改这些参数，你可以根据自己的喜好定制你的菜单布局。</p>
<h3 id="历史菜单" tabindex="-1"> 历史菜单</h3>
<p>历史菜单是访问编辑器命令历史的一个便捷方法。当激活菜单时(默认为<code>Ctrl+x</code>)，命令的历史会以时间倒序显示，这使得选择前一个命令变得非常容易。</p>
<p>历史菜单可以通过修改配置对象中的这些值进行配置：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    menus <span>=</span> <span>[</span>
      <span>..</span>.
      <span>{</span>
        name: help_menu
        only_buffer_difference: <span>true</span> <span># Search is done on the text written after activating the menu</span>
        marker: <span>"? "</span>                 <span># Indicator that appears with the menu is active</span>
        type: <span>{</span>
            layout: list             <span># Type of menu</span>
            page_size: <span>10</span>            <span># Number of entries that will presented when activating the menu</span>
        <span>}</span>
        style: <span>{</span>
            text: green                   <span># Text style</span>
            selected_text: green_reverse  <span># Text style for selected option</span>
            description_text: yellow      <span># Text style for description</span>
        <span>}</span>
      <span>}</span>
      <span>..</span>.
    <span>]</span>
    <span>..</span>.
</code></pre></div><p>当历史菜单被激活时，它从历史中拉出<code>page_size</code>个记录并在菜单中呈现。如果终端还有空间，当你再次按<code>Ctrl+x</code>时，菜单将拉出相同数量的记录，并将它们追加到当前页。如果不可能呈现所有拉出的记录，菜单将创建一个新的页面。可以通过按<code>Ctrl+z</code>转到上一页或<code>Ctrl+x</code>转到下一页来浏览这些页面。</p>
<h4 id="搜索历史记录" tabindex="-1"> 搜索历史记录</h4>
<p>要在你的命令历史中搜索，你可以开始输入你要找的命令的关键词。一旦菜单被激活，你输入的任何内容都会被历史记录中选定的命令所取代。例如，假设你已经输入了以下内容：</p>
<div><pre><code><span>let</span> a <span>=</span> <span>(</span><span>)</span>
</code></pre></div><p>你可以把光标放在 <code>()</code> 内并激活菜单，你可以通过输入关键词来过滤历史记录，一旦你选择了一个条目，输入的词就会被替换：</p>
<div><pre><code><span>let</span> a <span>=</span> <span>(</span>ls <span>|</span> where size <span>></span> 10MiB<span>)</span>
</code></pre></div><h4 id="菜单快速选择" tabindex="-1"> 菜单快速选择</h4>
<p>菜单的另一个很好的特性是能够快速选择其中的内容。假设你已经激活了你的菜单，它看起来像这样：</p>
<div><pre><code><span>></span>
<span>0</span>: <span>ls</span> <span>|</span> where size <span>></span> 10MiB
<span>1</span>: <span>ls</span> <span>|</span> where size <span>></span> 20MiB
<span>2</span>: <span>ls</span> <span>|</span> where size <span>></span> 30MiB
<span>3</span>: <span>ls</span> <span>|</span> where size <span>></span> 40MiB
</code></pre></div><p>你可以输入<code>!3</code>，然后按回车，而不是按向下键去选择第四个条目。这将在提示位置插入选定的文本，节省你向下滚动菜单的时间。</p>
<p>历史搜索和快速选择可以一起使用。你可以激活菜单，进行快速搜索，然后使用前面的方法进行快速选择。</p>
<h3 id="用户定义菜单" tabindex="-1"> 用户定义菜单</h3>
<p>如果你发现默认的菜单对你来说是不够的，你需要要创建自己的菜单，Nushell 也可以帮你做到这点。</p>
<p>为了添加一个满足你需求的新菜单，你可以使用其中一个默认的布局作为模板。Nushell 中可用的模板有列式、列表式或描述式。</p>
<p>列式菜单将以列的方式向你显示数据，并根据你的列中显示的文本大小调整列数。</p>
<p>列表类型的菜单将总是以列表的形式显示建议，你可以通过使用<code>!</code>加数字的组合来选择值。</p>
<p>描述类型将给你更多的空间来显示一些值的描述，以及可以插入到缓冲区的额外信息。</p>
<p>假设我们想创建一个菜单，用于显示在你的会话中创建的所有变量，我们将把它称为<code>vars_menu</code>。这个菜单将使用一个列表布局 (layout: list)。为了搜索值，我们希望只使用菜单激活后输入的东西(only_buffer_difference: true)。</p>
<p>满足这些所需的菜单将看起来像这样：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    menus <span>=</span> <span>[</span>
      <span>..</span>.
      <span>{</span>
        name: vars_menu
        only_buffer_difference: <span>true</span>
        marker: <span>"# "</span>
        type: <span>{</span>
            layout: list
            page_size: <span>10</span>
        <span>}</span>
        style: <span>{</span>
            text: green
            selected_text: green_reverse
            description_text: yellow
        <span>}</span>
        source: <span>{</span> <span>|</span>buffer, position<span>|</span>
            <span>$nu</span>.scope.vars
            <span>|</span> where name <span>=~</span> <span>$buffer</span>
            <span>|</span> sort-by name
            <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> <span>{</span>value: <span>$it</span>.name description: <span>$it</span>.type<span>}</span> <span>}</span>
        <span>}</span>
      <span>}</span>
      <span>..</span>.
    <span>]</span>
    <span>..</span>.
</code></pre></div><p>正如你所看到的，新的菜单与之前描述的<code>history_menu</code>是相同的，唯一的区别是新的字段叫<code>source</code>。<code>source</code>字段是 Nushell 所定义的，它包含了你想在菜单中显示的值。对于这个菜单，我们从<code>$nu.scope.vars</code>中提取数据，然后用它来创建记录并填充菜单。</p>
<p>记录所需的结构如下：</p>
<div><pre><code><span>{</span>
  value:       <span># The value that will be inserted in the buffer</span>
  description: <span># Optional. Description that will be display with the selected value</span>
  span: <span>{</span>      <span># Optional. Span indicating what section of the string will be replaced by the value</span>
    start:
    end:
  <span>}</span>
  extra: <span>[</span>string<span>]</span> <span># Optional. A list of strings that will be displayed with the selected value. Only works with a description menu</span>
<span>}</span>
</code></pre></div><p>为了让菜单显示一些东西，至少<code>value</code>字段必须存在于结果记录中。</p>
<p>为了使菜单具有交互性，这两个变量在块中可用：<code>$buffer</code>和<code>$position</code>。<code>$buffer</code>包含菜单捕获的值，当选项<code>only_buffer_difference</code>为真时，<code>$buffer</code>是菜单被激活后输入的文本。如果<code>only_buffer_difference</code>是假的，<code>$buffer</code>是行中所有的字符串。<code>$position</code>变量可以用来根据你对菜单的设想创建替换范围。<code>$position</code>的值会随着<code>only_buffer_difference</code>是真还是假而改变。当为真时，<code>$position</code>是在菜单激活后插入文本的字符串的起始位置；当值为 false 时，<code>$position</code>表示实际的光标位置。</p>
<p>利用这些信息，你可以设计你的菜单来呈现你所需要的信息，并在需要的位置替换该值。之后，玩转你的菜单唯一额外需要做的事情是定义一个按键绑定，并用于激活你的全新菜单。</p>
<h3 id="菜单按键绑定" tabindex="-1"> 菜单按键绑定</h3>
<p>如果你想改变两个菜单的默认激活方式，可以通过定义新的按键绑定来实现。例如，接下来的两个按键绑定设置分别将<code>Ctrl+t</code>和<code>Ctrl+y</code>定义为触发自动补全和历史菜单：</p>
<div><pre><code>  <span>let</span> <span>$config</span> <span>=</span> <span>{</span>
    <span>..</span>.

    keybindings: <span>[</span>
      <span>{</span>
        name: completion_menu
        modifier: control
        keycode: char_t
        mode: <span>[</span>vi_insert vi_normal<span>]</span>
        event: <span>{</span>
          until: <span>[</span>
            <span>{</span> send: menu name: completion_menu <span>}</span>
            <span>{</span> send: menupagenext <span>}</span>
          <span>]</span>
        <span>}</span>
      <span>}</span>
      <span>{</span>
        name: history_menu
        modifier: control
        keycode: char_y
        mode: <span>[</span>vi_insert vi_normal<span>]</span>
        event: <span>{</span>
          until: <span>[</span>
            <span>{</span> send: menu name: history_menu <span>}</span>
            <span>{</span> send: menupagenext <span>}</span>
          <span>]</span>
        <span>}</span>
      <span>}</span>
    <span>]</span>

    <span>..</span>.
  <span>}</span>
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">加载数据</title>
    <id>www.nushell.sh/zh-CN/book/loading_data.html</id>
    <link href="www.nushell.sh/zh-CN/book/loading_data.html"/>
    <updated>2022-06-04T13:17:54.512Z</updated>
    <content type="html"><![CDATA[<h1 id="加载数据" tabindex="-1"> 加载数据</h1>
<p>之前我们使用了<a href="/book/commands/ls.html"><code>ls</code></a>、<a href="/book/commands/ps.html"><code>ps</code></a>、<a href="/book/commands/date.html"><code>date</code></a>和<a href="/book/commands/sys.html"><code>sys</code></a>等命令来加载关于文件、进程、日期时间和系统本身的信息。每条命令都会给我们提供一个信息表，以对其进行探索。我们也可以通过其他方式将数据载入表格以供使用。</p>
<h2 id="打开文件" tabindex="-1"> 打开文件</h2>
<p>Nu 在处理数据方面最强大的能力之一是<a href="/book/commands/open.html"><code>open</code></a>命令。它是一个多功能命令，可以处理许多不同的数据格式。为了说明这一点让我们试着打开一个 JSON 文件：</p>
<div><pre><code>> open editors/vscode/package.json
──────────────────┬───────────────────────────────────────────────────────────────────────────────
 name             │ lark
 description      │ Lark support for VS Code
 author           │ Lark developers
 license          │ MIT
 version          │ 1.0.0
 repository       │ [row type url]
 publisher        │ vscode
 categories       │ [table 0 rows]
 keywords         │ [table 1 rows]
 engines          │ [row vscode]
 activationEvents │ [table 1 rows]
 main             │ ./out/extension
 contributes      │ [row configuration grammars languages]
 scripts          │ [row compile postinstall test vscode:prepublish watch]
 devDependencies  │ [row @types/mocha @types/node tslint typescript vscode vscode-languageclient]
──────────────────┴───────────────────────────────────────────────────────────────────────────────
</code></pre></div><p>与<a href="/book/commands/ls.html"><code>ls</code></a>类似，打开一个 Nu 支持的文件类型，会返回一些不仅仅是文本（或一个字节流）的东西。这里我们打开了一个来自 JavaScript 项目的 &quot;package.json&quot; 文件。Nu 可以识别 JSON 文本并将其解析为一个数据表。</p>
<p>如果我们想查看当前项目的版本，我们可以使用<a href="/book/commands/get.html"><code>get</code></a>命令：</p>
<div><pre><code>> open editors/vscode/package.json | get version
1.0.0
</code></pre></div><p>Nu 目前支持直接从以下格式加载表数据：</p>
<ul>
<li>csv</li>
<li>eml</li>
<li>ics</li>
<li>ini</li>
<li>json</li>
<li>nuon</li>
<li>ods</li>
<li>ssv</li>
<li>toml</li>
<li>tsv</li>
<li>url</li>
<li>vcf</li>
<li>xlsx / xls</li>
<li>xml</li>
<li>yaml / yml</li>
</ul>
<p>但是，当你加载其他的文本文件时会发生什么呢？让我们试一试：</p>
<div><pre><code><span>></span> <span>open</span> README.md
</code></pre></div><p>我们会看到该文件的内容，如果文件太大则会得到一个方便的滚动视图来查看文件，然后再跳回终端。为了提高可读性，Nu 还将语法高亮显示常见的文件格式，如源码文件、Markdown 等等。</p>
<p>本质上，这些文本文件对 Nu 来说就是一个大字符串。接下来，我们将讨论如何处理这些字符串，以便从中获得我们需要的数据。</p>
<h2 id="处理字符串" tabindex="-1"> 处理字符串</h2>
<p>处理来自 Nu 外部数据时一个普遍情况是，它并不总是以 Nu 理解的格式出现。通常这些数据是以字符串的形式提供给我们的。</p>
<p>想象一下，我们得到了这个数据文件：</p>
<div><pre><code>> open people.txt
Octavia | Butler | Writer
Bob | Ross | Painter
Antonio | Vivaldi | Composer
</code></pre></div><p>我们想要的数据都由管道（<code>|</code>）符号隔开，每人单独一行。由于 Nu 没有默认的以管道分隔的文件格式，所以我们必须自己来解析。</p>
<p>当我们引入这个文件时，我们需要做的第一件事是确保后续每次只处理一行：</p>
<div><pre><code>> open people.txt | lines
───┬──────────────────────────────
 0 │ Octavia | Butler | Writer
 1 │ Bob | Ross | Painter
 2 │ Antonio | Vivaldi | Composer
───┴──────────────────────────────
</code></pre></div><p>可以看到，我们正在处理这些行，因为我们又回到了一个表中。下一步是看看是否可以把行分割成更有用的东西。为此，我们将使用<a href="/book/commands/split.html"><code>split</code></a>命令。<a href="/book/commands/split.html"><code>split</code></a>，顾名思义，为我们提供了一种分割字符串的方法。我们将使用<a href="/book/commands/split.html"><code>split</code></a>的<code>column</code>子命令，将内容分成多列。我们会告诉它分隔符是什么，剩下的就由它来完成：</p>
<div><pre><code>> open people.txt | lines | split column "|"
───┬──────────┬───────────┬───────────
 # │ column1  │ column2   │ column3
───┼──────────┼───────────┼───────────
 0 │ Octavia  │  Butler   │  Writer
 1 │ Bob      │  Ross     │  Painter
 2 │ Antonio  │  Vivaldi  │  Composer
───┴──────────┴───────────┴───────────
</code></pre></div><p>这看起来差不多了，只是还有一些额外的空白字符，让我们 <a href="/book/commands/str_trim.html"><code>trim</code></a> 掉这些空格：</p>
<div><pre><code>> open people.txt | lines | split column "|" | str trim
───┬─────────┬─────────┬──────────
 # │ column1 │ column2 │ column3
───┼─────────┼─────────┼──────────
 0 │ Octavia │ Butler  │ Writer
 1 │ Bob     │ Ross    │ Painter
 2 │ Antonio │ Vivaldi │ Composer
───┴─────────┴─────────┴──────────
</code></pre></div><p>还不错，<a href="/book/commands/split.html"><code>split</code></a>命令返回给我们可以使用的数据，还预设了默认的列名：</p>
<div><pre><code>> open people.txt | lines | split column "|" | str trim | get column1
───┬─────────
 0 │ Octavia
 1 │ Bob
 2 │ Antonio
───┴─────────
</code></pre></div><p>我们也可以用自定义的列名代替默认的：</p>
<div><pre><code>> open people.txt | lines | split column "|" first_name last_name job | str trim
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Octavia    │ Butler    │ Writer
 1 │ Bob        │ Ross      │ Painter
 2 │ Antonio    │ Vivaldi   │ Composer
───┴────────────┴───────────┴──────────
</code></pre></div><p>现在，我们的数据加载到一个表中了，我们可以使用之前对表所用的各种命令来处理它：</p>
<div><pre><code>> open people.txt | lines | split column "|" first_name last_name job | str trim | sort-by first_name
───┬────────────┬───────────┬──────────
 # │ first_name │ last_name │ job
───┼────────────┼───────────┼──────────
 0 │ Antonio    │ Vivaldi   │ Composer
 1 │ Bob        │ Ross      │ Painter
 2 │ Octavia    │ Butler    │ Writer
───┴────────────┴───────────┴──────────
</code></pre></div><p>其他可用于字符串的命令有：</p>
<ul>
<li><code>str</code></li>
<li><a href="/book/commands/lines.html"><code>lines</code></a></li>
<li><a href="/book/commands/size.html"><code>size</code></a></li>
</ul>
<p>如果我们已经知道待处理的数据具有 Nu 能够理解的格式，则可以使用一些辅助命令，例如，我们打开一个 Rust 的 Cargo.lock 文件：</p>
<div><pre><code>> open Cargo<span>.</span>lock
<span># This file is automatically @generated by Cargo.</span>
<span># It is not intended for manual editing.</span>
<span>[</span><span>[</span><span>package</span><span>]</span><span>]</span>
<span>name</span> <span>=</span> <span>"adhoc_derive"</span>
<span>version</span> <span>=</span> <span>"0.1.2"</span>
</code></pre></div><p>&quot;Cargo.lock&quot; 实际上是一个 .toml 文件，但是文件扩展名不是 .toml。没关系，我们可以使用 <code>from toml</code> 命令：</p>
<div><pre><code>> open Cargo.lock | from toml
──────────┬───────────────────
 metadata │ [row 107 columns]
 package  │ [table 130 rows]
──────────┴───────────────────
</code></pre></div><p>每种 Nu 能打开并理解的结构化数据文本格式都有对应的 <code>from</code> 命令可以使用，只需要把支持的格式作为子命令传给 <code>from</code> 就可以了。</p>
<h2 id="以原始模式打开" tabindex="-1"> 以原始模式打开</h2>
<p>虽然能够打开一个文件并立即使用其数据表很有帮助，但这并不总是我们想要的。为了获得原始文本，<a href="/book/commands/open.html"><code>open</code></a>命令可以接受一个可选的<code>--raw</code>标志：</p>
<div><pre><code>> open Cargo<span>.</span>toml --raw
<span>[</span><span>package</span><span>]</span>
<span>name</span> <span>=</span> <span>"nu"</span>
<span>version</span> <span>=</span> <span>"0.1.3"</span>
<span>authors</span> <span>=</span> <span>[</span><span>"Yehuda Katz &lt;wycats@gmail.com>"</span><span>,</span> <span>"Jonathan Turner &lt;jonathan.d.turner@gmail.com>"</span><span>]</span>
<span>description</span> <span>=</span> <span>"A shell for the GitHub era"</span>
<span>license</span> <span>=</span> <span>"MIT"</span>
</code></pre></div><h2 id="获取-urls" tabindex="-1"> 获取 URLs</h2>
<p>除了从文件系统中加载文件，你还可以通过使用<a href="/book/commands/fetch.html"><code>fetch</code></a>命令来加载 URLs。这将从互联网上获取 URL 的内容并返回：</p>
<div><pre><code>> fetch https://blog.rust-lang.org/feed.xml
──────┬───────────────────
 feed │ {record 2 fields}
──────┴───────────────────
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">元数据</title>
    <id>www.nushell.sh/zh-CN/book/metadata.html</id>
    <link href="www.nushell.sh/zh-CN/book/metadata.html"/>
    <updated>2022-06-04T13:17:54.512Z</updated>
    <content type="html"><![CDATA[<h1 id="元数据" tabindex="-1"> 元数据</h1>
<p>在使用 Nu 的过程中，你可能遇到过这样的情况：你觉得有一些额外的事情在幕后进行。例如，假设你试图打开一个 Nu 支持的文件，但却忘记了它已被 Nu 支持并试图再次转换：</p>
<div><pre><code>> open Cargo.toml | from toml
error: Expected a string from pipeline
- shell:1:18
1 | open Cargo.toml | from toml
  |                   ^^^^^^^^^ requires string input
- shell:1:5
1 | open Cargo.toml | from toml
  |      ---------- object originates from here
</code></pre></div><p>这个错误信息不仅告诉我们，我们给 <code>from toml</code> 的不是一个字符串，还告诉我们这个值最初来自哪里。那么它是如何知道的呢？</p>
<p>在 Nu 中流经管道的值通常有一些额外信息，或元数据，附加在它们身上。这些通常被称为标签，就像商店里商品上的标签一样。这些标签并不影响数据，但它们给了 Nu 一种方法来改善使用这些数据的体验。</p>
<p>让我们再次运行<a href="/book/commands/open.html"><code>open</code></a>命令，但这一次，我们将看一下它所反馈的标签：</p>
<div><pre><code>> open Cargo.toml | metadata
────────┬───────────────────────────────────────────
 span   │ {record 2 fields}
────────┴───────────────────────────────────────────
</code></pre></div><p>目前，我们只追踪值来自何处的起止范围(span)。让我们进一步仔细看看：</p>
<div><pre><code><span>></span> <span>open</span> Cargo.toml <span>|</span> metadata <span>|</span> get span
───────┬────
 start │ <span>5</span>
 end   │ <span>15</span>
───────┴────
</code></pre></div><p>这里的范围 &quot;start&quot; 和 &quot;end&quot; 指的是下划线将标记在行中的位置。如果你数到 5，然后再数到 15，就会看到它与 &quot;Cargo.toml&quot; 文件名一致。这就是我们之前看到的错误是如何知道在何处标注下划线的。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">模块</title>
    <id>www.nushell.sh/zh-CN/book/modules.html</id>
    <link href="www.nushell.sh/zh-CN/book/modules.html"/>
    <updated>2022-06-04T13:17:54.512Z</updated>
    <content type="html"><![CDATA[<h1 id="模块" tabindex="-1"> 模块</h1>
<p>与其他许多编程语言类似，Nushell 也有模块，可以让你将自定义的命令导入到当前作用域中。
然而，由于 Nushell 也是一个 Shell，模块还允许你导入环境变量，可以用来方便地激活/停用各种环境配置。</p>
<p><em>注意! 目前对模块的实现是相当基本的，并将在未来进一步扩展。例如，目前还不能从一个模块中导入另一个模块。</em></p>
<h2 id="基础知识" tabindex="-1"> 基础知识</h2>
<p>一个简单的模块可以像这样定义：</p>
<div><pre><code><span>></span> module greetings <span>{</span>
     <span>export</span> def hello <span>[</span>name: string<span>]</span> <span>{</span>
         $<span>"hello (<span>$name</span>)!"</span>
     <span>}</span>

     <span>export</span> def hi <span>[</span>where: string<span>]</span> <span>{</span>
         $<span>"hi (<span>$where</span>)!"</span>
     <span>}</span>
<span>}</span>
</code></pre></div><p>或者在一个与你要创建的模块名相同的文件中：</p>
<div><pre><code><span># greetings.nu</span>

<span>export</span> def hello <span>[</span>name: string<span>]</span> <span>{</span>
    $<span>"hello (<span>$name</span>)!"</span>
<span>}</span>

<span>export</span> def hi <span>[</span>where: string<span>]</span> <span>{</span>
    $<span>"hi (<span>$where</span>)!"</span>
<span>}</span>
</code></pre></div><p>我们在 <code>greetings</code> 模块中定义了 <code>hello</code> 和 <code>hi</code> 两个自定义命令。<code>export</code>关键字使得以后可以从模块中导入该命令。</p>
<p>与<a href="/book/commands/def.html"><code>def</code></a>类似，也可以用<code>export</code>关键字标记<a href="/book/commands/def-env.html"><code>def-env</code></a>（你可以在<a href="/zh-CN/book/environment.html">环境</a>章节中了解更多关于<a href="/book/commands/def-env.html"><code>def-env</code></a>的信息）。</p>
<h2 id="使用模块" tabindex="-1"> 使用模块</h2>
<p>模块本身并不做任何事情，要使用模块导出的定义，我们需要<a href="/book/commands/use.html"><code>use</code></a>它：</p>
<div><pre><code><span>></span> use greetings

<span>></span> greetings hello <span>"world"</span>
hello world<span>!</span>

<span>></span> greetings hi <span>"there"</span>
hi there<span>!</span>
</code></pre></div><p><code>hello</code>和<code>hi</code>命令现在可以通过<code>greetings</code>前缀被调用。</p>
<h2 id="导入符号" tabindex="-1"> 导入符号</h2>
<p>一般来说，<a href="/book/commands/use.html"><code>use</code></a>关键词后面的任何内容都会形成一个<strong>导入模式</strong>，它控制着符号的导入方式。
导入模式可以是以下的一种：</p>
<p><code>use greetings</code></p>
<p>导入所有以模块名称为前缀的符号（我们在前面的例子中看到了这个）。</p>
<p><code>use greetings hello</code></p>
<p><code>hello</code>符号将被直接导入，没有任何前缀。</p>
<p><code>use greetings [ hello, hi ] </code></p>
<p>直接导入多个符号，没有任何前缀。</p>
<p><code>use greetings *</code></p>
<p>你也可以使用模块名称和<code>*</code> glob 来直接导入所有的名称，且不需要任何前缀。</p>
<h2 id="模块文件" tabindex="-1"> 模块文件</h2>
<p>Nushell 让你隐含地把一个源文件当作一个模块。
让我们先把模块定义的主体保存到一个文件中：</p>
<div><pre><code><span># greetings.nu</span>

<span>export</span> def hello <span>[</span>name: string<span>]</span> <span>{</span>
    $<span>"hello (<span>$name</span>)!"</span>
<span>}</span>

<span>export</span> def hi <span>[</span>where: string<span>]</span> <span>{</span>
    $<span>"hi (<span>$where</span>)!"</span>
<span>}</span>
</code></pre></div><p>现在，你可以直接在文件上调用<a href="/book/commands/use.html"><code>use</code></a>：</p>
<div><pre><code><span>></span> use greetings.nu

<span>></span> greetings hello <span>"world"</span>
hello world<span>!</span>

<span>></span> greetings hi <span>"there"</span>
hi there<span>!</span>
</code></pre></div><p>Nushell 会自动从文件名（&quot;greetings&quot;，没有&quot;.nu&quot;扩展名）推断出模块的名称。所以你可以通过文件名而不是模块名配合使用上述任何导入模式来完成导入。</p>
<h2 id="本地自定义命令" tabindex="-1"> 本地自定义命令</h2>
<p>任何在模块中定义的自定义命令，如果没有<code>export</code>关键字，将只在该模块的作用域内工作：</p>
<div><pre><code><span># greetings.nu</span>

<span>export</span> def hello <span>[</span>name: string<span>]</span> <span>{</span>
    greetings-helper <span>"hello"</span> <span>"world"</span>
<span>}</span>

<span>export</span> def hi <span>[</span>where: string<span>]</span> <span>{</span>
    greetings-helper <span>"hi"</span> <span>"there"</span>
<span>}</span>

def greetings-helper <span>[</span>greeting: string, subject: string<span>]</span> <span>{</span>
    $<span>"(<span>$greeting</span>) (<span>$subject</span>)!"</span>
<span>}</span>
</code></pre></div><p>然后，在 Nushell 里我们可以从 &quot;greetings.nu&quot; 中导入所有定义：</p>
<div><pre><code><span>></span> use greetings.nu *

<span>></span> hello <span>"world"</span>
hello world<span>!</span>

<span>></span> hi <span>"there"</span>
hi there<span>!</span>

<span>></span> greetings-helper <span>"foo"</span> <span>"bar"</span>  <span># fails because 'greetings-helper' is not exported</span>
</code></pre></div><h2 id="环境变量" tabindex="-1"> 环境变量</h2>
<p>到目前为止，我们只是用模块来导入自定义命令，用同样的方法导出环境变量也是可能的。
其语法与你可能习惯的<a href="/book/commands/let-env.html"><code>let-env</code></a>或<a href="/book/commands/load-env.html"><code>load-env</code></a>等命令略有不同：</p>
<div><pre><code><span># greetings.nu</span>

<span>export</span> <span>env</span> MYNAME <span>{</span> <span>"Arthur, King of the Britons"</span> <span>}</span>

<span>export</span> def hello <span>[</span>name: string<span>]</span> <span>{</span>
    $<span>"hello (<span>$name</span>)"</span>
<span>}</span>
</code></pre></div><p><code>use</code> 的工作方式与自定义命令相同：</p>
<div><pre><code><span>></span> use greetings.nu

<span>></span> <span>$env</span><span>.</span><span>"greetings MYNAME"</span>
Arthur, King of the Britons

<span>></span> greetings hello <span>$env</span><span>.</span><span>"greetings MYNAME"</span>
hello Arthur, King of the Britons<span>!</span>
</code></pre></div><p>你可能注意到我们没有直接给<code>MYNAME</code>赋值，相反，我们给了它一个代码块（<code>{ ...}</code>），它在我们每次调用<a href="/book/commands/use.html"><code>use</code></a>时都会被执行。例如，我们可以用<a href="/book/commands/random.html"><code>random</code></a>命令来演示这一点：</p>
<div><pre><code><span>></span> module roll <span>{</span> <span>export</span> <span>env</span> ROLL <span>{</span> random dice <span>|</span> into string <span>}</span> <span>}</span>

<span>></span> use roll ROLL

<span>></span> <span>$env</span>.ROLL
<span>4</span>

<span>></span> <span>$env</span>.ROLL
<span>4</span>

<span>></span> use roll ROLL

<span>></span> <span>$env</span>.ROLL
<span>6</span>

<span>></span> <span>$env</span>.ROLL
<span>6</span>
</code></pre></div><h2 id="导出符号" tabindex="-1"> 导出符号</h2>
<p>如上所述，你可以从模块中导出定义和环境变量。这可以让你更容易地将相关的定义分组，并导出你想公开的定义。</p>
<p>你还可以导出别名和外部声明(extern)，并在需要时才使用这些功能。导出外部声明也让你有能力隐藏模块中的自定义自动补全命令，这样它们就不必成为全局命名空间的一部分。</p>
<p>下面是所有你可以导出的列表：</p>
<ul>
<li><code>export def</code> - 导出一个自定义命令</li>
<li><code>export def-env</code> - 导出一个自定义环境命令</li>
<li><code>export env</code> - 导出一个环境变量</li>
<li><code>export alias</code> - 导出一个别名</li>
<li><code>export extern</code> - 导出一个已知外部命令的定义</li>
</ul>
<h2 id="隐藏" tabindex="-1"> 隐藏</h2>
<p>任何自定义命令、别名或环境变量, 无论是否从模块中导入, 都可以被 &quot;隐藏&quot;, 以恢复之前的定义。
(注意，现在还不能从模块中导出别名，但它们仍然可以被隐藏。)
我们用<a href="/book/commands/hide.html"><code>hide</code></a>命令来实现隐藏：</p>
<div><pre><code><span>></span> def foo <span>[</span><span>]</span> <span>{</span> <span>"foo"</span> <span>}</span>

<span>></span> foo
foo

<span>></span> hide foo

<span>></span> foo  <span># error! command not found!</span>
</code></pre></div><p><a href="/book/commands/hide.html"><code>hide</code></a>命令也接受导入模式，就像<a href="/book/commands/use.html"><code>use</code></a>那样。不过，导入模式的解释略有不同。它可以是下面中的一种：</p>
<p><code>hide foo</code> 或者 <code>hide greetings</code></p>
<ul>
<li>如果该名称是一个自定义的命令或环境变量，则直接隐藏它。否则：</li>
<li>如果名字是一个模块的名称，则隐藏所有以模块名称为前缀的导出。</li>
</ul>
<p><code>hide greetings hello</code></p>
<ul>
<li>隐藏带前缀的命令或环境变量</li>
</ul>
<p><code>hide greetings [hello, hi]</code></p>
<ul>
<li>隐藏带前缀的若干个命令或环境变量</li>
</ul>
<p><code>hide greetings *</code></p>
<ul>
<li>隐藏模块的所有的导出，不含前缀</li>
</ul>
<p>让我们看几个例子。前面已经看到了直接隐藏一个自定义命令的例子，现在让我们试试环境变量：</p>
<div><pre><code><span>></span> let-env FOO <span>=</span> <span>"FOO"</span>

<span>></span> <span>$env</span>.FOO
FOO

<span>></span> hide FOO

<span>></span> <span>$env</span>.FOO  <span># error! environment variable not found!</span>
</code></pre></div><p>第一种情况也适用于从一个模块导入的命令/环境变量（使用上面定义的 &quot;greetings.nu&quot; 文件）：</p>
<div><pre><code><span>></span> use greetings.nu *

<span>></span> <span>$env</span>.MYNAME
Arthur, King of the Britons

<span>></span> hello <span>"world"</span>
hello world<span>!</span>

<span>></span> hide MYNAME

<span>></span> <span>$env</span>.MYNAME  <span># error! environment variable not found!</span>

<span>></span> hide hello

<span>></span> hello <span>"world"</span> <span># error! command not found!</span>
</code></pre></div><p>最后，当名称为模块名时（假设是之前的<code>greetings</code>模块）：</p>
<div><pre><code><span>></span> use greetings.nu

<span>></span> <span>$env</span><span>.</span><span>"greetings MYNAME"</span>
Arthur, King of the Britons

<span>></span> greetings hello <span>"world"</span>
hello world<span>!</span>

<span>></span> hide greetings

<span>></span> <span>$env</span><span>.</span><span>"greetings MYNAME"</span>  <span># error! environment variable not found!</span>

<span>></span> greetings hello <span>"world"</span> <span># error! command not found!</span>
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">在系统中四处移动</title>
    <id>www.nushell.sh/zh-CN/book/moving_around.html</id>
    <link href="www.nushell.sh/zh-CN/book/moving_around.html"/>
    <updated>2022-06-04T13:17:54.513Z</updated>
    <content type="html"><![CDATA[<h1 id="在系统中四处移动" tabindex="-1"> 在系统中四处移动</h1>
<p>早期的 Shell 允许你在文件系统中进行目录跳转并运行命令，而现代的 Shell 如 Nu 也允许你这样做。让我们来看看你在与系统交互时可能会用到的一些常用命令。</p>
<h2 id="查看目录内容" tabindex="-1"> 查看目录内容</h2>
<div><pre><code><span>></span> <span>ls</span>
</code></pre></div><p>正如我们在其他章节中所看到的，<a href="/book/commands/ls.html"><code>ls</code></a>是一个用于查看路径内容的命令。Nu 将以表格的形式返回内容并供我们使用。</p>
<p><a href="/book/commands/ls.html"><code>ls</code></a>命令还需要一个可选的参数，以改变你想查看的内容。例如，我们可以列出以 &quot;.md &quot; 结尾的文件：</p>
<div><pre><code><span>></span> <span>ls</span> *.md
───┬────────────────────┬──────┬─────────┬────────────
 <span># │ name               │ type │ size    │ modified </span>
───┼────────────────────┼──────┼─────────┼────────────
 <span>0</span> │ CODE_OF_CONDUCT.md │ File │  <span>3.4</span> KB │ <span>5</span> days ago 
 <span>1</span> │ CONTRIBUTING.md    │ File │   <span>886</span> B │ <span>5</span> days ago 
 <span>2</span> │ README.md          │ File │ <span>15.0</span> KB │ <span>5</span> days ago 
 <span>3</span> │ TODO.md            │ File │  <span>1.6</span> KB │ <span>5</span> days ago 
───┴────────────────────┴──────┴─────────┴────────────
</code></pre></div><p>上述可选参数 &quot;<strong>*.md</strong>&quot; 中的星号（*）有时被称为通配符或 Glob，它让我们可以匹配任何东西。你可以把 glob &quot;*.md&quot; 理解为 &quot;匹配以 '.md' 结尾的任何文件名&quot;</p>
<p>Nu 也使用现代 Globs，它允许你访问更深的目录：</p>
<div><pre><code> <span>ls</span> **/*.md
────┬───────────────────────────────────────────┬──────┬─────────┬────────────
 <span>#  │ name                                      │ type │ size    │ modified </span>
────┼───────────────────────────────────────────┼──────┼─────────┼────────────
  <span>0</span> │ .github/ISSUE_TEMPLATE/bug_report.md      │ File │   <span>592</span> B │ <span>5</span> days ago 
  <span>1</span> │ .github/ISSUE_TEMPLATE/feature_request.md │ File │   <span>595</span> B │ <span>5</span> days ago 
  <span>2</span> │ CODE_OF_CONDUCT.md                        │ File │  <span>3.4</span> KB │ <span>5</span> days ago 
  <span>3</span> │ CONTRIBUTING.md                           │ File │   <span>886</span> B │ <span>5</span> days ago 
  <span>4</span> │ README.md                                 │ File │ <span>15.0</span> KB │ <span>5</span> days ago 
  <span>5</span> │ TODO.md                                   │ File │  <span>1.6</span> KB │ <span>5</span> days ago 
  <span>6</span> │ crates/nu-source/README.md                │ File │  <span>1.7</span> KB │ <span>5</span> days ago 
  <span>7</span> │ docker/packaging/README.md                │ File │  <span>1.5</span> KB │ <span>5</span> days ago 
  <span>8</span> │ docs/commands/README.md                   │ File │   <span>929</span> B │ <span>5</span> days ago 
  <span>9</span> │ docs/commands/alias.md                    │ File │  <span>1.7</span> KB │ <span>5</span> days ago 
 <span>10</span> │ docs/commands/append.md                   │ File │  <span>1.4</span> KB │ <span>5</span> days ago
</code></pre></div><p>在这里，我们要寻找任何以&quot;.md&quot; 结尾的文件，两个星号进一步表示 &quot;从这里开始的任何目录中&quot;。</p>
<h2 id="改变当前目录" tabindex="-1"> 改变当前目录</h2>
<div><pre><code><span>></span> <span>cd</span> new_directory
</code></pre></div><p>要从当前目录换到一个新目录，我们使用<code>cd</code>命令。就像在其他 Shells 中一样，我们可以使用目录的名称，或者如果我们想进入父目录，我们可以使用<code>..</code>的快捷方式。</p>
<p>如果<code>cd</code>被省略，只给出一个路径本身，也可以改变当前工作目录：</p>
<div><pre><code><span>></span> ./new_directory
</code></pre></div><p><strong>注意：</strong> 用<code>cd</code>改变目录会改变<code>PWD</code>环境变量。这意味着目录的改变会保留到当前代码块中，一旦你退出这个代码块，你就会返回到以前的目录。你可以在 <a href="/zh-CN/book/environment.html">环境篇</a> 中了解更多关于这方面的信息。</p>
<h2 id="文件系统命令" tabindex="-1"> 文件系统命令</h2>
<p>Nu 还提供了一些基本的文件系统命令，并且可以跨平台工作。</p>
<p>我们可以使用<code>mv</code>命令将一个目录或文件从一个地方移动到另一个地方：</p>
<div><pre><code><span>></span> <span>mv</span> item location
</code></pre></div><p>我们可以把一个目录或文件从一个地方复制到另一个地方：</p>
<div><pre><code><span>></span> <span>cp</span> item location
</code></pre></div><p>我们也可以删除一个目录或文件：</p>
<div><pre><code><span>></span> <span>rm</span> item
</code></pre></div><p>这三个命令也可以使用我们先前看到的<a href="/book/commands/ls.html"><code>ls</code></a>的 Glob 功能。</p>
<p>最后，我们可以使用<code>mkdir</code>命令创建一个新目录：</p>
<div><pre><code><span>></span> <span>mkdir</span> new_directory
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">从其他 Shell 或 DSL 到 Nu</title>
    <id>www.nushell.sh/zh-CN/book/nushell_map.html</id>
    <link href="www.nushell.sh/zh-CN/book/nushell_map.html"/>
    <updated>2022-06-04T13:17:54.513Z</updated>
    <content type="html"><![CDATA[<h1 id="从其他-shell-或-dsl-到-nu" tabindex="-1"> 从其他 Shell 或 DSL 到 Nu</h1>
<p>这个表格背后的想法是帮助你了解 Nu 的内置和插件所提供命令与其他已知的 Shell 和特定领域语言(DSL)的关系。我们试图制作一张所有 Nu 命令和它们在其他语言中的对应关系的表。欢迎大家参与贡献。</p>
<p>注意：此表针对 Nu 0.43 或更高版本。</p>
<table>
<thead>
<tr>
<th>Nushell</th>
<th>SQL</th>
<th>.Net LINQ (C#)</th>
<th>PowerShell (without external modules)</th>
<th>Bash</th>
</tr>
</thead>
<tbody>
<tr>
<td>alias</td>
<td>-</td>
<td>-</td>
<td>alias</td>
<td>alias</td>
</tr>
<tr>
<td>append</td>
<td>-</td>
<td>Append</td>
<td>-Append</td>
<td></td>
</tr>
<tr>
<td>args</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>autoview</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>math avg</td>
<td>avg</td>
<td>Average</td>
<td>Measure-Object, measure</td>
<td></td>
</tr>
<tr>
<td>calc, <code>&lt;math expression&gt;</code></td>
<td>math operators</td>
<td>Aggregate, Average, Count, Max, Min, Sum</td>
<td></td>
<td>bc</td>
</tr>
<tr>
<td>cd</td>
<td>-</td>
<td>-</td>
<td>Set-Location, cd</td>
<td>cd</td>
</tr>
<tr>
<td>clear</td>
<td>-</td>
<td>-</td>
<td>Clear-Host</td>
<td>clear</td>
</tr>
<tr>
<td>compact</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>config</td>
<td>-</td>
<td>-</td>
<td>$Profile</td>
<td>vi .bashrc, .profile</td>
</tr>
<tr>
<td>count</td>
<td>count</td>
<td>Count</td>
<td>Measure-Object, measure</td>
<td>wc</td>
</tr>
<tr>
<td>cp</td>
<td>-</td>
<td>-</td>
<td>Copy-Item, cp, copy</td>
<td>cp</td>
</tr>
<tr>
<td>date</td>
<td>NOW() / getdate()</td>
<td>DateTime class</td>
<td>Get-Date</td>
<td>date</td>
</tr>
<tr>
<td>debug</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>drop</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>du</td>
<td>-</td>
<td>-</td>
<td></td>
<td>du</td>
</tr>
<tr>
<td>each</td>
<td>cursor</td>
<td></td>
<td>ForEach-Object, foreach, for</td>
<td></td>
</tr>
<tr>
<td>echo</td>
<td>print, union all</td>
<td>-</td>
<td>Write-Output, write</td>
<td>echo</td>
</tr>
<tr>
<td>enter</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>exit</td>
<td>-</td>
<td></td>
<td>exit</td>
<td>exit</td>
</tr>
<tr>
<td>fetch</td>
<td>-</td>
<td>HttpClient,WebClient, HttpWebRequest/Response</td>
<td>Invoke-WebRequest</td>
<td>wget</td>
</tr>
<tr>
<td>first</td>
<td>top, limit</td>
<td>First, FirstOrDefault</td>
<td>Select-Object -First</td>
<td>head</td>
</tr>
<tr>
<td>format</td>
<td></td>
<td>String.Format</td>
<td>String.Format</td>
<td></td>
</tr>
<tr>
<td>from</td>
<td>import flatfile, openjson, cast(variable as xml)</td>
<td>-</td>
<td>Import/ConvertFrom-{Csv,Xml,Html,Json}</td>
<td></td>
</tr>
<tr>
<td>get</td>
<td></td>
<td>Select</td>
<td>(cmd).column</td>
<td></td>
</tr>
<tr>
<td>group-by</td>
<td>group by</td>
<td>GroupBy, group</td>
<td>Group-Object, group</td>
<td></td>
</tr>
<tr>
<td>headers</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>help</td>
<td>sp_help</td>
<td>-</td>
<td>Get-Help, help, man</td>
<td>man</td>
</tr>
<tr>
<td>histogram</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>history</td>
<td>-</td>
<td>-</td>
<td>Get-History, history</td>
<td>history</td>
</tr>
<tr>
<td>inc(<code>*</code>)</td>
<td>-</td>
<td></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>is_empty</td>
<td>is null</td>
<td>String.InNullOrEmpty</td>
<td>String.InNullOrEmpty</td>
<td></td>
</tr>
<tr>
<td>keep, =take</td>
<td>top, limit</td>
<td>Take</td>
<td>Select-Object -First</td>
<td>head</td>
</tr>
<tr>
<td>keep-until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>keep-while</td>
<td></td>
<td>TakeWhile</td>
<td></td>
<td></td>
</tr>
<tr>
<td>kill</td>
<td>-</td>
<td>-</td>
<td>Stop-Process, kill</td>
<td>kill</td>
</tr>
<tr>
<td>last</td>
<td></td>
<td>Last, LastOrDefault</td>
<td>Select-Object -Last</td>
<td>tail</td>
</tr>
<tr>
<td>lines</td>
<td>-</td>
<td>-</td>
<td>File.ReadAllLines</td>
<td></td>
</tr>
<tr>
<td>ls</td>
<td>-</td>
<td>-</td>
<td>Get-ChildItem, dir, ls</td>
<td>ls</td>
</tr>
<tr>
<td>match(<code>*</code>)</td>
<td>case when</td>
<td>Regex.IsMatch</td>
<td>[regex]</td>
<td></td>
</tr>
<tr>
<td>merge</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mkdir</td>
<td>-</td>
<td>-</td>
<td>mkdir, md</td>
<td>mkdir</td>
</tr>
<tr>
<td>mv</td>
<td>-</td>
<td>-</td>
<td>Move-Item, mv, move, mi</td>
<td>mv</td>
</tr>
<tr>
<td>next</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nth</td>
<td>limit x offset y, rownumber =</td>
<td>ElementAt</td>
<td>[x], indexing operator, ElementAt</td>
<td></td>
</tr>
<tr>
<td>open</td>
<td></td>
<td></td>
<td>Get-Content, gc, cat, type</td>
<td>cat</td>
</tr>
<tr>
<td>parse</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transpose</td>
<td>pivot</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>post(<code>*</code>)</td>
<td>-</td>
<td>HttpClient,WebClient, HttpWebRequest/Response</td>
<td>Invoke-WebRequest</td>
<td></td>
</tr>
<tr>
<td>prepend</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ps(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>Get-Process, ps, gps</td>
<td>ps</td>
</tr>
<tr>
<td>pwd</td>
<td>-</td>
<td>-</td>
<td>Get-Location, pwd</td>
<td>pwd</td>
</tr>
<tr>
<td>range</td>
<td></td>
<td>Range</td>
<td>1..10, 'a'..'f'</td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td></td>
<td>Aggregate</td>
<td></td>
<td></td>
</tr>
<tr>
<td>reject</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rename</td>
<td>-</td>
<td>-</td>
<td>Rename-Item, ren, rni</td>
<td>mv</td>
</tr>
<tr>
<td>reverse</td>
<td></td>
<td>Reverse</td>
<td>[Array]::Reverse($var)</td>
<td></td>
</tr>
<tr>
<td>rm</td>
<td>-</td>
<td>-</td>
<td>Remove-Item, del, erase, rd, ri, rm, rmdir</td>
<td>rm</td>
</tr>
<tr>
<td>save</td>
<td>-</td>
<td>-</td>
<td>Write-Output, Out-File</td>
<td>&gt; foo.txt</td>
</tr>
<tr>
<td>select</td>
<td>select</td>
<td>Select</td>
<td>Select-Object, select</td>
<td></td>
</tr>
<tr>
<td>shells</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>shuffle</td>
<td></td>
<td>Random</td>
<td>Sort-Object {Get-Random}</td>
<td>-</td>
</tr>
<tr>
<td>size</td>
<td></td>
<td></td>
<td>Measure-Object, measure</td>
<td>wc</td>
</tr>
<tr>
<td>skip</td>
<td>where row_number()</td>
<td>Skip</td>
<td>Select-Object -Skip</td>
<td></td>
</tr>
<tr>
<td>skip until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip while</td>
<td></td>
<td>SkipWhile</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sort-by</td>
<td>order by</td>
<td>OrderBy, OrderByDescending, ThenBy, ThenByDescending</td>
<td>Sort-Object, sort</td>
<td></td>
</tr>
<tr>
<td>split-by</td>
<td></td>
<td>Split</td>
<td>Split</td>
<td></td>
</tr>
<tr>
<td>split column</td>
<td></td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>split row</td>
<td></td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>str(<code>*</code>)</td>
<td>string functions</td>
<td>String class</td>
<td>String class</td>
<td></td>
</tr>
<tr>
<td>str collect</td>
<td>concat_ws</td>
<td>Join</td>
<td>Join-String</td>
<td></td>
</tr>
<tr>
<td>str trim</td>
<td>rtrim, ltrim</td>
<td>Trim, TrimStart, TrimEnd</td>
<td>Trim</td>
<td></td>
</tr>
<tr>
<td>sum</td>
<td>sum</td>
<td>Sum</td>
<td>Measure-Object, measure</td>
<td></td>
</tr>
<tr>
<td>sys(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>Get-ComputerInfo</td>
<td>uname, lshw, lsblk, lscpu, lsusb, hdparam, free</td>
</tr>
<tr>
<td>table</td>
<td></td>
<td></td>
<td>Format-Table, ft, Format-List, fl</td>
<td></td>
</tr>
<tr>
<td>tags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>textview(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>Get-Content, cat</td>
<td></td>
</tr>
<tr>
<td>tree(<code>*</code>)</td>
<td>-</td>
<td>-</td>
<td>tree</td>
<td></td>
</tr>
<tr>
<td>to</td>
<td>-</td>
<td>-</td>
<td>Export/ConvertTo-{Csv,Xml,Html,Json}</td>
<td></td>
</tr>
<tr>
<td>touch</td>
<td>-</td>
<td>-</td>
<td>Set-Content</td>
<td>touch</td>
</tr>
<tr>
<td>uniq</td>
<td>distinct</td>
<td>Distinct</td>
<td>Get-Unique, gu</td>
<td>uniq</td>
</tr>
<tr>
<td>upsert</td>
<td>As</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>version</td>
<td>select @@version</td>
<td>-</td>
<td>$PSVersionTable</td>
<td></td>
</tr>
<tr>
<td>with_env</td>
<td>-</td>
<td>-</td>
<td>$env:FOO = 'bar'</td>
<td>export foo = &quot;bar&quot;</td>
</tr>
<tr>
<td>where</td>
<td>where</td>
<td>Where</td>
<td>Where-Object, where, &quot;?&quot; operator</td>
<td></td>
</tr>
<tr>
<td>which</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>which</td>
</tr>
<tr>
<td>wrap</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><code>*</code> - 这些命令是标准插件的一部分</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html">从函数式语言到 Nu</title>
    <id>www.nushell.sh/zh-CN/book/nushell_map_functional.html</id>
    <link href="www.nushell.sh/zh-CN/book/nushell_map_functional.html"/>
    <updated>2022-06-04T13:17:54.514Z</updated>
    <content type="html"><![CDATA[<h1 id="从函数式语言到-nu" tabindex="-1"> 从函数式语言到 Nu</h1>
<p>这个表格的目的是帮助你了解 Nu 的内置和插件所提供命令与函数式语言的关系。我们试图制作一张所有 Nu 命令和它们在其他语言中的映射关系的表。欢迎大家参与贡献。</p>
<p>注意：此表针对 Nu 0.43 或更高版本。</p>
<table>
<thead>
<tr>
<th>Nushell</th>
<th>Clojure</th>
<th>Tablecloth (Ocaml / Elm)</th>
<th>Haskell</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>alias</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>append</td>
<td>conj, into, concat</td>
<td>append, (++), concat, concatMap</td>
<td>(++)</td>
<td></td>
</tr>
<tr>
<td>args</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>autoview</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>math avg</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>into binary</td>
<td>Integer/toHexString</td>
<td></td>
<td>showHex</td>
<td></td>
</tr>
<tr>
<td>calc, <code>&lt;math expression&gt;</code></td>
<td>math operators</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>cd</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>clear</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>clip</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>compact</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>config</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>count</td>
<td>count</td>
<td>length, size</td>
<td>length, size</td>
<td></td>
</tr>
<tr>
<td>cp</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>java.time.LocalDate/now</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>debug</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>drop</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>du</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>each</td>
<td>map, mapv, iterate</td>
<td>map, forEach</td>
<td>map</td>
<td></td>
</tr>
<tr>
<td>echo</td>
<td>println</td>
<td></td>
<td>putStrLn, print</td>
<td></td>
</tr>
<tr>
<td>enter</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>exit</td>
<td>System/exit</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fetch(<code>*</code>)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>first</td>
<td>first</td>
<td>head</td>
<td>head</td>
<td></td>
</tr>
<tr>
<td>format</td>
<td>format</td>
<td></td>
<td>Text.Printf.printf</td>
<td></td>
</tr>
<tr>
<td>from</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>get</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>group-by</td>
<td>group-by</td>
<td></td>
<td>group, groupBy</td>
<td></td>
</tr>
<tr>
<td>headers</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>help</td>
<td>doc</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>histogram</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>history</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>inc(<code>*</code>)</td>
<td>inc</td>
<td></td>
<td>succ</td>
<td></td>
</tr>
<tr>
<td>insert</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>empty?</td>
<td>empty?</td>
<td>isEmpty</td>
<td></td>
<td></td>
</tr>
<tr>
<td>keep</td>
<td>take, drop-last, pop</td>
<td>take, init</td>
<td>take, init</td>
<td></td>
</tr>
<tr>
<td>keep-until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>keep-while</td>
<td>take-while</td>
<td>takeWhile</td>
<td>takeWhile</td>
<td></td>
</tr>
<tr>
<td>kill</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>last</td>
<td>last, peek, take-last</td>
<td>last</td>
<td>last</td>
<td></td>
</tr>
<tr>
<td>lines</td>
<td></td>
<td></td>
<td>lines, words, split-with</td>
<td></td>
</tr>
<tr>
<td>ls</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>match(<code>*</code>)</td>
<td>re-matches, re-seq, re-find</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>merge</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mkdir</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mv</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>next</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nth</td>
<td>nth</td>
<td>Array.get</td>
<td>lookup</td>
<td></td>
</tr>
<tr>
<td>open</td>
<td>with-open</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>parse</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transpose</td>
<td>(apply mapv vector matrix)</td>
<td></td>
<td>transpose</td>
<td></td>
</tr>
<tr>
<td>post(<code>*</code>)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>prepend</td>
<td>cons</td>
<td>cons, ::</td>
<td>::</td>
<td></td>
</tr>
<tr>
<td>prev</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ps</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pwd</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>range, 1..10</td>
<td>range</td>
<td>range</td>
<td>1..10, 'a'..'f'</td>
<td></td>
</tr>
<tr>
<td>reduce</td>
<td>reduce, reduce-kv</td>
<td>foldr</td>
<td>foldr</td>
<td></td>
</tr>
<tr>
<td>reject</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rename</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reverse</td>
<td>reverse, rseq</td>
<td>reverse, reverseInPlace</td>
<td>reverse</td>
<td></td>
</tr>
<tr>
<td>rm</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>save</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>select</td>
<td>select-keys</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>shells</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>shuffle</td>
<td>shuffle</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>count</td>
<td></td>
<td>size, length</td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>rest</td>
<td>tail</td>
<td>tail</td>
<td></td>
</tr>
<tr>
<td>skip until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip while</td>
<td>drop-while</td>
<td>dropWhile</td>
<td>dropWhile, dropWhileEnd</td>
<td></td>
</tr>
<tr>
<td>sort-by</td>
<td>sort, sort-by, sorted-set-by</td>
<td>sort, sortBy, sortWith</td>
<td>sort, sortBy</td>
<td></td>
</tr>
<tr>
<td>split-by</td>
<td>split, split-{at,with,lines}</td>
<td>split, words, lines</td>
<td>split, words, lines</td>
<td></td>
</tr>
<tr>
<td>split column</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>split row</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>str(<code>*</code>)</td>
<td>clojure.string functions</td>
<td>String functions</td>
<td></td>
<td></td>
</tr>
<tr>
<td>str collect</td>
<td>join</td>
<td>concat</td>
<td>intercalate</td>
<td></td>
</tr>
<tr>
<td>str trim</td>
<td>trim, triml, trimr</td>
<td>trim, trimLeft, trimRight</td>
<td>strip</td>
<td></td>
</tr>
<tr>
<td>sum</td>
<td>apply +</td>
<td>sum</td>
<td>sum</td>
<td></td>
</tr>
<tr>
<td>sys</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>table</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tree(<code>*</code>)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>to</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>touch</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>uniq</td>
<td>set</td>
<td>Set.empty</td>
<td>Data.Set</td>
<td></td>
</tr>
<tr>
<td>upsert</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>version</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>with_env</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>what</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>where</td>
<td>filter, filterv, select</td>
<td>filter, filterMap</td>
<td>filter</td>
<td></td>
</tr>
<tr>
<td>which</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>wrap</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><code>*</code> - 这些命令是标准插件的一部分</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html">从命令式语言到 Nu</title>
    <id>www.nushell.sh/zh-CN/book/nushell_map_imperative.html</id>
    <link href="www.nushell.sh/zh-CN/book/nushell_map_imperative.html"/>
    <updated>2022-06-04T13:17:54.514Z</updated>
    <content type="html"><![CDATA[<h1 id="从命令式语言到-nu" tabindex="-1"> 从命令式语言到 Nu</h1>
<p>这个表格的目的是帮助你了解 Nu 的内置和插件所提供的命令与命令式语言的关系。我们试图制作一张所有 Nu 命令和它们在其他语言中的对应关系的表。欢迎大家参与贡献。</p>
<p>注意：此表假设 Nu 0.43 或更高版本。</p>
<table>
<thead>
<tr>
<th>Nushell</th>
<th>Python</th>
<th>Kotlin (Java)</th>
<th>C++</th>
<th>Rust</th>
</tr>
</thead>
<tbody>
<tr>
<td>alias</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>append</td>
<td>list.append, set.add</td>
<td>add</td>
<td>push_back, emplace_back</td>
<td>push, push_back</td>
</tr>
<tr>
<td>args</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>autoview</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>math avg</td>
<td>statistics.mean</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>calc, = math</td>
<td>math operators</td>
<td>math operators</td>
<td>math operators</td>
<td>math operators</td>
</tr>
<tr>
<td>cd</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>clear</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>clip</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>compact</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>config</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>count</td>
<td>len</td>
<td>size, length</td>
<td>length</td>
<td>len</td>
</tr>
<tr>
<td>cp</td>
<td>shutil.copy</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>datetime.date.today</td>
<td>java.time.LocalDate.now</td>
<td></td>
<td></td>
</tr>
<tr>
<td>debug</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>default</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>drop</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>du</td>
<td>shutil.disk_usage</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>each</td>
<td>for</td>
<td>for</td>
<td>for</td>
<td>for</td>
</tr>
<tr>
<td>echo</td>
<td>print</td>
<td>println</td>
<td>printf</td>
<td>println!</td>
</tr>
<tr>
<td>enter</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>exit</td>
<td>exit</td>
<td>System.exit, kotlin.system.exitProcess</td>
<td>exit</td>
<td>exit</td>
</tr>
<tr>
<td>fetch</td>
<td>urllib.request.urlopen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>first</td>
<td>list[0]</td>
<td>List[0], peek</td>
<td>vector[0], top</td>
<td>Vec[0]</td>
</tr>
<tr>
<td>format</td>
<td>format</td>
<td>format</td>
<td>format</td>
<td>format!</td>
</tr>
<tr>
<td>from</td>
<td>csv, json, sqlite3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>get</td>
<td>dict[&quot;key&quot;]</td>
<td>Map[&quot;key&quot;]</td>
<td>map[&quot;key&quot;]</td>
<td>HashMap[&quot;key&quot;], get, entry</td>
</tr>
<tr>
<td>group-by</td>
<td>itertools.groupby</td>
<td>groupBy</td>
<td></td>
<td>group_by</td>
</tr>
<tr>
<td>headers</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>help</td>
<td>help</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>histogram</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>history</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>inc(<code>*</code>)</td>
<td>x += 1</td>
<td>x++</td>
<td>x++</td>
<td>x += 1</td>
</tr>
<tr>
<td>insert</td>
<td>list.insert</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>empty?</td>
<td>is None</td>
<td>isEmpty</td>
<td>empty</td>
<td>is_empty</td>
</tr>
<tr>
<td>keep</td>
<td>list[:x]</td>
<td></td>
<td></td>
<td>&amp;Vec[..x]</td>
</tr>
<tr>
<td>keep until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>keep while</td>
<td>itertools.takewhile</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>kill</td>
<td>os.kill</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>last</td>
<td>list[-1]</td>
<td></td>
<td></td>
<td>&amp;Vec[Vec.len()-1]</td>
</tr>
<tr>
<td>lines</td>
<td>split, splitlines</td>
<td>split</td>
<td>views::split</td>
<td>split, split_whitespace, rsplit, lines</td>
</tr>
<tr>
<td>ls</td>
<td>os.listdir</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>match(<code>*</code>)</td>
<td>re.findall</td>
<td>Regex.matches</td>
<td>regex_match</td>
<td></td>
</tr>
<tr>
<td>merge</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mkdir</td>
<td>os.mkdir</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mv</td>
<td>shutil.move</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>next</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>nth</td>
<td>list[x]</td>
<td>List[x]</td>
<td>vector[x]</td>
<td>Vec[x]</td>
</tr>
<tr>
<td>open</td>
<td>open</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>parse</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transpose</td>
<td>zip(*matrix)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>post(<code>*</code>)</td>
<td>urllib.request.urlopen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>prepend</td>
<td>deque.appendleft</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>ps(<code>*</code>)</td>
<td>os.listdir('/proc')</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>pwd</td>
<td>os.getcwd</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>range</td>
<td>.., until, downTo, step</td>
<td>iota</td>
<td>..</td>
</tr>
<tr>
<td>reduce</td>
<td>functools.reduce</td>
<td>reduce</td>
<td>reduce</td>
<td>fold, rfold, scan</td>
</tr>
<tr>
<td>reject</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>rename</td>
<td>shutil.move</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>reverse</td>
<td>reversed, list.reverse</td>
<td>reverse, reversed, asReversed</td>
<td>reverse</td>
<td>rev</td>
</tr>
<tr>
<td>rm</td>
<td>os.remove</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>save</td>
<td>io.TextIOWrapper.write</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>select</td>
<td>{k:dict[k] for k in keylist}</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>shells</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>shuffle</td>
<td>random.shuffle</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>len</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip</td>
<td>list[x:]</td>
<td></td>
<td></td>
<td>&amp;Vec[x..],skip</td>
</tr>
<tr>
<td>skip until</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>skip while</td>
<td>itertools.dropwhile</td>
<td></td>
<td></td>
<td>skip_while</td>
</tr>
<tr>
<td>sort-by</td>
<td>sorted, list.sort</td>
<td>sortedBy, sortedWith, Arrays.sort, Collections.sort</td>
<td>sort</td>
<td>sort</td>
</tr>
<tr>
<td>split-by</td>
<td>str.split{,lines}, re.split</td>
<td>split</td>
<td>views::split</td>
<td>split</td>
</tr>
<tr>
<td>split column</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>split row</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>str(<code>*</code>)</td>
<td>str functions</td>
<td>String functions</td>
<td>string functions</td>
<td>&amp;str, String functions</td>
</tr>
<tr>
<td>str collect</td>
<td>str.join</td>
<td>joinToString</td>
<td></td>
<td>join</td>
</tr>
<tr>
<td>str trim</td>
<td>strip, rstrip, lstrip</td>
<td>trim, trimStart, trimEnd</td>
<td>regex</td>
<td>trim, trim*{start,end}, strip*{suffix,prefix}</td>
</tr>
<tr>
<td>sum</td>
<td>sum</td>
<td>sum</td>
<td>reduce</td>
<td>sum</td>
</tr>
<tr>
<td>sys(<code>*</code>)</td>
<td>sys</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>table</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tree(<code>*</code>)</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>to</td>
<td>csv, json, sqlite3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>touch</td>
<td>open(path, 'a').close()</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>uniq</td>
<td>set</td>
<td>Set</td>
<td>set</td>
<td>HashSet</td>
</tr>
<tr>
<td>upsert</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>version</td>
<td>sys.version, sys.version_info</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>with-env</td>
<td>os.environ</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>where</td>
<td>filter</td>
<td>filter</td>
<td>filter</td>
<td>filter</td>
</tr>
<tr>
<td>which</td>
<td>shutil.which</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>wrap</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li><code>*</code> - 这些命令是标准插件的一部分</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html">Nushell 运算符</title>
    <id>www.nushell.sh/zh-CN/book/nushell_operator_map.html</id>
    <link href="www.nushell.sh/zh-CN/book/nushell_operator_map.html"/>
    <updated>2022-06-04T13:17:54.514Z</updated>
    <content type="html"><![CDATA[<h1 id="nushell-运算符" tabindex="-1"> Nushell 运算符</h1>
<p>这个表格的目的是帮助你了解 Nu 运算符与其他语言运算符的关系。我们试图制作一张包含所有 Nushell 运算符的表，以及它们在其他语言中的对应关系。欢迎大家参与贡献。</p>
<p>注意：此表针对 Nu 0.14.1 或更高版本。</p>
<table>
<thead>
<tr>
<th>Nushell</th>
<th>SQL</th>
<th>Python</th>
<th>.NET LINQ (C#)</th>
<th>PowerShell</th>
<th>Bash</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>=</td>
<td>==</td>
<td>==</td>
<td>-eq, -is</td>
<td>-eq</td>
</tr>
<tr>
<td>!=</td>
<td>!=, &lt;&gt;</td>
<td>!=</td>
<td>!=</td>
<td>-ne, -isnot</td>
<td>-ne</td>
</tr>
<tr>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>&lt;</td>
<td>-lt</td>
<td>-lt</td>
</tr>
<tr>
<td>&lt;=</td>
<td>&lt;=</td>
<td>&lt;=</td>
<td>&lt;=</td>
<td>-le</td>
<td>-le</td>
</tr>
<tr>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>&gt;</td>
<td>-gt</td>
<td>-gt</td>
</tr>
<tr>
<td>&gt;=</td>
<td>&gt;=</td>
<td>&gt;=</td>
<td>&gt;=</td>
<td>-ge</td>
<td>-ge</td>
</tr>
<tr>
<td>=~</td>
<td>like</td>
<td>re, in, startswith</td>
<td>Contains, StartsWith</td>
<td>-like, -contains</td>
<td>=~</td>
</tr>
<tr>
<td>!~</td>
<td>not like</td>
<td>not in</td>
<td>Except</td>
<td>-notlike, -notcontains</td>
<td>! &quot;str1&quot; =~ &quot;str2&quot;</td>
</tr>
<tr>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>/</td>
<td>/</td>
<td>/</td>
<td>/</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>**</td>
<td>pow</td>
<td>**</td>
<td>Power</td>
<td>Pow</td>
<td>**</td>
</tr>
<tr>
<td>in</td>
<td>in</td>
<td>re, in, startswith</td>
<td>Contains, StartsWith</td>
<td>-In</td>
<td>case in</td>
</tr>
<tr>
<td>not-in</td>
<td>not in</td>
<td>not in</td>
<td>Except</td>
<td>-NotIn</td>
<td></td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>and</td>
<td>and</td>
<td>&amp;&amp;</td>
<td>-And, &amp;&amp;</td>
<td>-a, &amp;&amp;</td>
</tr>
<tr>
<td>||</td>
<td>or</td>
<td>or</td>
<td>||</td>
<td>-Or, ||</td>
<td>-o, ||</td>
</tr>
</tbody>
</table>
]]></content>
  </entry>
  <entry>
    <title type="html">运算符</title>
    <id>www.nushell.sh/zh-CN/book/operators.html</id>
    <link href="www.nushell.sh/zh-CN/book/operators.html"/>
    <updated>2022-06-04T13:17:54.514Z</updated>
    <content type="html"><![CDATA[<h1 id="运算符" tabindex="-1"> 运算符</h1>
<p>Nushell 支持以下常见的数学、逻辑和字符串操作的运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>加</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减</td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘</td>
</tr>
<tr>
<td><code>/</code></td>
<td>除</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数 (幂)</td>
</tr>
<tr>
<td><code>mod</code></td>
<td>取模</td>
</tr>
<tr>
<td><code>==</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>=~</code></td>
<td>正则匹配 / 字符串包含另一个字符串</td>
</tr>
<tr>
<td><code>!~</code></td>
<td>正则不匹配 / 字符串<em>不</em>包含另一个</td>
</tr>
<tr>
<td><code>in</code></td>
<td>列表包含值</td>
</tr>
<tr>
<td><code>not-in</code></td>
<td>列表不包含值</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>两个布尔值与运算</td>
</tr>
<tr>
<td>`</td>
<td></td>
</tr>
</tbody>
</table>
<p>圆括号可用于分组以指定求值顺序，或用于调用命令并在表达式中使用结果。</p>
<h2 id="运算符结合顺序" tabindex="-1"> 运算符结合顺序</h2>
<p>数学运算的结合顺序如下（从最高优先级到最低）：</p>
<ul>
<li>圆括号 (<code>()</code>)</li>
<li>乘 (<code>*</code>) 、 除 (<code>/</code>) 和幂 (<code>**</code>)</li>
<li>加 (<code>+</code>) 和减 (<code>-</code>)</li>
</ul>
<div><pre><code>> 3 * (1 + 2)
9
</code></pre></div><h2 id="正则表达式-字符串包含运算符" tabindex="-1"> 正则表达式 / 字符串包含运算符</h2>
<p><code>=~</code>和<code>!~</code>运算符提供了一种更方便的方法来评估 <a href="https://cheatography.com/davechild/cheat-sheets/regular-expressions/" target="_blank" rel="noopener noreferrer">正则表达式</a>。你不需要知道正则表达式就可以使用它们 —— 它们也是检查一个字符串是否包含另一个的简单方法：</p>
<ul>
<li><code>string =~ pattern</code> 如果 <code>string</code> 包含 <code>pattern</code> 的匹配返回 <strong>true</strong>, 反之返回 <strong>false</strong>；</li>
<li><code>string !~ pattern</code> 如果 <code>string</code> 包含 <code>pattern</code> 的匹配返回 <strong>false</strong>, 反之返回 <strong>true</strong>；</li>
</ul>
<p>例如:</p>
<div><pre><code>foobarbaz <span>=~</span> bar <span># returns true</span>
foobarbaz <span>!</span>~ bar <span># returns false</span>
<span>ls</span> <span>|</span> where name <span>=~</span> ^nu <span># returns all files whose names start with "nu"</span>
</code></pre></div><p>两个运算符都使用了 <a href="https://docs.rs/regex/latest/regex/struct.Regex.html#method.is_match" target="_blank" rel="noopener noreferrer">Rust regex 包的 <code>is_match()</code> 函数</a>。</p>
<h2 id="大小写敏感性" tabindex="-1"> 大小写敏感性</h2>
<p>对字符串进行操作时，运算符通常是区分大小写的。有几种方法可以处理大小写不敏感的场景：</p>
<ol>
<li>在正则表达式运算符中，指定<code>(?i)</code>不区分大小写的模式修饰器：</li>
</ol>
<div><pre><code><span>"FOO"</span> <span>=~</span> <span>"foo"</span> <span># returns false</span>
<span>"FOO"</span> <span>=~</span> <span>"(?i)foo"</span> <span># returns true</span>
</code></pre></div><ol start="2">
<li>使用<a href="/book/commands/str_contains.html"><code>str contains</code></a> 命令的<code>--insensitive</code>标志：</li>
</ol>
<div><pre><code><span>"FOO"</span> <span>|</span> str contains --insensitive <span>"foo"</span>
</code></pre></div><ol start="3">
<li>在比较前用<a href="/book/commands/str_downcase.html"><code>str downcase</code></a>将字符串转换为小写：</li>
</ol>
<div><pre><code><span>(</span><span>"FOO"</span> <span>|</span> str downcase<span>)</span> <span>==</span> <span>(</span><span>"Foo"</span> <span>|</span> str downcase<span>)</span>
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">并行</title>
    <id>www.nushell.sh/zh-CN/book/parallelism.html</id>
    <link href="www.nushell.sh/zh-CN/book/parallelism.html"/>
    <updated>2022-06-04T13:17:54.515Z</updated>
    <content type="html"><![CDATA[<h1 id="并行" tabindex="-1"> 并行</h1>
<p>Nushell 现在已经初步支持并行运行代码了，这允许你使用更多的计算机硬件资源来处理一个流的各个元素。</p>
<p>你会注意到这些命令包含其特有的<code>par-</code>命名，每一个都对应着一个非并行的版本，这允许你先轻松地以串行的风格写代码，然后再回头用几个额外的字符轻松地将串行脚本转换成并行脚本。</p>
<h2 id="par-each" tabindex="-1"> <code>par-each</code></h2>
<p>最常见的并行命令是<a href="/book/commands/par-each.html"><code>par-each</code></a>，它是<a href="/book/commands/each.html"><code>each</code></a>命令的搭档。</p>
<p>与<a href="/book/commands/each.html"><code>each</code></a>一样，<a href="/book/commands/par-each.html"><code>par-each</code></a>对管道中流入的元素进行处理，在每个元素上运行一个代码块。与<a href="/book/commands/each.html"><code>each</code></a>不同，<a href="/book/commands/par-each.html"><code>par-each</code></a>将并行地进行这些操作。</p>
<p>假设你想计算当前目录下每个子目录下的文件数量。使用<a href="/book/commands/each.html"><code>each</code></a>你可以这样写。</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where <span>type</span> <span>==</span> <span>dir</span> <span>|</span> each <span>{</span> <span>|</span>it<span>|</span>
    <span>{</span> name: <span>$it</span>.name, len: <span>(</span>ls <span>$it</span>.name <span>|</span> length<span>)</span> <span>}</span>
<span>}</span>
</code></pre></div><p>我们为每个条目创建一条记录，并在其中填入目录的名称和该子目录中的文件数。</p>
<p>在你的机器上，时间可能有所不同。对于这台机器的当前目录来说，需要 21 毫秒的时间。</p>
<p>现在，由于这个操作可以并行运行，让我们把上面的操作转换为并行的，把<a href="/book/commands/each.html"><code>each</code></a>改为<a href="/book/commands/par-each.html"><code>par-each</code></a>：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where <span>type</span> <span>==</span> <span>dir</span> <span>|</span> par-each <span>{</span> <span>|</span>it<span>|</span>
    <span>{</span> name: <span>$it</span>.name, len: <span>(</span>ls <span>$it</span>.name <span>|</span> length<span>)</span> <span>}</span>
<span>}</span>
</code></pre></div><p>在这台机器上，现在它的运行时间为 6 毫秒。这是一个相当大的差异!</p>
<p>顺便提一下：由于 <a href="/zh-CN/book/environment.html#%E4%BD%9C%E7%94%A8%E5%9F%9F">环境变量是有作用域的</a>，你可以使用<code>par-each</code>在多个目录中并行工作（注意 <code>cd</code> 命令）：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where <span>type</span> <span>==</span> <span>dir</span> <span>|</span> par-each <span>{</span> <span>|</span>it<span>|</span>
    <span>{</span> name: <span>$it</span>.name, len: <span>(</span>cd <span>$it</span>.name<span>;</span> <span>ls</span> <span>|</span> length<span>)</span> <span>}</span>
<span>}</span>
</code></pre></div><p>如果你看一下结果，你会注意到，它们每次运行返回的顺序是不同的（这取决于你系统上的硬件线程数量）。随着任务的完成，我们得到了正确的结果，如果我们希望得到结果以特定的顺序出现，我们可能需要添加额外的步骤。例如，对于上述情况，我们可能想按 &quot;name&quot; 字段对结果进行排序。这样，我们的脚本的<a href="/book/commands/each.html"><code>each</code></a>和<a href="/book/commands/par-each.html"><code>par-each</code></a>版本都能得到相同的结果。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">管道</title>
    <id>www.nushell.sh/zh-CN/book/pipeline.html</id>
    <link href="www.nushell.sh/zh-CN/book/pipeline.html"/>
    <updated>2022-06-04T13:17:54.515Z</updated>
    <content type="html"><![CDATA[<h1 id="管道" tabindex="-1"> 管道</h1>
<p>Nu 的核心设计之一是管道，这个设计思想可以追溯到几十年前 Unix 背后的一些原始理念。正如 Nu 拓展了 Unix 的单一字符串数据类型一样，Nu 也扩展了管道的概念，使其不仅仅包含文本。</p>
<h2 id="基础" tabindex="-1"> 基础</h2>
<p>一个管道由三部分组成：输入、过滤器和输出。</p>
<div><pre><code><span>></span> <span>open</span> <span>"Cargo.toml"</span> <span>|</span> inc package.version --minor <span>|</span> save <span>"Cargo_new.toml"</span>
</code></pre></div><p>第一条命令：<code>open &quot;Cargo.toml&quot;</code> 是一个输入（有时也称为 &quot;源&quot; 或 &quot;生产者&quot;），它创建或加载数据，并将其送入管道。管道待处理的值正是来自于此输入。像<a href="/book/commands/ls.html"><code>ls</code></a>这样的命令也是输入，因为它们从文件系统中获取数据，并通过管道发送以便能被后续使用。</p>
<p>第二个命令：<code>inc package.version --minor</code> 是一个过滤器。过滤器获取输入的数据并对其进行处理。它们可能会修改它（如我们例子中的<a href="/book/commands/inc.html"><code>inc</code></a>命令），或者在值通过时对其做其他操作，如记录。</p>
<p>最后一条命令：<code>save &quot;Cargo_new.toml&quot;</code> 是一个输出（有时称为 &quot;接收者&quot;）。输出从管道中获取输入，并对其进行一些最终操作。在我们的例子中，我们在最后一步把通过管道的内容保存到一个文件中。还有一些其他类型的输出命令可以获取数值并供用户查看。</p>
<p><code>$in</code> 变量可以将管道收集成一个值，允许你将整个流作为一个参数访问，比如：</p>
<div><pre><code><span>></span> <span>echo</span> <span>1</span> <span>2</span> <span>3</span> <span>|</span> <span>$in</span>.1 * <span>$in</span>.2
<span>6</span>
</code></pre></div><h2 id="多行管道" tabindex="-1"> 多行管道</h2>
<p>如果一个管道对一行来说有些长，你可以把它放在<code>(</code>和<code>)</code>里，以创建一个子表达式：</p>
<div><pre><code><span>(</span>
    <span>"01/22/2021"</span> <span>|</span>
    parse <span>"{month}/{day}/{year}"</span> <span>|</span>
    get year
<span>)</span>
</code></pre></div><p>也可以参考 <a href="/zh-CN/book/variables_and_subexpressions.html#%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F">子表达式</a></p>
<h2 id="与外部命令交互" tabindex="-1"> 与外部命令交互</h2>
<p>Nu 命令之间使用 Nu 的数据类型进行通信（见<a href="/zh-CN/book/types_of_data.html">数据类型</a>），但 Nu 之外的命令呢？让我们看看一些与外部命令交互的例子：</p>
<p><code>internal_command | external_command</code></p>
<p>数据将从 <code>internal_command</code> 流向 <code>external_command</code>。这些数据将被转换为字符串，以便它们可以被发送到外部命令的<code>stdin</code>。</p>
<p><code>external_command | internal_command</code></p>
<p>从外部命令进入 Nu 的数据将以字节的形式流入，Nushell 将尝试自动将其转换为 UTF-8 文本。如果成功，一个文本数据流将被发送到<code>internal_command</code>；如果不成功，一个二进制数据流将被发送到<code>internal_command</code>。像<a href="/book/commands/lines.html"><code>lines</code></a>这样的命令有助于从外部命令接收数据，因为它提供了分离的数据行以供后续使用。</p>
<p><code>external_command_1 | external_command_2</code></p>
<p>Nu 在两个外部命令之间以与其他 Shell 相同的方式处理数据管道，比如 Bash。<code>external_command_1</code>的<code>stdout</code>与<code>external_command_2</code>的<code>stdin</code>相连，这让数据在两个命令之间自然流动。</p>
<h2 id="幕后解说" tabindex="-1"> 幕后解说</h2>
<p>你可能想知道，既然<a href="/book/commands/ls.html"><code>ls</code></a>是一个输入而不是一个输出，我们为何能看到一个表格？其实 Nu 使用了另一个叫做<a href="/book/commands/table.html"><code>table</code></a>的命令为我们自动添加了这个输出。<a href="/book/commands/table.html"><code>table</code></a>命令被附加到任何没有输出的管道上，这使得我们可以看到结果。</p>
<p>实际上，该命令：</p>
<div><pre><code>> ls
</code></pre></div><p>和以下管道：</p>
<div><pre><code>> ls | table
</code></pre></div><p>是一样的。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">插件</title>
    <id>www.nushell.sh/zh-CN/book/plugins.html</id>
    <link href="www.nushell.sh/zh-CN/book/plugins.html"/>
    <updated>2022-06-04T13:17:54.515Z</updated>
    <content type="html"><![CDATA[<h1 id="插件" tabindex="-1"> 插件</h1>
<p>Nu 可以通过插件进行扩展。插件的行为与 Nu 的内置命令很相似，另外的好处是它们可以与 Nu 本身分开添加。</p>
<p>Nu 的插件是可执行的；Nu 在需要时启动它们，并通过 <a href="https://en.wikipedia.org/wiki/Standard_streams" target="_blank" rel="noopener noreferrer">stdin, stdout 和 stderr</a> 与它们进行通信。Nu 的插件可以使用 JSON 或 <a href="https://capnproto.org/" target="_blank" rel="noopener noreferrer">Cap'n Proto</a> 作为它们的通信编码方式。</p>
<h2 id="添加一个插件" tabindex="-1"> 添加一个插件</h2>
<p>要添加一个插件，请调用<a href="/book/commands/register.html"><code>register</code></a>命令来告诉 Nu 在哪里可以找到它，与此同时，你还需要告诉 Nushell 这个插件使用什么方式进行编码。</p>
<p>Linux+macOS:</p>
<div><pre><code><span>></span> register --encoding<span>=</span>capnp ./my_plugins/my-cool-plugin
</code></pre></div><p>Windows:</p>
<div><pre><code><span>></span> register --encoding<span>=</span>capnp .<span>\</span>my_plugins<span>\</span>my-cool-plugin.exe
</code></pre></div><p>当 <a href="/book/commands/register.html"><code>register</code></a> 被调用时：</p>
<ol>
<li>Nu 启动该插件并通过 stdin 向其发送 &quot;签名&quot; 信息；</li>
<li>插件通过 stdout 响应，包含其签名（名称、描述、参数、标志等）的消息；</li>
<li>Nu 将插件的签名保存在<code>$nu.plugin-path</code>位置的文件中，因此在注册之后的多次启动中都是有效的；</li>
</ol>
<p>一旦注册，该插件就可以作为你的命令集的一部分被使用：</p>
<div><pre><code><span>></span> <span>help</span> commands <span>|</span> where is_plugin <span>==</span> <span>true</span>
</code></pre></div><h2 id="示例" tabindex="-1"> 示例</h2>
<p>Nu 的主版本中包含了一些插件的例子，这些例子对学习插件协议的工作方式很有帮助：</p>
<ul>
<li><a href="https://github.com/nushell/nushell/tree/main/crates/nu_plugin_example" target="_blank" rel="noopener noreferrer">Rust</a></li>
<li><a href="https://github.com/nushell/nushell/blob/main/crates/nu_plugin_python/plugin.py" target="_blank" rel="noopener noreferrer">Python</a></li>
</ul>
<h2 id="调试" tabindex="-1"> 调试</h2>
<p>调试插件的最简单方法是打印到 stderr；插件的标准错误流会通过 Nu 重定向并显示给用户。</p>
<h2 id="帮助" tabindex="-1"> 帮助</h2>
<p>Nu 的插件文档尚在撰写中，如果你对某件事情不确定 <a href="https://discord.gg/NtAbbGn" target="_blank" rel="noopener noreferrer">Nu Discord</a>上的 #plugins 频道是一个提问的好地方!</p>
]]></content>
  </entry>
  <entry>
    <title type="html">正则表达式</title>
    <id>www.nushell.sh/zh-CN/book/regular_expressions.html</id>
    <link href="www.nushell.sh/zh-CN/book/regular_expressions.html"/>
    <updated>2022-06-04T13:17:54.515Z</updated>
    <content type="html"><![CDATA[<h1 id="正则表达式" tabindex="-1"> 正则表达式</h1>
<p>Nushell 命令中的正则表达式是由 <code>rust-lang/regex</code> 包处理的。如果你想了解更多，请查看 crate 的文档：&quot;<a href="https://github.com/rust-lang/regex" target="_blank" rel="noopener noreferrer">Regex</a>&quot;。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">脚本</title>
    <id>www.nushell.sh/zh-CN/book/scripts.html</id>
    <link href="www.nushell.sh/zh-CN/book/scripts.html"/>
    <updated>2022-06-04T13:17:54.515Z</updated>
    <content type="html"><![CDATA[<h1 id="脚本" tabindex="-1"> 脚本</h1>
<p>在 Nushell 中，你可以用 Nushell 语言编写和运行脚本。要运行一个脚本，你可以把它作为一个参数传递给<code>nu</code>命令行程序：</p>
<div><pre><code><span>></span> nu myscript.nu
</code></pre></div><p>这将在一个新的 Nu 实例中运行脚本直至完成。你也可以使用<a href="/book/commands/source.html"><code>source</code></a>在 Nu 的 <strong>当前</strong> 实例中运行脚本：</p>
<div><pre><code><span>></span> <span>source</span> myscript.nu
</code></pre></div><p>我们来看一个脚本文件的例子吧：</p>
<div><pre><code><span># myscript.nu</span>
def greet <span>[</span>name<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello"</span> <span>$name</span>
<span>}</span>

greet <span>"world"</span>
</code></pre></div><p>脚本文件包含了自定义命令的定义以及主脚本本身，它将在自定义命令定义后运行。</p>
<p>在上面的例子中，首先<code>greet</code>是由 Nushell 解释器定义的，这使得我们之后可以调用这个定义，我们可以把上面的内容写成：</p>
<div><pre><code>greet <span>"world"</span>

def greet <span>[</span>name<span>]</span> <span>{</span>
  <span>echo</span> <span>"hello"</span> <span>$name</span>
<span>}</span>
</code></pre></div><p>Nushell 并不要求定义必须放在脚本中调用该定义之前，你可以把定义放在你觉得舒服的地方。</p>
<h2 id="脚本是如何被处理的" tabindex="-1"> 脚本是如何被处理的</h2>
<p>在一个脚本中定义总是先运行，这样我们就可以在脚本中调用定义。</p>
<p>在定义运行之后, 我们从脚本文件的顶部开始, 一个接一个地运行每一组命令。</p>
<h2 id="脚本行" tabindex="-1"> 脚本行</h2>
<p>为了更好地理解 Nushell 是如何看待代码行的, 我们来看一个脚本的例子：</p>
<div><pre><code>a
b<span>;</span> c <span>|</span> d
</code></pre></div><p>当这个脚本运行时，Nushell 将首先运行<code>a</code>命令至完成并查看其结果。接下来，Nushell 将按照<a href="/zh-CN/book/types_of_data.html#%E7%BB%84">&quot;组&quot;部分</a>中的规则运行<code>b; c | d</code>。</p>
<h2 id="参数化脚本" tabindex="-1"> 参数化脚本</h2>
<p>脚本文件可以选择性地包含一个特殊的 &quot;main&quot; 命令。<code>main</code>将在任何其他 Nu 代码之后运行，主要用于向脚本添加参数。你可以在脚本名称后面传递参数（<code>nu &lt;script name&gt; &lt;script args&gt;</code>）。比如：</p>
<div><pre><code><span># myscript.nu</span>

def main <span>[</span>x: int<span>]</span> <span>{</span>
  <span>$x</span> + <span>10</span>
<span>}</span>
</code></pre></div><div><pre><code>> nu myscript.nu 100
110
</code></pre></div><h2 id="shebangs" tabindex="-1"> Shebangs (<code>!#</code>)</h2>
<p>在 Linux 和 macOS 上，你可以选择使用 <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)" target="_blank" rel="noopener noreferrer">Shebang</a>来告诉操作系统一个文件应该被 <code>Nu</code> 解释。例如，在一个名为 <code>myscript</code> 的文件中包含以下内容：</p>
<div><pre><code><span>#!/usr/bin/env nu</span>
<span>echo</span> <span>"Hello World!"</span>
</code></pre></div><p>此时你可以直接运行该脚本(注意：前面并没有加<code>nu</code>)：</p>
<div><pre><code><span>></span> ./myscript
Hello World<span>!</span>
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">Shell 中的 Shell</title>
    <id>www.nushell.sh/zh-CN/book/shells_in_shells.html</id>
    <link href="www.nushell.sh/zh-CN/book/shells_in_shells.html"/>
    <updated>2022-06-04T13:17:54.515Z</updated>
    <content type="html"><![CDATA[<h1 id="shell-中的-shell" tabindex="-1"> Shell 中的 Shell</h1>
<h2 id="在多个目录下工作" tabindex="-1"> 在多个目录下工作</h2>
<p>虽然在一个目录下工作很常见，但同时在多个路径工作也很方便。为此，Nu 提供了 &quot;Shells&quot; 的概念。顾名思义，它们是一种在一个 Shell 中运行多个 Shell 的方法，允许你在多个工作目录之间快速跳转。</p>
<p>作为开始，让我们进入一个目录：</p>
<div><pre><code>/home/jonathant/Source/nushell<span>(</span>main<span>)</span><span>></span> enter <span>..</span>/book
/home/jonathant/Source/book<span>(</span>main<span>)</span><span>></span> <span>ls</span>
────┬────────────────────┬──────┬────────┬─────────────
 <span>#  │ name               │ type │ size   │ modified</span>
────┼────────────────────┼──────┼────────┼─────────────
  <span>0</span> │ <span>404</span>.html           │ File │  <span>429</span> B │ <span>2</span> hours ago
  <span>1</span> │ CONTRIBUTING.md    │ File │  <span>955</span> B │ <span>2</span> hours ago
  <span>2</span> │ Gemfile            │ File │ <span>1.1</span> KB │ <span>2</span> hours ago
  <span>3</span> │ Gemfile.lock       │ File │ <span>6.9</span> KB │ <span>2</span> hours ago
</code></pre></div><p>进入(<code>enter</code>)类似于改变目录（正如我们在<code>cd</code>命令中看到的那样）。这允许你跳入一个目录，在其中工作。我们现在是在两个目录中，而不是改变目录。为了更清楚地看到这一点，我们可以使用<a href="/book/commands/shells.html"><code>shells</code></a>命令来列出我们当前的活动目录：</p>
<div><pre><code>/home/jonathan/Source/book<span>(</span>main<span>)</span><span>></span> shells
───┬────────┬────────────┬─────────────────────────
 <span># │ active │    name    │          path</span>
───┼────────┼────────────┼─────────────────────────
 <span>0</span> │ <span>false</span>  │ filesystem │ /home/jt/Source/nushell
 <span>1</span> │ <span>true</span>   │ filesystem │ /home/jt/Source/book
 <span>2</span> │ <span>false</span>  │ filesystem │ /home/jt/Source/music
───┴────────┴────────────┴─────────────────────────

</code></pre></div><p><a href="/book/commands/shells.html"><code>shells</code></a>命令显示目前有三个 Shells 处于活动状态：我们最初的 &quot;nushell&quot; 源目录和现在的新 &quot;book&quot; 目录。</p>
<p>我们可以用 <code>n</code>, <code>p</code> 和 <code>g</code> 的快捷命令在这些 Shell 之间跳转，这是 &quot;next&quot;、&quot;previous&quot; 和 &quot;go&quot; 的缩写：</p>
<div><pre><code>/home/jonathant/Source/book(main)> n
/home/jonathant/Source/nushell(main)> p
/home/jonathant/Source/book(main)> g 2
/home/jonathant/Source/music(main)>
</code></pre></div><p>我们可以看到目录在变化，但我们总是能够回到我们正在工作的前一个目录。这使我们能够在同一个会话的多个目录中工作。</p>
<h2 id="退出-shell" tabindex="-1"> 退出 Shell</h2>
<p>你可以使用 <code>exit</code> 命令离开一个你已经 &quot;进入(<code>enter</code>)&quot; 的 Shell。如果这是最后一个打开的 Shell，Nu 将退出。</p>
<p>你可以随时退出 Nu，即使有多个 Shell 处于活动状态，只需要在<code>exit</code>命令中传递<code>--now</code>标志。像这样：<code>exit --now</code></p>
]]></content>
  </entry>
  <entry>
    <title type="html">标准输入、输出和退出码</title>
    <id>www.nushell.sh/zh-CN/book/stdout_stderr_exit_codes.html</id>
    <link href="www.nushell.sh/zh-CN/book/stdout_stderr_exit_codes.html"/>
    <updated>2022-06-04T13:17:54.515Z</updated>
    <content type="html"><![CDATA[<h1 id="标准输入、输出和退出码" tabindex="-1"> 标准输入、输出和退出码</h1>
<p>Nushell 和外部命令之间互操作的一个重要部分是与来自外部的标准数据流一起工作。</p>
<p>这些重要数据流中的第一个是标准输出流(stdout)。</p>
<h2 id="标准输出流" tabindex="-1"> 标准输出流</h2>
<p>标准输出流(stdout)是大多数外部应用程序将数据发送到管道或屏幕上的方式。如果由外部应用发送到其 stdout 的数据是管道的一部分，Nushell 会默认接收。</p>
<div><pre><code><span>></span> external <span>|</span> str collect
</code></pre></div><p>以上将调用名为<code>external</code>的外部命令，并将 stdout 输出流重定向到管道中。有了这个重定向，Nushell 就可以把数据传递给管道中的下一个命令，这里是<code>str collect</code>。</p>
<p>如果没有管道，Nushell 将不做任何重定向，允许它直接打印到屏幕上。</p>
<h2 id="标准错误流" tabindex="-1"> 标准错误流</h2>
<p>另一个外部应用程序经常用来打印错误信息的常见流是标准错误流(stderr)。默认情况下，Nushell 不会对 stderr 做任何重定向，这意味着它会默认打印到屏幕上。</p>
<p>你可以通过使用<code>do -i { ... }</code>来强制 Nushell 做一个重定向。例如，如果我们想调用上面的外部程序并重定向其 stderr，我们可以这样写：</p>
<div><pre><code><span>></span> <span>do</span> -i <span>{</span> external <span>}</span>
</code></pre></div><h2 id="退出码" tabindex="-1"> 退出码</h2>
<p>最后，外部命令有一个 &quot;退出代码(exit code)&quot;。这些代码有助于给调用者一个提示，说明该命令是否运行成功。</p>
<p>Nushell 通过两种方式之一跟踪最近完成的外部命令的最后退出代码。第一种方式是使用<code>LAST_EXIT_CODE</code>环境变量。</p>
<div><pre><code><span>></span> <span>do</span> -i <span>{</span> external <span>}</span>
<span>></span> <span>echo</span> <span>$env</span>.LAST_EXIT_CODE
</code></pre></div><p>第二种是使用一个叫做<a href="/book/commands/complete.html"><code>complete</code></a>的命令。</p>
<h2 id="使用-complete-命令" tabindex="-1"> 使用 <a href="/book/commands/complete.html"><code>complete</code></a> 命令</h2>
<p><a href="/book/commands/complete.html"><code>complete</code></a>命令允许你运行一个外部程序直到完成，并将 stdout, stderr, 和退出代码收集在一条记录中。</p>
<p>如果我们尝试在一个不存在的文件上运行外部的<code>cat</code>，我们可以看到<a href="/book/commands/complete.html"><code>complete</code></a>对流的处理，包括重定向的 stderr：</p>
<div><pre><code><span>></span> <span>do</span> -i <span>{</span> <span>cat</span> unknown.txt <span>}</span> <span>|</span> complete
╭───────────┬─────────────────────────────────────────────╮
│ stdout    │                                             │
│ stderr    │ cat: unknown.txt: No such <span>file</span> or directory │
│ exit_code │ <span>1</span>                                           │
╰───────────┴─────────────────────────────────────────────╯
</code></pre></div><h2 id="原始流" tabindex="-1"> 原始流</h2>
<p>在 Nushell 中，stdout 和 stderr 都表现为 &quot;原始流&quot;。这些流是字节流，而不是结构化的流，而后者才是 Nushell 内部命令所使用的。</p>
<p>因为字节流可能很难处理，特别是考虑到使用输出作为文本数据是很常见的，Nushell 试图将原始流转换为文本数据。这使得其他命令可以拉取外部命令的输出，并接收他们可以进一步处理的字符串。</p>
<p>Nushell 试图将流转换为 UTF-8 文本，如果在任何时候转换失败，流的其余部分就会被假定为始终是字节。</p>
<p>如果你想对字节流的解码有更多的控制，你可以使用 <a href="/book/commands/decode.html"><code>decode</code></a> 命令。<a href="/book/commands/decode.html"><code>decode</code></a>命令可以插入到外部或其他原始流创建命令之后的管道中，它将根据你给<code>decode</code>的参数来处理字节的解码。例如，你可以这样对 shift-jis 文本进行解码：</p>
<div><pre><code><span>></span> 0x<span>[</span>8a 4c<span>]</span> <span>|</span> decode shift-jis
貝
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">Table of Contents</title>
    <id>www.nushell.sh/zh-CN/book/table_of_contents.html</id>
    <link href="www.nushell.sh/zh-CN/book/table_of_contents.html"/>
    <updated>2022-06-04T13:17:54.516Z</updated>
    <content type="html"><![CDATA[<h1 id="table-of-contents" tabindex="-1"> Table of Contents</h1>
<ul>
<li><a href="/zh-CN/book/installation.html">安装</a> - 安装 Nushell</li>
<li><a href="/zh-CN/book/introduction.html">介绍</a> - 开始使用</li>
<li><a href="/zh-CN/book/thinking_in_nushell.html">Nushell 开发思想</a> - Nushell 开发思想</li>
<li><a href="/zh-CN/book/moving_around.html">四处移动</a> - 在 Nushell 里四处移动</li>
<li><a href="/zh-CN/book/types_of_data.html">数据类型</a> - Nushell 中的数据类型</li>
<li><a href="/zh-CN/book/loading_data.html">加载数据</a> - 加载及使用数据</li>
<li><a href="/zh-CN/book/strings.html">字符串</a> - 字符串、转义字符和字符串插值</li>
<li><a href="/zh-CN/book/working_with_lists.html">使用列表</a> - 使用 Nushell 的列表</li>
<li><a href="/zh-CN/book/working_with_tables.html">使用表格</a> - 使用 Nushell 的表格</li>
<li><a href="/zh-CN/book/pipeline.html">管道</a> - 管道是如何运作的</li>
<li><a href="/zh-CN/book/configuration.html">配置</a> - 如何配置 Nushell</li>
<li><a href="/zh-CN/book/3rdpartyprompts.html">第三方命令行提示</a> - 如何配置第三方命令行提示</li>
<li><a href="/zh-CN/book/custom_commands.html">自定义命令</a> - 创建你自己的命令</li>
<li><a href="/zh-CN/book/aliases.html">别名</a> - 如何为命令添加别名</li>
<li><a href="/zh-CN/book/operators.html">运算符</a> - Nushell 支持的运算符</li>
<li><a href="/zh-CN/book/math.html">数学</a> - Nushell 里的数学计算</li>
<li><a href="/zh-CN/book/variables_and_subexpressions.html">变量和子表达式</a> - 使用变量和子表达式</li>
<li><a href="/zh-CN/book/environment.html">环境变量</a> - 使用环境变量</li>
<li><a href="/zh-CN/book/stdout_stderr_exit_codes.html">标准输出、错误和退出码</a> - 使用标准输出、错误和退出码</li>
<li><a href="/zh-CN/book/modules.html">模块</a> - 创建和使用你自己的模块</li>
<li><a href="/zh-CN/book/scripts.html">脚本</a> - 创建你自己的脚本</li>
<li><a href="/zh-CN/book/metadata.html">元数据</a> - 细说 Nushell 的元数据系统</li>
<li><a href="/zh-CN/book/creating_errors.html">创建你自己的<code>错误</code></a> - 创建你自己的错误信息</li>
<li><a href="/zh-CN/book/shells_in_shells.html">Shells</a> - 同时在多个 Shell 里面工作</li>
<li><a href="/zh-CN/book/escaping.html">命令转移</a> - 转移到同名的本机原生命令</li>
<li><a href="/zh-CN/book/plugins.html">插件</a> - 通过插件增强 Nushell 并添加更多功能</li>
<li><a href="/zh-CN/book/parallelism.html">平行</a> - 并行运行你的代码</li>
<li><a href="/zh-CN/book/line_editor.html">行编辑器</a> - Nushell 的行编辑器</li>
<li><a href="/zh-CN/book/dataframes.html">数据帧</a> - 在 Nushell 里使用数据帧</li>
<li><a href="/zh-CN/book/coloring_and_theming.html">配色和主题</a> - 如何改变 Nushell 的颜色和主题</li>
<li><a href="/zh-CN/book/regular_expressions.html">正则表达式</a> - 正则使用指南</li>
<li><a href="/zh-CN/book/coming_from_bash.html">Bash 用户上手指南</a> - 帮助 Bash 用户快速上手 Nushell</li>
<li><a href="/zh-CN/book/nushell_map.html">从 shells/DSL 到 Nushell</a> - Nushell 与 SQL, Linq, PowerShell 及 Bash 的差异</li>
<li><a href="/zh-CN/book/nushell_map_imperative.html">从命令式语言到 Nushell</a> - Nushell 与 Python, Kotlin, C++, C# 和 Rust 的差异</li>
<li><a href="/zh-CN/book/nushell_map_functional.html">从函数式编程语言到 Nushell</a> - Nushell 与 Clojure, Tablecloth (Ocaml / Elm) 和 Haskell 的差异</li>
<li><a href="/zh-CN/book/nushell_operator_map.html">Nushell 运算符映射</a> - 比较 Nushell 与通用编程语言中的运算符</li>
<li><a href="/zh-CN/book/command_reference.html">命令参考</a> - Nushell 所有命令清单</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html">以 Nushell 的方式思考</title>
    <id>www.nushell.sh/zh-CN/book/thinking_in_nushell.html</id>
    <link href="www.nushell.sh/zh-CN/book/thinking_in_nushell.html"/>
    <updated>2022-06-04T13:17:54.516Z</updated>
    <content type="html"><![CDATA[<h1 id="以-nushell-的方式思考" tabindex="-1"> 以 Nushell 的方式思考</h1>
<p>为了帮助你理解并充分利用 Nushell，我们把这部分内容一起放入&quot;以 Nushell 的方式思考&quot;这一节。通过学习 Nushell 的思考方式，并使用它提供的模式，你会在开始时遇到更少的问题，并为接下来的成功做好准备。</p>
<p>那么，用 Nushell 的方式思考是什么意思呢？下面是一些 Nushell 新用户常见的问题。</p>
<h2 id="nushell-不是-bash" tabindex="-1"> Nushell 不是 Bash</h2>
<p>Nushell 既是一种编程语言，也是一种 Shell，正因为如此，它有自己的方式来处理文件、目录、网站等等。我们对其进行了建模，以使其与你可能熟悉的其他 Shell 的工作方式接近。其中管道用于将两个命令连接在一起：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> length
</code></pre></div><p>Nushell 也支持其他常见的功能，例如从之前运行的命令中获取退出代码(Exit Code)。</p>
<p>虽然它确实有这些功能，但 Nushell 并不是 Bash。Bash 的工作方式以及一般的 POSIX 风格，并不是 Nushell 所支持的。例如，在 Bash 中你可以使用：</p>
<div><pre><code><span>></span> <span>echo</span> <span>"hello"</span> <span>></span> output.txt
</code></pre></div><p>在 Nushell 中，我们使用<code>&gt;</code>作为大于运算符，这与 Nushell 的语言特质比较吻合。取而代之的是，你需要用管道将其连接到一个可以保存内容的命令：</p>
<div><pre><code><span>></span> <span>echo</span> <span>"hello"</span> <span>|</span> save output.txt
</code></pre></div><p><strong>以 Nushell 的方式思考：</strong> Nushell 看待数据的方式是，数据在管道中流动，直到它到达用户或由最后的命令处理。Nushell 使用命令来完成工作，学习这些命令以及何时使用它们有助于你组合使用多种管道。</p>
<h2 id="把-nushell-想象成一种编译型语言" tabindex="-1"> 把 Nushell 想象成一种编译型语言</h2>
<p>Nushell 设计的一个重要部分，特别是它与许多动态语言不同的地方是，Nushell 将你提供给它的源代码转换成某种可执行产物，然后再去运行它。Nushell 没有 <code>eval</code> 功能，因此也不允许你在运行时继续拉入新的源代码。这意味着对于诸如引入文件使其成为你项目的一部分这样的任务，需要知道文件的具体路径，就如同 C++或 Rust 等编译语言中的文件引入一样。</p>
<p>例如，下面的代码在 Nushell 中是没有意义的，如果作为脚本将无法执行：</p>
<div><pre><code><span>echo</span> <span>"def abc [] { 1 + 2 }"</span> <span>|</span> save output.nu
<span>source</span> <span>"output.nu"</span>
abc
</code></pre></div><p><code>source</code> 命令将引入被编译的源码，但前面那行 <code>save</code> 命令还没有机会运行。Nushell 运行整个程序块就像运行一个文件一样，而不是一次运行一行。在这个例子中，由于<code>output.nu</code>文件是在 &quot;编译&quot; 步骤之后才创建的，因此 <code>source</code> 命令在解析时无法从其中读取定义。</p>
<p>另一个常见的问题是试图动态地创建文件名并<code>source</code>，如下：</p>
<div><pre><code><span>></span> <span>source</span> $<span>"(<span>$my</span>-path)/common.nu"</span>
</code></pre></div><p>这就需要求值器(Evaluator)运行并对字符串进行求值(Evaluate)，但不幸的是，Nushell 在编译时就需要这些信息。</p>
<p><strong>以 Nushell 的方式思考：</strong> Nushell 被设计为对你输入的所有源代码使用一个单一的“编译”步骤，这与求值是分开的。这将允许强大的 IDE 支持，准确的错误提示，并成为第三方工具更容易使用的语言，以及在未来甚至可以有更高级的输出，比如能够直接将 Nushell 编译为二进制文件等。</p>
<h2 id="变量是不可变的" tabindex="-1"> 变量是不可变的</h2>
<p>对于来自其他语言的人来说，另一个常见的令人惊愕之处是 Nushell 的变量是不可变的（事实上，有些人已经开始称它们为 &quot;<strong>常量</strong>&quot; 来反映这一点）。接触 Nushell，你需要花一些时间来熟悉更多的函数式风格，因为这往往有助于写出与<strong>不可变的变量</strong>最相容的代码。</p>
<p>你可能想知道为什么 Nushell 使用不可变的变量，在 Nushell 开发的早期，我们决定看看我们能在语言中使用多长时间的以数据为中心的函数式风格。最近，我们在 Nushell 中加入了一个关键的功能，使这些早期的实验显示出其价值：并行性。通过在任何 Nushell 脚本中将<a href="/book/commands/each.html"><code>each</code></a>切换到<a href="/book/commands/par-each.html"><code>par-each</code></a>，你就能够在 “输入” 上并行地运行相应的代码块。这是可能的，因为 Nushell 的设计在很大程度上依赖于不可变性、组合和流水线。</p>
<p>Nushell 的变量是不可变的，但这并不意味着无法表达变化。Nushell 大量使用了 &quot;Shadowing&quot; 技术（变量隐藏）。变量隐藏是指创建一个与之前声明的变量同名的新变量，例如，假设你有一个<code>$x</code>在当前作用域内，而你想要一个新的<code>$x</code>并将其加 1：</p>
<div><pre><code><span>let</span> x <span>=</span> <span>$x</span> + <span>1</span>
</code></pre></div><p>这个新的<code>x</code>对任何跟在这一行后面的代码都是可见的。谨慎地使用变量隐藏可以使变量的使用变得更容易，尽管这不是必须的。</p>
<p>循环计数器是可变变量的另一种常见模式，它被内置于大多数迭代命令中，例如，你可以使用<a href="/book/commands/each.html"><code>each</code></a>上的<code>-n</code>标志同时获得每个元素的值和索引：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> each -n <span>{</span> <span>|</span>it<span>|</span> $<span>"Number (<span>$it</span>.index) is size (<span>$it</span>.item.size)"</span> <span>}</span>
</code></pre></div><p>你也可以使用<a href="/book/commands/reduce.html"><code>reduce</code></a>命令来达到上述目的，其方式与你在循环中修改一个变量相同。例如，如果你想在一个字符串列表中找到最长的字符串，你可以这样做：</p>
<div><pre><code><span>></span> <span>[</span>one, two, three, four, five, six<span>]</span> <span>|</span> reduce <span>{</span><span>|</span>curr, max<span>|</span>
    <span>if</span> <span>(</span><span>$curr</span> <span>|</span> str length<span>)</span> <span>></span> <span>(</span><span>$max</span> <span>|</span> str length<span>)</span> <span>{</span>
        <span>$curr</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>$max</span>
    <span>}</span>
<span>}</span>
</code></pre></div><p><strong>以 Nushell 的方式思考：</strong> 如果你习惯于使用可变的变量来完成不同的任务，那么你将需要一些时间来学习如何以更加函数式的方式来完成每个任务。Nushell 有一套内置的能力来帮助处理这样的模式，学习它们将帮助你以更加 Nushell 的风格来写代码。由此带来的额外的好处是你可以通过并行运行你的部分代码来加速脚本执行。</p>
<h2 id="nushell-的环境是有作用域的" tabindex="-1"> Nushell 的环境是有作用域的</h2>
<p>Nushell 从编译型语言中获得了很多设计灵感，其中一个是语言应该避免全局可变状态。Shell 经常通过修改全局变量来更新环境，但 Nushell 避开了这种方法。</p>
<p>在 Nushell 中，代码块可以控制自己的环境，因此对环境的改变是发生在代码块范围内的。</p>
<p>在实践中，这可以让你用更简洁的代码来处理子目录，例如，如果你想在当前目录下构建每个子项目，你可以运行：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> each <span>{</span> <span>|</span>it<span>|</span>
    <span>cd</span> <span>$it</span>.name
    <span>make</span>
<span>}</span>
</code></pre></div><p><code>cd</code>命令改变了<code>PWD</code>环境变量，这个变量的改变只在当前代码块有效，如此即可允许每次迭代都从当前目录开始，进入下一个子目录。</p>
<p>环境变量具有作用域使命令更可预测，更容易阅读，必要时也更容易调试。Nushell 还提供了一些辅助命令，如<a href="/book/commands/def-env.html"><code>def-env</code></a>、<a href="/book/commands/load-env.html"><code>load-env</code></a>，作为对环境变量进行批量更新的辅助方法。</p>
<p><code>*</code> - 这里有一个例外，<a href="/book/commands/def-env.html"><code>def-env</code></a>允许你创建一个可以修改并保留调用者环境的命令</p>
<p><strong>以 Nushell 的方式思考：</strong> 在 Nushell 中，没有全局可修改变量的编码最佳实践延伸到了环境变量。使用内置的辅助命令可以让你更容易地处理 Nushell 中的环境变量问题。利用环境变量对代码块具有作用范围这一事实，也可以帮助你写出更简洁的脚本，并与外部命令互动，而不需要在全局环境中添加你不需要的东西。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">数据类型</title>
    <id>www.nushell.sh/zh-CN/book/types_of_data.html</id>
    <link href="www.nushell.sh/zh-CN/book/types_of_data.html"/>
    <updated>2022-06-04T13:17:54.524Z</updated>
    <content type="html"><![CDATA[<h1 id="数据类型" tabindex="-1"> 数据类型</h1>
<p>传统上，Unix Shell 命令之间使用字符串文本进行通信。一个命令通过标准输出（通常缩写为 &quot;stdout&quot;）输出文本，另一个命令通过标准输入（或 &quot;stdin&quot;）读入文本，以此来让两个命令进行通信。</p>
<p>我们可以认为这种通信是基于字符串的。</p>
<p>Nu 在其命令中采用了这种方法，并将其扩展到包括其他类型的数据。目前，Nu 支持两种数据类型：简单的和结构化的数据。</p>
<p>像许多编程语言一样，Nu 使用一组简单和结构化的数据类型对数据进行建模。简单的数据类型包括整数、浮点数、字符串、布尔、日期和路径。它还包括一个用于表示文件大小的特殊类型。</p>
<h2 id="整数" tabindex="-1"> 整数</h2>
<p>整数（或整形）数字：例子包括 1、5 和 100。</p>
<h2 id="小数" tabindex="-1"> 小数</h2>
<p>小数是指带有一些小数成分的数字，例如，1.5，2.0，和 15.333。</p>
<h2 id="字符串" tabindex="-1"> 字符串</h2>
<p>代表文本的字符串。在 Nushell 中，我们有几种方法可以表示字符串：</p>
<p><strong>双引号</strong></p>
<div><pre><code>"my message"
</code></pre></div><p>双引号是最常见的引号形式，只要是需要文字的地方，你都可能看到。</p>
<p><strong>单引号</strong></p>
<div><pre><code>'my message'
</code></pre></div><p>单引号也生成一个字符串值，就像双引号一样。这里的区别是，它们允许你在文本中使用双引号，例如：<code>'他说：&quot;你能帮我拿下杯子吗？&quot;'</code>。</p>
<p><strong>字符串插值</strong></p>
<p>Nushell 支持字符串插值，允许你在以<code>$</code>为前缀的字符串中运行子表达式。比如：</p>
<div><pre><code>> echo $"6 x 7 = (6 * 7)"
6 x 7 = 42
</code></pre></div><div><pre><code>> ls | each { |it| echo $"($it.name) is ($it.size)" }
───┬─────────────────────
 0 │ genawait is 4.1 KB
 1 │ learncpp is 4.1 KB
 2 │ nuscripts is 4.1 KB
───┴─────────────────────
</code></pre></div><p><strong>裸字符串</strong></p>
<div><pre><code>> echo hello
</code></pre></div><p>Nushell 的一个独特特征是，你也可以创建一个没有任何引号的单字字符串。</p>
<p>上面的内容和如下写法是一样的：</p>
<div><pre><code>> echo "hello"
</code></pre></div><p>另见 <a href="/zh-CN/book/loading_data.html#%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串的使用</a>。</p>
<h2 id="文本行" tabindex="-1"> 文本行</h2>
<p>文本行(Lines)是具有隐含的操作系统特定行结尾的字符串。使用时需要加上操作系统特定的行尾标识。</p>
<h2 id="列路径" tabindex="-1"> 列路径</h2>
<p>列路径(Column Paths)是指通过表格到特定子表、列、行或单元格的路径。</p>
<p>例如) <code>open data.toml | get foo.0.bar</code>中的值<code>foo.0.bar</code></p>
<h2 id="glob-模式-通配符" tabindex="-1"> Glob 模式（通配符）</h2>
<p>在 Nushell 中，文件操作也允许你传入一个 glob 模式，有时被称为 &quot;通配符&quot;。这允许你给出一个可以匹配多个文件路径的模式。</p>
<p>最常见的模式是 <code>*</code>，它将匹配所有的路径。通常，你会看到这个模式被用作另一个模式的一部分，例如<code>*.bak</code>和<code>temp\*</code>。</p>
<p>在 Nushell 中，我们也支持通过双 <code>*</code> 来遍历其他目录内嵌套得更深的路径。例如，<code>ls **/*</code>将列出所有嵌套在当前目录下的非隐藏路径。</p>
<p>除了<code>*</code>，还有<code>?</code>模式，它将匹配一个单一的字符。例如，你可以通过使用模式<code>p???</code>来匹配 &quot;port&quot;。</p>
<h2 id="布尔类型" tabindex="-1"> 布尔类型</h2>
<p>布尔类型是指真或假的状态。它通常用于一个比较的结果，而非直接使用该值。</p>
<p>布尔类型的两个值是<code>true</code>和<code>false</code>。</p>
<h2 id="日期" tabindex="-1"> 日期</h2>
<p>日期和时间被保存在日期(Date)值类型中。系统使用的日期值是有时区的，默认使用 UTC 时区。</p>
<p>日期有三种形式，基于 RFC 3339 标准：</p>
<ul>
<li>日期:
<ul>
<li><code>2022-02-02</code></li>
</ul>
</li>
<li>日期和时间 (GMT 格式):
<ul>
<li><code>2022-02-02T14:30:00</code></li>
</ul>
</li>
<li>包含时区的日期和时间:
<ul>
<li><code>2022-02-02T14:30:00+05:00</code></li>
</ul>
</li>
</ul>
<h2 id="时间间隔" tabindex="-1"> 时间间隔</h2>
<p>时间间隔(Duration)表示时间的长短。一秒钟、五周和一年都是时间间隔。</p>
<p>Eg) <code>1wk</code>是一个星期的时间间隔。</p>
<p>下表显示了目前支持的所有时间间隔：</p>
<table>
<thead>
<tr>
<th>Duration</th>
<th>时长</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1ns</code></td>
<td>1 纳秒</td>
</tr>
<tr>
<td><code>1us</code></td>
<td>1 微秒</td>
</tr>
<tr>
<td><code>1ms</code></td>
<td>1 毫秒</td>
</tr>
<tr>
<td><code>1sec</code></td>
<td>1 秒</td>
</tr>
<tr>
<td><code>1min</code></td>
<td>1 分钟</td>
</tr>
<tr>
<td><code>1hr</code></td>
<td>1 小时</td>
</tr>
<tr>
<td><code>1day</code></td>
<td>1 天</td>
</tr>
<tr>
<td><code>1wk</code></td>
<td>1 周</td>
</tr>
</tbody>
</table>
<h2 id="区间" tabindex="-1"> 区间</h2>
<p>区间(Ranges)是一种表达从开始到结束的数值序列的方式。它们的形式是<code>'start' + '..' + 'end'</code>。例如，范围 <code>1..3</code>表示数字 1、2、和 3。</p>
<h2 id="闭区间和开区间" tabindex="-1"> 闭区间和开区间</h2>
<p>默认情况下，区间是包含性的，也就是说，结束值被算作区间的一部分。区间<code>1..3</code>包括数字<code>3</code>作为区间内的最后一个值。</p>
<p>有时，你可能想要一个达到某个数字的区间，但在输出中不包含该数字。对于这种情况，你可以使用<code>..&lt;</code>代替<code>..</code>。例如，<code>1..&lt;5</code>包含数字 1、2、3 和 4。</p>
<h2 id="开放式区间" tabindex="-1"> 开放式区间</h2>
<p>区间也可以是开放式的。你可以去掉区间的起点或终点，使其成为开放式的。</p>
<p>比方说，你想从 3 开始计数，但你心里没有一个具体的终点。你可以用 <code>3..</code> 这个区间来表示。当你在右边使用一个无限制的区间时，请记住，这将持续计数尽可能长的时间，这可能是一个非常长的时间，你可能会在 <code>first</code> 这样的命令中使用开放式区间，这样你就可以从区间中取出你想要的指定数量的元素。</p>
<p>你也可以使区间的开始部分开放。在这种情况下，Nushell 将从<code>0</code>开始向上计数。区间<code>..2</code>包含数字 0、1 和 2。</p>
<h2 id="文件路径" tabindex="-1"> 文件路径</h2>
<p>文件路径(File Paths)是在给定的操作系统中代表文件路径的一种与平台无关的方式。比如<code>/usr/bin</code>和<code>C:\Users\file.txt</code>。</p>
<h2 id="文件大小" tabindex="-1"> 文件大小</h2>
<p>文件大小(File Sizes)保存在一种特殊的称为字节的整数类型中。例如包括 <code>100b</code>, <code>15kb</code>, 和 <code>100mb</code>。</p>
<p>文件大小单位的完整列表是：</p>
<ul>
<li><code>b</code>: bytes</li>
<li><code>kb</code>: kilobytes (aka 1000 bytes)</li>
<li><code>mb</code>: megabytes</li>
<li><code>gb</code>: gigabytes</li>
<li><code>tb</code>: terabytes</li>
<li><code>pb</code>: petabytes</li>
<li><code>kib</code>: kibibytes (aka 1024 bytes)</li>
<li><code>mib</code>: mebibytes</li>
<li><code>gib</code>: gibibytes</li>
<li><code>tib</code>: tebibytes</li>
<li><code>pib</code>: pebibytes</li>
</ul>
<h2 id="二进制数据" tabindex="-1"> 二进制数据</h2>
<p>二进制数据，像图像文件的数据一样，是一组原始字节。</p>
<p>你可以使用 <code>0x[...]</code> 或 <code>0b[...]</code> 或 <code>0o[...]</code> 形式将二进制写成一个字面值：</p>
<div><pre><code>> 0x[1F FF]
> 0b[1 1010]
> 0o[777]
</code></pre></div><p>不完整的字节将用零来填充。</p>
<h2 id="结构化数据" tabindex="-1"> 结构化数据</h2>
<p>结构化数据是在简单数据的基础上建立的。例如，结构化数据给我们提供了一种在同一数值中表示多个整数的方法，而不是一个单一的整数。目前支持的结构化数据类型有：记录、列表和表格。</p>
<h2 id="记录" tabindex="-1"> 记录</h2>
<p>记录(Records)持有键值对，很像 JSON 中的对象。由于这些记录有时会有很多字段，所以记录是从上到下打印的，而不是从左到右：</p>
<div><pre><code>> echo {name: sam, rank: 10}
╭──────┬─────╮
│ name │ sam │
│ rank │ 10  │
╰──────┴─────╯
</code></pre></div><p>你可以将其转换到一个表然后遍历该记录：</p>
<div><pre><code>> echo {name: sam, rank: 10} | transpose key value
╭───┬──────┬───────╮
│ # │ key  │ value │
├───┼──────┼───────┤
│ 0 │ name │  sam  │
│ 1 │ rank │   10  │
╰───┴──────┴───────╯
</code></pre></div><h2 id="列表" tabindex="-1"> 列表</h2>
<p>列表(Lists)可以容纳一个以上的值。这些可以是简单的值，也可以容纳行，而一组记录的组合通常被称为 &quot;表&quot;。</p>
<p>例如，一个字符串的列表：</p>
<div><pre><code>> echo [sam fred george]
───┬────────
 0 │ sam
 1 │ fred
 2 │ george
───┴────────
</code></pre></div><h2 id="表" tabindex="-1"> 表</h2>
<p>表(Table)是 Nushell 的一个核心数据结构。当你运行 Nushell 命令时，你会发现许多命令都会将表作为输出返回。表由行和列组成。</p>
<p>我们可以创建自己的表，就像我们创建一个列表一样。因为表也包含列，而不仅仅是值，所以我们需要传入列的名称：</p>
<div><pre><code>> echo [[column1, column2]; [Value1, Value2]]
───┬─────────┬─────────
 # │ column1 │ column2
───┼─────────┼─────────
 0 │ Value1  │ Value2
───┴─────────┴─────────
</code></pre></div><p>我们还可以创建一个有多行数据的表格：</p>
<div><pre><code>> echo [[column1, column2]; [Value1, Value2] [Value3, Value4]]
───┬─────────┬─────────
 # │ column1 │ column2
───┼─────────┼─────────
 0 │ Value1  │ Value2
 1 │ Value3  │ Value4
───┴─────────┴─────────
</code></pre></div><p>你也可以通过一个记录列表来创建表格:</p>
<div><pre><code>> echo [{name: sam, rank: 10}, {name: bob, rank: 7}]
╭───┬──────┬──────╮
│ # │ name │ rank │
├───┼──────┼──────┤
│ 0 │ sam  │   10 │
│ 1 │ bob  │    7 │
╰───┴──────┴──────╯
</code></pre></div><h2 id="块" tabindex="-1"> 块</h2>
<p>块(Blocks)表示 Nu 中的一个代码块。例如，在命令 <code>each { |it| echo $it }</code> 中，块是包含在大括号中的部分，<code>{ |it| echo $it }</code>。如果有必要，可以在一对管道符号（例如，<code>|it|</code>）之间指定块参数。</p>
<p>块是表示可以在每行数据上执行的代码的一种有效方法。在<a href="/book/commands/each.html"><code>each</code></a>块中使用<code>$it</code>作为参数名是惯例，但并不是必须的：<code>each { |x| echo $x }</code>与<code>each { |it| echo $it }</code>的结果相同。</p>
<h2 id="组" tabindex="-1"> 组</h2>
<p>以此为例：</p>
<div><pre><code>foo <span>{</span>
  line1
  line2<span>;</span> line3 <span>|</span> line4
<span>}</span>
</code></pre></div><p>在该代码块内，你有两个独立的组(Groups)直到运行完毕。组是一个以分号分隔的管道集合，其中最后一个管道会输出到屏幕。</p>
<ul>
<li><code>line1</code> 是一个独立的组，所以该命令将运行到结束并显示在屏幕上。</li>
<li><code>line2</code> 是第二组中的一个管道。它会运行，但其内容不会在屏幕上显示。</li>
<li><code>line3</code> | <code>line4</code> 是第二组中的第二个管道。它会运行并且它的内容会在屏幕上显示。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title type="html">变量和子表达式</title>
    <id>www.nushell.sh/zh-CN/book/variables_and_subexpressions.html</id>
    <link href="www.nushell.sh/zh-CN/book/variables_and_subexpressions.html"/>
    <updated>2022-06-04T13:17:54.524Z</updated>
    <content type="html"><![CDATA[<h1 id="变量和子表达式" tabindex="-1"> 变量和子表达式</h1>
<p>在 Nushell 中有两种类型的求值表达式：变量和子表达式。如果你看到一个以美元符号（<code>$</code>）开头的字符串的话，你就应该知道你看到的是一个求值表达式。这表明当 Nushell 运行到此处时需要执行一个求值操作来处理这个表达式并使用此结果值。这两种求值表达式都支持一个简单形式和一个&quot;路径&quot;形式，用于处理更复杂的数据。</p>
<h2 id="变量" tabindex="-1"> 变量</h2>
<p>在两种求值表达式中比较简单的是变量。在求值过程中，变量被其值所取代。</p>
<p>如果我们创建了一个变量，我们可以通过使用<code>$</code>来引用它并打印其内容：</p>
<div><pre><code><span>></span> <span>let</span> my-value <span>=</span> <span>4</span>
<span>></span> <span>echo</span> <span>$my</span>-value
<span>4</span>
</code></pre></div><p>Nushell 中的变量是不可变的，这意味着你不能在声明后修改它的值。
不过它们可以在嵌套块中被隐藏，这导致：</p>
<div><pre><code><span>></span> <span>let</span> my-value <span>=</span> <span>4</span>
<span>></span> <span>do</span> <span>{</span> <span>let</span> my-value <span>=</span> <span>5</span><span>;</span> <span>echo</span> <span>$my</span>-value <span>}</span>
<span>5</span>
<span>></span> <span>echo</span> <span>$my</span>-value
<span>4</span>
</code></pre></div><h2 id="变量路径" tabindex="-1"> 变量路径</h2>
<p>变量路径通过深入变量的内容，找到其中的列，并最终获得一个值。比如，对于前面的例子如果我们不是赋值<code>4</code>，而是赋值了一个表的值：</p>
<div><pre><code><span>></span> <span>let</span> my-value <span>=</span> <span>[</span><span>[</span>name<span>]</span><span>;</span> <span>[</span>testuser<span>]</span><span>]</span>
</code></pre></div><p>我们可以使用一个变量路径来访问变量<code>$my-value</code>并只用一步从<code>name</code>列获得数值：</p>
<div><pre><code><span>></span> <span>echo</span> <span>$my</span>-value.name
testuser
</code></pre></div><h2 id="子表达式" tabindex="-1"> 子表达式</h2>
<p>你总是可以通过用圆括号<code>()</code>来执行一个子表达式并使用其结果。请注意，Nushell 以前的版本（0.32 以前）使用<code>$()</code>。</p>
<p>括号中包含了一个流水线，该流水线将被执行完毕然后使用结果值。例如，<code>(ls)</code>将运行<a href="/book/commands/ls.html"><code>ls</code></a>命令并返回结果表格，<code>(git branch --show-current)</code>运行外部<code>git</code>命令并返回一个包含当前分支名称的字符串。你也可以使用括号来运行数学表达式，如<code>(2 + 3)</code>。</p>
<p>子表达式也可以是管道，而不仅仅是单个命令。如果我们想得到一个大于 10KB 的文件名列表，我们可以使用子表达式来运行一个管道，并将其赋值给一个变量：</p>
<div><pre><code><span>></span> <span>let</span> names-of-big-files <span>=</span> <span>(</span>ls <span>|</span> where size <span>></span> 10kb<span>)</span>
<span>></span> <span>echo</span> <span>$names</span>-of-big-files
───┬────────────┬──────┬──────────┬──────────────
 <span># │    name    │ type │   size   │   modified</span>
───┼────────────┼──────┼──────────┼──────────────
 <span>0</span> │ Cargo.lock │ File │ <span>155.3</span> KB │ <span>17</span> hours ago
 <span>1</span> │ README.md  │ File │  <span>15.9</span> KB │ <span>17</span> hours ago
───┴────────────┴──────┴──────────┴──────────────
</code></pre></div><h2 id="子表达式和路径" tabindex="-1"> 子表达式和路径</h2>
<p>子表达式也支持路径，例如，假设我们想获得当前目录下的文件名列表，其中一个办法是使用管道：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> get name
</code></pre></div><p>我们也可以使用子表达式路径只需一步即可：</p>
<div><pre><code><span>></span> <span>echo</span> <span>(</span>ls<span>)</span>.name
</code></pre></div><p>这取决于代码的需要和你个人喜欢的编码风格。</p>
<h2 id="简化子表达式-行条件" tabindex="-1"> 简化子表达式 (行条件)</h2>
<p>Nushell 支持使用一种简化的方式访问子表达式中的列，你可能已经使用过这个功能了。例如，如果我们想只看到<a href="/book/commands/ls.html"><code>ls</code></a>中大小至少为 10KB 的行，我们可以通过：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where size <span>></span> 10kb
</code></pre></div><p><code>where size &gt; 10kb</code>是一个由两部分组成的命令：命令名<a href="/book/commands/where.html"><code>where</code></a>和简化的表达式<code>size &gt; 10kb</code>。我们说简化是因为这里的<code>size</code>是<code>$it.size</code>的简洁版。也可以用以下任何一种方式来写：</p>
<div><pre><code><span>></span> <span>ls</span> <span>|</span> where <span>$it</span>.size <span>></span> 10kb
<span>></span> <span>ls</span> <span>|</span> where <span>(</span><span>$it</span>.size <span>></span> 10kb<span>)</span>
<span>></span> <span>ls</span> <span>|</span> where <span>{</span><span>|</span><span>$it</span><span>|</span> <span>$it</span>.size <span>></span> 10kb <span>}</span>
</code></pre></div><p>为了使简化语法正常工作，列名必须出现在操作的左侧（如<code>size &gt; 10kb</code>中的<code>size</code>）。</p>
]]></content>
  </entry>
  <entry>
    <title type="html">处理列表</title>
    <id>www.nushell.sh/zh-CN/book/working_with_lists.html</id>
    <link href="www.nushell.sh/zh-CN/book/working_with_lists.html"/>
    <updated>2022-06-04T13:17:54.525Z</updated>
    <content type="html"><![CDATA[<h1 id="处理列表" tabindex="-1"> 处理列表</h1>
<h2 id="创建列表" tabindex="-1"> 创建列表</h2>
<p>列表(<code>List</code>)是一个有序的值的集合。
你可以用方括号创建一个列表，周围的值用空格和/或逗号隔开 (以方便阅读)。
例如，<code>[foo bar baz]</code> 或 <code>[foo, bar, baz]</code>。</p>
<h2 id="更新列表" tabindex="-1"> 更新列表</h2>
<p>当列表数据从管道流入时，你可以向列表中更新(<code>update</code>)和插入(<code>insert</code>)值，例如，让我们在列表的中间插入值<code>10</code>：</p>
<div><pre><code><span>></span> <span>[</span><span>1</span>, <span>2</span>, <span>3</span>, <span>4</span><span>]</span> <span>|</span> insert <span>2</span> <span>10</span>
<span># [1, 2, 10, 3, 4]</span>
</code></pre></div><p>我们也可以使用<code>update</code>将第二个元素的值替换为<code>10</code>：</p>
<div><pre><code><span>></span> <span>[</span><span>1</span>, <span>2</span>, <span>3</span>, <span>4</span><span>]</span> <span>|</span> update <span>1</span> <span>10</span>
<span># [1, 10, 3, 4]</span>
</code></pre></div><p>除了 <code>update</code> 和 <code>insert</code> 之外，还有 <code>prepend</code> 和 <code>append</code>，它们分别让你插入到列表的开头或列表的结尾。例如：</p>
<div><pre><code><span>let</span> colors <span>=</span> <span>[</span>yellow green<span>]</span>
<span>let</span> colors <span>=</span> <span>(</span><span>$colors</span> <span>|</span> prepend red<span>)</span>
<span>let</span> colors <span>=</span> <span>(</span><span>$colors</span> <span>|</span> append purple<span>)</span>
<span>echo</span> <span>$colors</span> <span># [red yellow green purple]</span>
</code></pre></div><h2 id="迭代列表" tabindex="-1"> 迭代列表</h2>
<p>要遍历一个列表中的元素，可以使用<a href="/book/commands/each.html"><code>each</code></a>命令和 <a href="/zh-CN/book/types_of_data.html#%E5%9D%97">Nu 代码块</a> 指定对每一个元素做什么操作。块参数（例如<code>{ |it| echo $it }</code>中的<code>|it|</code>）通常是当前的列表元素，但如果需要，通过 <code>--numbered</code>(<code>-n</code>) 标志可以将其改为包含<code>index</code>和<code>item</code>值的元素。比如：</p>
<div><pre><code><span>let</span> names <span>=</span> <span>[</span>Mark Tami Amanda Jeremy<span>]</span>
<span>$names</span> <span>|</span> each <span>{</span> <span>|</span>it<span>|</span> $<span>"Hello, (<span>$it</span>)!"</span> <span>}</span>
<span># Outputs "Hello, Mark!" and three more similar lines.</span>

<span>$names</span> <span>|</span> each -n <span>{</span> <span>|</span>it<span>|</span> $<span>"(<span>$it</span>.index + 1) - (<span>$it</span>.item)"</span> <span>}</span>
<span># Outputs "1 - Mark", "2 - Tami", etc.</span>
</code></pre></div><p><a href="/book/commands/where.html"><code>where</code></a>命令可以用来创建一个列表的子集，高效地根据一个条件过滤列表。</p>
<p>下面的例子得到所有名称以 &quot;e&quot; 结尾的颜色：</p>
<div><pre><code><span>let</span> colors <span>=</span> <span>[</span>red orange yellow green blue purple<span>]</span>
<span>echo</span> <span>$colors</span> <span>|</span> where <span>(</span><span>$it</span> <span>|</span> str ends-with <span>'e'</span><span>)</span>
</code></pre></div><p>在这个例子中，我们只保留大于<code>7</code>的数字：</p>
<div><pre><code><span># The block passed to where must evaluate to a boolean.</span>
<span># This outputs the list [orange blue purple].</span>

<span>let</span> scores <span>=</span> <span>[</span><span>7</span> <span>10</span> <span>8</span> <span>6</span> <span>7</span><span>]</span>
<span>echo</span> <span>$scores</span> <span>|</span> where <span>$it</span> <span>></span> <span>7</span> <span># [10 8]</span>
</code></pre></div><p><a href="/book/commands/reduce.html"><code>reduce</code></a>命令从一个列表计算一个单一的值。
它使用了一个代码块，该块有两个参数：当前元素（即 <code>it</code>）和一个累加器 (即 <code>acc</code>)。如果想要给累加器指定一个初始值，请使用 <code>--fold</code> (<code>-f</code>) 标志。
若要改变<code>it</code>使其具有<code>index</code>和<code>item</code>两个值，请添加<code>--numbered</code>（<code>-n</code>）标志。
例如：</p>
<div><pre><code><span>let</span> scores <span>=</span> <span>[</span><span>3</span> <span>8</span> <span>4</span><span>]</span>
<span>echo</span> <span>"total ="</span> <span>(</span><span>$scores</span> <span>|</span> reduce <span>{</span> <span>|</span>it, acc<span>|</span> <span>$acc</span> + <span>$it</span> <span>}</span><span>)</span> <span># 15</span>

<span>echo</span> <span>"total ="</span> <span>(</span><span>$scores</span> <span>|</span> math <span>sum</span><span>)</span> <span># easier approach, same result</span>

<span>echo</span> <span>"product ="</span> <span>(</span><span>$scores</span> <span>|</span> reduce --fold <span>1</span> <span>{</span> <span>|</span>it, acc<span>|</span> <span>$acc</span> * <span>$it</span> <span>}</span><span>)</span> <span># 96</span>

<span>echo</span> <span>$scores</span> <span>|</span> reduce -n <span>{</span> <span>|</span>it, acc<span>|</span> <span>$acc</span> + <span>$it</span>.index * <span>$it</span>.item <span>}</span> <span># 3 + 1*8 + 2*4 = 19</span>
</code></pre></div><h2 id="访问列表" tabindex="-1"> 访问列表</h2>
<p>要访问一个给定索引的列表元素, 可以使用<code>$name.index</code>形式, 其中<code>$name</code>是持有列表的变量。</p>
<p>例如，下面列表中的第二个元素可以用<code>$names.1</code>来访问：</p>
<div><pre><code><span>let</span> names <span>=</span> <span>[</span>Mark Tami Amanda Jeremy<span>]</span>
<span>$names</span>.1 <span># gives Tami</span>
</code></pre></div><p>如果索引在某个变量<code>$index</code>中，我们可以使用<code>get</code>命令从列表中提取该元素：</p>
<div><pre><code><span>let</span> names <span>=</span> <span>[</span>Mark Tami Amanda Jeremy<span>]</span>
<span>let</span> index <span>=</span> <span>1</span>
<span>$names</span> <span>|</span> get <span>$index</span> <span># gives Tami</span>
</code></pre></div><p><a href="/book/commands/length.html"><code>length</code></a>命令返回列表中的元素个数。例如，<code>[red green blue] | length</code>输出<code>3</code>。</p>
<p><a href="/book/commands/empty.html"><code>empty?</code></a> 命令确定一个字符串、列表或表格是否为空。它可以与列表一起使用，如下所示：</p>
<div><pre><code><span>let</span> colors <span>=</span> <span>[</span>red green blue<span>]</span>
<span>$colors</span> <span>|</span> empty? <span># false</span>

<span>let</span> colors <span>=</span> <span>[</span><span>]</span>
<span>$colors</span> <span>|</span> empty? <span># true</span>
</code></pre></div><p><code>in</code> 和 <code>not-in</code> 运算符用于测试一个值是否在一个列表中，例如：</p>
<div><pre><code><span>let</span> colors <span>=</span> <span>[</span>red green blue<span>]</span>
<span>'blue'</span> <span>in</span> <span>$colors</span> <span># true</span>
<span>'yellow'</span> <span>in</span> <span>$colors</span> <span># false</span>
<span>'gold'</span> not-in <span>$colors</span> <span># true</span>
</code></pre></div><p><a href="/book/commands/any.html"><code>any?</code></a>命令用于确定一个列表中是否有任意一个元素匹配给定的条件，例如：</p>
<div><pre><code><span># Do any color names end with "e"?</span>
<span>echo</span> <span>$colors</span> <span>|</span> any? <span>(</span><span>$it</span> <span>|</span> str ends-with <span>"e"</span><span>)</span> <span># true</span>

<span># Is the length of any color name less than 3?</span>
<span>echo</span> <span>$colors</span> <span>|</span> any? <span>(</span><span>$it</span> <span>|</span> str length<span>)</span> <span>&lt;</span> <span>3</span> <span># false</span>

<span># Are any scores greater than 7?</span>
<span>echo</span> <span>$scores</span> <span>|</span> any? <span>$it</span> <span>></span> <span>7</span> <span># true</span>

<span># Are any scores odd?</span>
<span>echo</span> <span>$scores</span> <span>|</span> any? <span>$it</span> mod <span>2</span> <span>==</span> <span>1</span> <span># true</span>
</code></pre></div><p><a href="/book/commands/all.html"><code>all?</code></a>命令确定一个列表中是否所有元素都匹配给定的条件。例如：</p>
<div><pre><code><span># Do all color names end with "e"?</span>
<span>echo</span> <span>$colors</span> <span>|</span> all? <span>(</span><span>$it</span> <span>|</span> str ends-with <span>"e"</span><span>)</span> <span># false</span>

<span># Is the length of all color names greater than or equal to 3?</span>
<span>echo</span> <span>$colors</span> <span>|</span> all? <span>(</span><span>$it</span> <span>|</span> str length<span>)</span> <span>>=</span> <span>3</span> <span># true</span>

<span># Are all scores greater than 7?</span>
<span>echo</span> <span>$scores</span> <span>|</span> all? <span>$it</span> <span>></span> <span>7</span> <span># false</span>

<span># Are all scores even?</span>
<span>echo</span> <span>$scores</span> <span>|</span> all? <span>$it</span> mod <span>2</span> <span>==</span> <span>0</span> <span># false</span>
</code></pre></div><h2 id="转换列表" tabindex="-1"> 转换列表</h2>
<p><a href="/book/commands/flatten.html"><code>flatten</code></a>命令通过将嵌套列表中的元素添加到顶层列表中来从现有的列表创建一个新列表。这条命令可以被多次调用，以使任意嵌套深度的列表变平。例如：</p>
<div><pre><code><span>echo</span> <span>[</span><span>1</span> <span>[</span><span>2</span> <span>3</span><span>]</span> <span>4</span> <span>[</span><span>5</span> <span>6</span><span>]</span><span>]</span> <span>|</span> flatten <span># [1 2 3 4 5 6]</span>

<span>echo</span> <span>[</span><span>[</span><span>1</span> <span>2</span><span>]</span> <span>[</span><span>3</span> <span>[</span><span>4</span> <span>5</span> <span>[</span><span>6</span> <span>7</span> <span>8</span><span>]</span><span>]</span><span>]</span><span>]</span> <span>|</span> flatten <span>|</span> flatten <span>|</span> flatten <span># [1 2 3 4 5 6 7 8]</span>
</code></pre></div><p><a href="/book/commands/wrap.html"><code>wrap</code></a>命令将一个列表转换为一个表格。每个列表的值将都会被转换为一个单独的行和列：</p>
<div><pre><code><span>let</span> zones <span>=</span> <span>[</span>UTC CET Europe/Moscow Asia/Yekaterinburg<span>]</span>

<span># Show world clock for selected time zones</span>
<span>$zones</span> <span>|</span> wrap <span>'Zone'</span> <span>|</span> upsert Time <span>{</span><span>|</span>it<span>|</span>
    <span>(</span>
        <span>date</span> now
            <span>|</span> <span>date</span> to-timezone <span>$it</span>.Zone
            <span>|</span> <span>date</span> <span>format</span> <span>'%Y.%m.%d %H:%M'</span>
    <span>)</span>
<span>}</span>
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">处理字符串</title>
    <id>www.nushell.sh/zh-CN/book/working_with_strings.html</id>
    <link href="www.nushell.sh/zh-CN/book/working_with_strings.html"/>
    <updated>2022-06-04T13:17:54.525Z</updated>
    <content type="html"><![CDATA[<h1 id="处理字符串" tabindex="-1"> 处理字符串</h1>
<p>Nushell 中的字符串用于保存文本数据以便后续使用，其中可以包括文件名、文件路径、列名以及更多。字符串是如此地普遍，以至于 Nushell 提供了几种处理它们的方法，你可以从中选择最合适的。</p>
<h2 id="单引号字符串" tabindex="-1"> 单引号字符串</h2>
<p>Nushell 中最简单的字符串是单引号字符串。这种字符串使用<code>'</code>字符来包裹文本。下面是作为单引号字符串的<code>hello world</code>示例：</p>
<div><pre><code><span>></span> <span>'hello world'</span>
hello world
</code></pre></div><p>单引号字符串不会对它们所给予的文本做任何事情，这使得它们成为容纳广泛文本数据的理想选择。</p>
<h2 id="双引号字符串" tabindex="-1"> 双引号字符串</h2>
<p>对于更复杂的字符串，Nushell 也提供双引号字符串。这些字符串使用<code>&quot;</code>字符来包裹文本。它们还支持使用<code>\</code>字符在文本中转义。</p>
<p>例如，我们可以用转义字符和双引号字符串写出文字 hello，然后换行，再写上 world：</p>
<div><pre><code><span>></span> <span>"hello<span title="\n">\n</span>world"</span>
hello
world
</code></pre></div><p>转义字符让你快速添加一个非此难以输入的字符。</p>
<p>Nushell 目前支持以下转义字符：</p>
<ul>
<li><code>\&quot;</code> - 双引号</li>
<li><code>\'</code> - 单引号</li>
<li><code>\\</code> - 反斜杠</li>
<li><code>\/</code> - 斜杠</li>
<li><code>\b</code> - 退格字符</li>
<li><code>\f</code> - 换页符</li>
<li><code>\r</code> - 回车符</li>
<li><code>\n</code> - 换行符 (line feed)</li>
<li><code>\t</code> - 制表符</li>
<li><code>\uXXXX</code> - Unicode 字符 (用 Unicode 字符的编号替换 XXXX)</li>
</ul>
<h2 id="字符串插值" tabindex="-1"> 字符串插值</h2>
<p>更复杂的字符串用例还需要一种新的字符串形式：字符串插值。这是一种从原始文本和执行表达式的结果中构建文本的方法。字符串插值将这些结果结合在一起，返回一个新的字符串。</p>
<p>字符串插值使用 <code>$&quot; &quot;</code> 和 <code>$' '</code> 作为包裹插值文本的方式。</p>
<p>例如，假设我们有一个叫做<code>$name</code>的变量，我们想问候这个变量中所包含的人：</p>
<div><pre><code><span>></span> <span>let</span> name <span>=</span> <span>"Alice"</span>
<span>></span> $<span>"greetings, (<span>$name</span>)"</span>
greetings, Alice
</code></pre></div><p>通过使用<code>()</code>包裹表达式，我们可以运行它们并使用结果来帮助生成字符串。</p>
<p>字符串插值有单引号：<code>$' '</code> 和双引号：<code>$&quot; &quot;</code> 这两种形式，分别对应于单引号和双引号字符串 —— 单引号字符串插值不支持转义字符，而双引号字符串插值支持。</p>
<p>从 0.61 版开始，字符串插值支持转义小括号，所以<code>(</code>和<code>)</code>字符可以在一个字符串中使用，而 Nushell 不会试图计算它们之间出现的内容：</p>
<div><pre><code><span>></span> $<span>"2 + 2 is (2 + 2) \(you guessed it!)"</span>
<span>2</span> + <span>2</span> is <span>4</span> <span>(</span>you guessed it<span>!</span><span>)</span>
</code></pre></div><h2 id="分割字符串" tabindex="-1"> 分割字符串</h2>
<p><a href="/book/commands/split_row.html"><code>split row</code></a>命令从一个基于分隔符的字符串创建一个列表。
例如，<code>let colors = (&quot;red,green,blue&quot; | split row &quot;,&quot;)</code> 创建列表<code>[red green blue]</code>。</p>
<p><a href="/book/commands/split_column.html"><code>split column</code></a>命令将从一个基于分隔符的字符串中创建一个表。例如，<code>let colors = (&quot;red,green,blue&quot; | split column &quot;,&quot;)</code> 创建一个表格，并为每个元素添加一列。</p>
<p>最后, <a href="/book/commands/split_chars.html"><code>split chars</code></a>命令将一个字符串分割成一个字符列表。</p>
<h2 id="str-命令" tabindex="-1"> <code>str</code> 命令</h2>
<p>许多字符串函数是<code>str</code>命令的子命令，你可以使用<code>help str</code>来获得一个完整的 <code>str</code> 命令列表。</p>
<p>例如, 你可以使用<code>str contains</code>来检查一个字符串是否包含某个特定的字符：</p>
<div><pre><code><span>></span> <span>"hello world"</span> <span>|</span> str contains <span>"w"</span>
<span>true</span>
</code></pre></div>]]></content>
  </entry>
  <entry>
    <title type="html">处理表格</title>
    <id>www.nushell.sh/zh-CN/book/working_with_tables.html</id>
    <link href="www.nushell.sh/zh-CN/book/working_with_tables.html"/>
    <updated>2022-06-04T13:17:54.525Z</updated>
    <content type="html"><![CDATA[<h1 id="处理表格" tabindex="-1"> 处理表格</h1>
<p>在 Nu 中查看数据的一种常见方式是通过表格。Nu 提供了许多处理表格的命令以方便找到你想要的内容以及将数据缩小到你需要的范围。</p>
<p>首先，让我们获得一个可用的表：</p>
<div><pre><code>> ls
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ files.rs      │ File │  4.6 KB │ 5 days ago
 1 │ lib.rs        │ File │   330 B │ 5 days ago
 2 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 3 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
 4 │ path.rs       │ File │  2.1 KB │ 5 days ago
 5 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 6 │ signature.rs  │ File │  1.2 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────
</code></pre></div><h2 id="排序" tabindex="-1"> 排序</h2>
<p>我们可以通过调用<a href="/book/commands/sort-by.html"><code>sort-by</code></a>命令对一个表进行排序，并指定需要排序的列。比如，按照文件的大小对表格进行排序：</p>
<div><pre><code>> ls | sort-by size
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ lib.rs        │ File │   330 B │ 5 days ago
 1 │ signature.rs  │ File │  1.2 KB │ 5 days ago
 2 │ path.rs       │ File │  2.1 KB │ 5 days ago
 3 │ files.rs      │ File │  4.6 KB │ 5 days ago
 4 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 5 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 6 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
───┴───────────────┴──────┴─────────┴────────────
</code></pre></div><p>我们可以通过任何可以比较的列来对一个表进行排序。例如，我们也可以用 &quot;name&quot;, &quot;accessed&quot; 或者 &quot;modified&quot; 列对上述内容进行排序。</p>
<h2 id="选取" tabindex="-1"> 选取</h2>
<p>我们可以从表中通过选择特定的列或行来获得数据。让我们从表中选择（<a href="/book/commands/select.html"><code>select</code></a>）几列吧：</p>
<div><pre><code>> ls | select name size
───┬───────────────┬─────────
 # │ name          │ size
───┼───────────────┼─────────
 0 │ files.rs      │  4.6 KB
 1 │ lib.rs        │   330 B
 2 │ lite_parse.rs │  6.3 KB
 3 │ parse.rs      │ 49.8 KB
 4 │ path.rs       │  2.1 KB
 5 │ shapes.rs     │  4.7 KB
 6 │ signature.rs  │  1.2 KB
───┴───────────────┴─────────
</code></pre></div><p>这有助于创建一个更专注于我们所需的表格。接下来，假设我们只想看这个目录中最小的 5 个文件：</p>
<div><pre><code>> ls | sort-by size | first 5
───┬──────────────┬──────┬────────┬────────────
 # │ name         │ type │ size   │ modified
───┼──────────────┼──────┼────────┼────────────
 0 │ lib.rs       │ File │  330 B │ 5 days ago
 1 │ signature.rs │ File │ 1.2 KB │ 5 days ago
 2 │ path.rs      │ File │ 2.1 KB │ 5 days ago
 3 │ files.rs     │ File │ 4.6 KB │ 5 days ago
 4 │ shapes.rs    │ File │ 4.7 KB │ 5 days ago
───┴──────────────┴──────┴────────┴────────────
</code></pre></div><p>你会注意到我们首先按大小对表进行排序以得到最小的文件，然后我们用<code>first 5</code>来返回表的前 5 行。</p>
<p>你也可以跳过(<code>skip</code>)不需要的行，让我们跳过上面所得 5 行中的前两行：</p>
<div><pre><code>> ls | sort-by size | first 5 | skip 2
───┬───────────┬──────┬────────┬────────────
 # │ name      │ type │ size   │ modified
───┼───────────┼──────┼────────┼────────────
 0 │ path.rs   │ File │ 2.1 KB │ 5 days ago
 1 │ files.rs  │ File │ 4.6 KB │ 5 days ago
 2 │ shapes.rs │ File │ 4.7 KB │ 5 days ago
───┴───────────┴──────┴────────┴────────────
</code></pre></div><p>我们已将其缩小为我们关心的三行。</p>
<p>让我们看看其他几个用于选择数据的命令。您可能想知道为什么选取表格的行是通过数字，这是选择单行数据的便捷方式。让我们按文件名对表进行排序，然后使用 <code>select</code> 命令通过行号来选择其中的一行：</p>
<div><pre><code>> ls | sort-by name
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ files.rs      │ File │  4.6 KB │ 5 days ago
 1 │ lib.rs        │ File │   330 B │ 5 days ago
 2 │ lite_parse.rs │ File │  6.3 KB │ 5 days ago
 3 │ parse.rs      │ File │ 49.8 KB │ 1 day ago
 4 │ path.rs       │ File │  2.1 KB │ 5 days ago
 5 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
 6 │ signature.rs  │ File │  1.2 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────

> ls | sort-by name | select 5
───┬───────────────┬──────┬─────────┬────────────
 # │ name          │ type │ size    │ modified
───┼───────────────┼──────┼─────────┼────────────
 0 │ shapes.rs     │ File │  4.7 KB │ 5 days ago
───┴───────────────┴──────┴─────────┴────────────
</code></pre></div><h2 id="从表格提取数据" tabindex="-1"> 从表格提取数据</h2>
<p>到目前为止，我们在处理表格时都是将表格修剪成我们需要的样子。有时我们可能想更进一步，只看单元格本身的值，而不是取整列。比如，我们只想得到一个包含所有文件名的列表。在此，我们使用<a href="/book/commands/get.html"><code>get</code></a> 命令：</p>
<div><pre><code>> ls | get name
───┬───────────────
 0 │ files.rs
 1 │ lib.rs
 2 │ lite_parse.rs
 3 │ parse.rs
 4 │ path.rs
 5 │ shapes.rs
 6 │ signature.rs
───┴───────────────
</code></pre></div><p>现在我们获得了每一个文件的文件名。</p>
<p>这可能看起来很像我们之前使用的<a href="/book/commands/select.html"><code>select</code></a>命令，所以也把它放在这里以便于比较：</p>
<div><pre><code>> ls | select name
───┬───────────────
 # │ name
───┼───────────────
 0 │ files.rs
 1 │ lib.rs
 2 │ lite_parse.rs
 3 │ parse.rs
 4 │ path.rs
 5 │ shapes.rs
 6 │ signature.rs
───┴───────────────
</code></pre></div><p>这看起来非常相似！让我们看看能不能把这两个命令的区别说清楚：</p>
<ul>
<li><a href="/book/commands/select.html"><code>select</code></a> - 创建一个只包括指定列的新表；</li>
<li><a href="/book/commands/get.html"><code>get</code></a> - 以列表形式返回指定列内的值；</li>
</ul>
<p>区分这些表格的方法是 —— 列名没有了，也让我们知道这是一个我们可以处理的值的列表。</p>
<p><a href="/book/commands/get.html"><code>get</code></a>命令可以更进一步，它可以接受表中更深的数据路径。这简化了对复杂数据的处理，比如那些你可能在.json 文件中发现的结构。</p>
<h2 id="修改表格数据" tabindex="-1"> 修改表格数据</h2>
<p>除了从表中选择数据外，还可以更新其中的数据。我们可能想合并表格，添加新的列，或编辑单元格的内容等。在 Nushell 中，本节中的每个命令都会在管道中返回一个新的表而非对原表进行编辑。</p>
<h3 id="拼接表格" tabindex="-1"> 拼接表格</h3>
<p>我们可以使用<a href="/book/commands/append.html"><code>append</code></a>将列名相同的表拼接起来：</p>
<div><pre><code>> let $first = [[a b]; [1 2]]
> let $second = [[a b]; [3 4]]
> $first | append $second
───┬───┬───
 # │ a │ b
───┼───┼───
 0 │ 1 │ 2
 1 │ 3 │ 4
───┴───┴───
</code></pre></div><h3 id="合并表格" tabindex="-1"> 合并表格</h3>
<p>我们可以使用<a href="/book/commands/merge.html"><code>merge</code></a>命令将两个（或多个）表格合并在一起：</p>
<div><pre><code><span>></span> <span>let</span> <span>$first</span> <span>=</span> <span>[</span><span>[</span>a b<span>]</span><span>;</span> <span>[</span><span>1</span> <span>2</span><span>]</span><span>]</span>
<span>></span> <span>let</span> <span>$second</span> <span>=</span> <span>[</span><span>[</span>c d<span>]</span><span>;</span> <span>[</span><span>3</span> <span>4</span><span>]</span><span>]</span>
<span>></span> <span>$first</span> <span>|</span> merge <span>{</span> <span>$second</span> <span>}</span>
───┬───┬───┬───┬───
 <span># │ a │ b │ c │ d</span>
───┼───┼───┼───┼───
 <span>0</span> │ <span>1</span> │ <span>2</span> │ <span>3</span> │ <span>4</span>
───┴───┴───┴───┴───
</code></pre></div><p>让我们再加一个表格吧：</p>
<div><pre><code><span>></span> <span>let</span> <span>$third</span> <span>=</span> <span>[</span><span>[</span>e f<span>]</span><span>;</span> <span>[</span><span>5</span> <span>6</span><span>]</span><span>]</span>
</code></pre></div><p>我们可以将以上三个表格合并在一起，操作如下：</p>
<div><pre><code><span>></span> <span>$first</span> <span>|</span> merge <span>{</span> <span>$second</span> <span>}</span> <span>|</span> merge <span>{</span> <span>$third</span> <span>}</span>
───┬───┬───┬───┬───┬───┬───
 <span># │ a │ b │ c │ d │ e │ f</span>
───┼───┼───┼───┼───┼───┼───
 <span>0</span> │ <span>1</span> │ <span>2</span> │ <span>3</span> │ <span>4</span> │ <span>5</span> │ <span>6</span>
───┴───┴───┴───┴───┴───┴───
</code></pre></div><p>或者我们可以使用<a href="/book/commands/reduce.html"><code>reduce</code></a>命令来动态地合并所有的表格：</p>
<div><pre><code><span>></span> <span>[</span><span>$first</span> <span>$second</span> <span>$third</span><span>]</span> <span>|</span> reduce <span>{</span><span>|</span>it, acc<span>|</span> <span>$acc</span> <span>|</span> merge <span>{</span> <span>$it</span> <span>}</span><span>}</span>
───┬───┬───┬───┬───┬───┬───
 <span># │ a │ b │ c │ d │ e │ f</span>
───┼───┼───┼───┼───┼───┼───
 <span>0</span> │ <span>1</span> │ <span>2</span> │ <span>3</span> │ <span>4</span> │ <span>5</span> │ <span>6</span>
───┴───┴───┴───┴───┴───┴───
</code></pre></div><h3 id="添加新列" tabindex="-1"> 添加新列</h3>
<p>我们可以使用<a href="/book/commands/insert.html"><code>insert</code></a>命令在表中增加新列，让我们看一个例子：</p>
<div><pre><code>> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
</code></pre></div><p>让我们添加一个名为 &quot;next_edition&quot; 的列并将 2021 作为值：</p>
<div><pre><code>> open rustfmt.toml | insert next_edition 2021
──────────────┬──────
 edition      │ 2018
 next_edition │ 2021
──────────────┴──────
</code></pre></div><p>注意，我们如果打开原始文件，会发现内容没变：</p>
<div><pre><code>> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
</code></pre></div><p>Nu 的更改是函数性更改，这意味着它们只在值上起作用，而不是试图引起永久性变更。这使我们可以在管道中进行许多不同类型的操作直到我们准备好将结果输出(如果我们选择这样做的话)。这里我们可以使用 <a href="/book/commands/save.html"><code>save</code></a> 命令保存结果：</p>
<div><pre><code>> open rustfmt.toml | insert next_edition 2021 | save rustfmt2.toml
> open rustfmt2.toml
──────────────┬──────
 edition      │ 2018
 next_edition │ 2021
──────────────┴──────
</code></pre></div><h3 id="更新一列" tabindex="-1"> 更新一列</h3>
<p>与<a href="/book/commands/insert.html"><code>insert</code></a>命令类似，我们也可以使用<a href="/book/commands/update.html"><code>update</code></a>命令将某一列的内容修改为新值。为了看看效果，让我们打开同一个文件：</p>
<div><pre><code>> open rustfmt.toml
─────────┬──────
 edition │ 2018
─────────┴──────
</code></pre></div><p>现在，用我们希望支持的下一个版本更新 edition：</p>
<div><pre><code>> open rustfmt.toml | update edition 2021
─────────┬──────
 edition │ 2021
─────────┴──────
</code></pre></div><p>你也可以使用<a href="/book/commands/upsert.html"><code>upsert</code></a>命令来插入或更新，这取决于该列是否已经存在。</p>
<h3 id="移动列" tabindex="-1"> 移动列</h3>
<p>你可以使用<code>move</code>来移动表中的列。例如，如果想把<code>ls</code>中的 &quot;name&quot; 列移到 &quot;size&quot; 列之后，我们可以这样做：</p>
<div><pre><code>> ls | move name --after size
╭────┬──────┬─────────┬───────────────────┬──────────────╮
│ #  │ type │  size   │       name        │   modified   │
├────┼──────┼─────────┼───────────────────┼──────────────┤
│  0 │ dir  │   256 B │ Applications      │ 3 days ago   │
│  1 │ dir  │   256 B │ Data              │ 2 weeks ago  │
│  2 │ dir  │   448 B │ Desktop           │ 2 hours ago  │
│  3 │ dir  │   192 B │ Disks             │ a week ago   │
│  4 │ dir  │   416 B │ Documents         │ 4 days ago   │
...
</code></pre></div><h3 id="重命名列" tabindex="-1"> 重命名列</h3>
<p>你也可以通过<code>rename</code>命令对表中的列进行<strong>重命名</strong>。我们可以使用这个例子来运行<code>ls</code>并重命名这些列：</p>
<div><pre><code>> ls | rename filename filetype filesize date
╭────┬───────────────────┬──────────┬──────────┬──────────────╮
│ #  │     filename      │ filetype │ filesize │     date     │
├────┼───────────────────┼──────────┼──────────┼──────────────┤
│  0 │ Applications      │ dir      │    256 B │ 3 days ago   │
│  1 │ Data              │ dir      │    256 B │ 2 weeks ago  │
│  2 │ Desktop           │ dir      │    448 B │ 2 hours ago  │
│  3 │ Disks             │ dir      │    192 B │ a week ago   │
│  4 │ Documents         │ dir      │    416 B │ 4 days ago   │
...
</code></pre></div>]]></content>
  </entry>
</feed>