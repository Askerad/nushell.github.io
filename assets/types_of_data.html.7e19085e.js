import{_ as l,r as o,o as c,c as r,a as e,b as t,w as s,d as a,e as d}from"./app.f7ef80e9.js";const u={},h=e("h1",{id:"types-of-data",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#types-of-data","aria-hidden":"true"},"#"),a(" Types of Data")],-1),p=e("p",null,"Traditionally, Unix shell commands have communicated with each other using strings of text: one command would write text to standard output (often abbreviated 'stdout') and the other would read text from standard input (or 'stdin'), allowing the two commands to communicate.",-1),m=e("p",null,"Nu embraces this approach, and expands it to include other types of data, in addition to strings.",-1),b=e("p",null,"Like many programming languages, Nu models data using a set of simple, and structured data types. Simple data types include integers, floats, strings, booleans, dates. There are also special types for filesizes and time durations.",-1),g=a("The "),f=e("code",null,"describe",-1),x=a(" command returns the type of a data value:"),y=d(`<div class="language-text ext-text"><pre class="language-text"><code>&gt; 42 | describe
</code></pre></div><h2 id="integers" tabindex="-1"><a class="header-anchor" href="#integers" aria-hidden="true">#</a> Integers</h2><p>Examples of integers (i.e. &quot;round numbers&quot;) include 1, 0, -5, and 100. You can parse a string into an integer with the <code>into int</code> command</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; &quot;-5&quot; | into int
</code></pre></div><h2 id="decimals" tabindex="-1"><a class="header-anchor" href="#decimals" aria-hidden="true">#</a> Decimals</h2><p>Decimal numbers are numbers with some fractional component. Examples include 1.5, 2.0, and 15.333. You can cast a string into an Decimal with the <code>into decimal</code> command</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; &quot;1.2&quot; | into decimal
</code></pre></div><h2 id="strings" tabindex="-1"><a class="header-anchor" href="#strings" aria-hidden="true">#</a> Strings</h2><p>A string of characters that represents text. There are a few ways these can be constructed:</p><ul><li>Double quotes <ul><li><code>&quot;Line1\\nLine2\\n&quot;</code></li></ul></li><li>Single quotes <code>&#39;She said &quot;Nushell is the future&quot;.&#39;</code></li><li>Dynamic string interpolation <ul><li><code>$&quot;6 x 7 = (6 * 7)&quot;</code></li><li><code>ls | each { |it| $&quot;($it.name) is ($it.size)&quot; }</code></li></ul></li><li>Bare strings <ul><li><code>echo hello</code></li></ul></li></ul>`,10),k=a("See "),_=a("Working with strings"),v=a(" and "),w={href:"https://www.nushell.sh/book/loading_data.html#handling-strings",target:"_blank",rel:"noopener noreferrer"},q=a("Handling Strings"),T=a(" for details."),z=d(`<h2 id="booleans" tabindex="-1"><a class="header-anchor" href="#booleans" aria-hidden="true">#</a> Booleans</h2><p>There are just two boolean values: <code>true</code> and <code>false</code>. Rather than writing the values directly, they often result from a comparison:</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> mybool <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">1</span>
<span class="token operator">&gt;</span> <span class="token variable">$mybool</span>
<span class="token boolean">true</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">let</span> mybool <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token variable">$env</span><span class="token builtin class-name">.</span><span class="token environment constant">HOME</span> <span class="token operator">|</span> path exists<span class="token punctuation">)</span>
<span class="token operator">&gt;</span> <span class="token variable">$mybool</span>
<span class="token boolean">true</span>
</code></pre></div><h2 id="dates" tabindex="-1"><a class="header-anchor" href="#dates" aria-hidden="true">#</a> Dates</h2><p>Dates and times are held together in the Date value type. Date values used by the system are timezone-aware, and by default use the UTC timezone.</p><p>Dates are in three forms, based on the RFC 3339 standard:</p><ul><li>A date: <ul><li><code>2022-02-02</code></li></ul></li><li>A date and time (in GMT): <ul><li><code>2022-02-02T14:30:00</code></li></ul></li><li>A date and time with timezone: <ul><li><code>2022-02-02T14:30:00+05:00</code></li></ul></li></ul><h2 id="durations" tabindex="-1"><a class="header-anchor" href="#durations" aria-hidden="true">#</a> Durations</h2><p>Durations represent a length of time. This chart shows all durations currently supported:</p><table><thead><tr><th>Duration</th><th>Length</th></tr></thead><tbody><tr><td><code>1ns</code></td><td>one nanosecond</td></tr><tr><td><code>1us</code></td><td>one microsecond</td></tr><tr><td><code>1ms</code></td><td>one millisecond</td></tr><tr><td><code>1sec</code></td><td>one second</td></tr><tr><td><code>1min</code></td><td>one minute</td></tr><tr><td><code>1hr</code></td><td>one hour</td></tr><tr><td><code>1day</code></td><td>one day</td></tr><tr><td><code>1wk</code></td><td>one week</td></tr></tbody></table><p>You can make fractional durations:</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token number">3</span>.14day
3day 3hr 21min
</code></pre></div><p>And you can do calculations with durations:</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> 30day / 1sec  <span class="token comment"># How many seconds in 30 days?</span>
<span class="token number">2592000</span>
</code></pre></div><h2 id="file-sizes" tabindex="-1"><a class="header-anchor" href="#file-sizes" aria-hidden="true">#</a> File sizes</h2><p>Nushell also has a special type for file sizes. Examples include <code>100b</code>, <code>15kb</code>, and <code>100mb</code>.</p><p>The full list of filesize units are:</p><ul><li><code>b</code>: bytes</li><li><code>kb</code>: kilobytes (aka 1000 bytes)</li><li><code>mb</code>: megabytes</li><li><code>gb</code>: gigabytes</li><li><code>tb</code>: terabytes</li><li><code>pb</code>: petabytes</li><li><code>eb</code>: exabytes</li><li><code>zb</code>: zettabyte</li><li><code>kib</code>: kibibytes (aka 1024 bytes)</li><li><code>mib</code>: mebibytes</li><li><code>gib</code>: gibibytes</li><li><code>tib</code>: tebibytes</li><li><code>pib</code>: pebibytes</li><li><code>eib</code>: exbibyte</li><li><code>zib</code>: zebibyte</li></ul><p>As with durations, you can make fractional file sizes, and do calculations:</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> 1Gb / 1b
<span class="token number">1000000000</span>
<span class="token operator">&gt;</span> 1Gib / 1b
<span class="token number">1073741824</span>
<span class="token operator">&gt;</span> <span class="token punctuation">(</span>1Gib / 1b<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span> ** <span class="token number">30</span>
<span class="token boolean">true</span>
</code></pre></div><h2 id="ranges" tabindex="-1"><a class="header-anchor" href="#ranges" aria-hidden="true">#</a> Ranges</h2><p>A range is a way of expressing a sequence of values from start to finish. They take the form &lt;start&gt;..&lt;end&gt;. For example, the range <code>1..3</code> means the numbers 1, 2, and 3.</p><h3 id="inclusive-and-non-inclusive-ranges" tabindex="-1"><a class="header-anchor" href="#inclusive-and-non-inclusive-ranges" aria-hidden="true">#</a> Inclusive and non-inclusive ranges</h3><p>Ranges are inclusive by default, meaning that the ending value is counted as part of the range. The range <code>1..3</code> includes the number <code>3</code> as the last value in the range.</p><p>Sometimes, you may want a range that is limited by a number but doesn&#39;t use that number in the output. For this, you can use <code>..&lt;</code> instead of <code>..</code>. For example, <code>1..&lt;5</code> is the numbers 1, 2, 3, and 4.</p><h3 id="open-ended-ranges" tabindex="-1"><a class="header-anchor" href="#open-ended-ranges" aria-hidden="true">#</a> Open-ended ranges</h3><p>Ranges can also be open-ended. You can remove the start or the end of the range to make it open-ended.</p><p>Let&#39;s say you wanted to start counting at 3, but you didn&#39;t have a specific end in mind. You could use the range <code>3..</code> to represent this. When you use a range that&#39;s open-ended on the right side, remember that this will continue counting for as long as possible, which could be a very long time! You&#39;ll often want to use open-ended ranges with commands like <code>take</code>, so you can take the number of elements you want from the range.</p><p>You can also make the start of the range open. In this case, Nushell will start counting with <code>0</code>. For example, the range <code>..2</code> is the numbers 0, 1, and 2.</p><h2 id="binary-data" tabindex="-1"><a class="header-anchor" href="#binary-data" aria-hidden="true">#</a> Binary data</h2><p>Binary data, like the data from an image file, is a group of raw bytes.</p><p>You can write binary as a literal using any of the <code>0x[...]</code>, <code>0b[...]</code>, or <code>0o[...]</code> forms:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; 0x[1F FF]  # Hexadecimal
&gt; 0b[1 1010] # Binary
&gt; 0o[777]    # Octal
</code></pre></div><p>Incomplete bytes will be left-padded with zeros.</p><h2 id="structured-data" tabindex="-1"><a class="header-anchor" href="#structured-data" aria-hidden="true">#</a> Structured data</h2><p>Structured data builds from the simple data. For example, instead of a single integer, structured data gives us a way to represent multiple integers in the same value. Here&#39;s a list of the currently supported structured data types: records, lists and tables.</p><h2 id="records" tabindex="-1"><a class="header-anchor" href="#records" aria-hidden="true">#</a> Records</h2><p>Records hold key-value pairs, much like objects in JSON. As these can sometimes have many fields, a record is printed up-down rather than left-right:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; echo {name: sam, rank: 10}
\u256D\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u256E
\u2502 name \u2502 sam \u2502
\u2502 rank \u2502 10  \u2502
\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u256F
</code></pre></div><p>You can iterate over records by first transposing it into a table:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; echo {name: sam, rank: 10} | transpose key value
\u256D\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256E
\u2502 # \u2502 key  \u2502 value \u2502
\u251C\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524
\u2502 0 \u2502 name \u2502  sam  \u2502
\u2502 1 \u2502 rank \u2502   10  \u2502
\u2570\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256F
</code></pre></div><h2 id="lists" tabindex="-1"><a class="header-anchor" href="#lists" aria-hidden="true">#</a> Lists</h2><p>Lists can hold more than one value. These can be simple values. They can also hold rows, and the combination of a list of records is often called a &quot;table&quot;.</p><p>Example: a list of strings</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; echo [sam fred george]
\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
 0 \u2502 sam
 1 \u2502 fred
 2 \u2502 george
\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
</code></pre></div><h2 id="tables" tabindex="-1"><a class="header-anchor" href="#tables" aria-hidden="true">#</a> Tables</h2><p>The table is a core data structure in Nushell. As you run commands, you&#39;ll see that many of them return tables as output. A table has both rows and columns.</p><p>We can create our own tables similarly to how we create a list. Because tables also contain columns and not just values, we pass in the name of the column values:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; echo [[column1, column2]; [Value1, Value2]]
\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
 # \u2502 column1 \u2502 column2
\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
 0 \u2502 Value1  \u2502 Value2
\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
</code></pre></div><p>We can also create a table with multiple rows of data:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; echo [[column1, column2]; [Value1, Value2] [Value3, Value4]]
\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
 # \u2502 column1 \u2502 column2
\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
 0 \u2502 Value1  \u2502 Value2
 1 \u2502 Value3  \u2502 Value4
\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
</code></pre></div><p>You can also create a table as a list of records:</p><div class="language-text ext-text"><pre class="language-text"><code>&gt; echo [{name: sam, rank: 10}, {name: bob, rank: 7}]
\u256D\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u256E
\u2502 # \u2502 name \u2502 rank \u2502
\u251C\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2524
\u2502 0 \u2502 sam  \u2502   10 \u2502
\u2502 1 \u2502 bob  \u2502    7 \u2502
\u2570\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u256F
</code></pre></div><h3 id="column-paths" tabindex="-1"><a class="header-anchor" href="#column-paths" aria-hidden="true">#</a> Column paths</h3><p>Column paths are a path through the table to a specific sub-table, column, row, or cell. E.g. the value <code>foo.0.bar</code> in <code>open data.toml | get foo.0.bar</code></p><h2 id="blocks" tabindex="-1"><a class="header-anchor" href="#blocks" aria-hidden="true">#</a> Blocks</h2><p>Blocks represent a block of code in Nu. For example, in the command <code>each { |it| echo $it }</code> the block is the portion contained in curly braces, <code>{ |it| echo $it }</code>. Block parameters are specified between a pair of pipe symbols (for example, <code>|it|</code>) if necessary.</p>`,57),V=a("Blocks are a useful way to represent code that can be executed on each row of data. It is idiomatic to use "),D=e("code",null,"$it",-1),B=a(" as a parameter name in "),N=e("code",null,"each",-1),$=a(" blocks, but not required; "),F=e("code",null,"each { |x| echo $x }",-1),L=a(" works the same way as "),S=e("code",null,"each { |it| echo $it }",-1),A=a(".");function Y(E,R){const n=o("RouterLink"),i=o("ExternalLinkIcon");return c(),r("div",null,[h,p,m,b,e("p",null,[g,t(n,{to:"/book/commands/describe.html"},{default:s(()=>[f]),_:1}),x]),y,e("p",null,[k,t(n,{to:"/book/working_with_strings.html"},{default:s(()=>[_]),_:1}),v,e("a",w,[q,t(i)]),T]),z,e("p",null,[V,D,B,t(n,{to:"/book/commands/each.html"},{default:s(()=>[N]),_:1}),$,F,L,S,A])])}const C=l(u,[["render",Y],["__file","types_of_data.html.vue"]]);export{C as default};
